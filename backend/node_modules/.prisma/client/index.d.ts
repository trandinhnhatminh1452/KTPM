
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model StaffProfile
 * 
 */
export type StaffProfile = $Result.DefaultSelection<Prisma.$StaffProfilePayload>
/**
 * Model StudentProfile
 * 
 */
export type StudentProfile = $Result.DefaultSelection<Prisma.$StudentProfilePayload>
/**
 * Model Building
 * 
 */
export type Building = $Result.DefaultSelection<Prisma.$BuildingPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model RoomAmenity
 * 
 */
export type RoomAmenity = $Result.DefaultSelection<Prisma.$RoomAmenityPayload>
/**
 * Model FeeRate
 * 
 */
export type FeeRate = $Result.DefaultSelection<Prisma.$FeeRatePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model UtilityMeterReading
 * 
 */
export type UtilityMeterReading = $Result.DefaultSelection<Prisma.$UtilityMeterReadingPayload>
/**
 * Model Maintenance
 * 
 */
export type Maintenance = $Result.DefaultSelection<Prisma.$MaintenancePayload>
/**
 * Model RoomTransfer
 * 
 */
export type RoomTransfer = $Result.DefaultSelection<Prisma.$RoomTransferPayload>
/**
 * Model VehicleRegistration
 * 
 */
export type VehicleRegistration = $Result.DefaultSelection<Prisma.$VehicleRegistrationPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model LoginLog
 * 
 */
export type LoginLog = $Result.DefaultSelection<Prisma.$LoginLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  STUDENT: 'STUDENT',
  STAFF: 'STAFF',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const StudentStatus: {
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  RENTING: 'RENTING',
  EVICTED: 'EVICTED',
  CHECKED_OUT: 'CHECKED_OUT'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const RoomType: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  MANAGEMENT: 'MANAGEMENT'
};

export type RoomType = (typeof RoomType)[keyof typeof RoomType]


export const RoomStatus: {
  AVAILABLE: 'AVAILABLE',
  FULL: 'FULL',
  UNDER_MAINTENANCE: 'UNDER_MAINTENANCE'
};

export type RoomStatus = (typeof RoomStatus)[keyof typeof RoomStatus]


export const FeeType: {
  ROOM_FEE: 'ROOM_FEE',
  ELECTRICITY: 'ELECTRICITY',
  WATER: 'WATER',
  PARKING: 'PARKING',
  OTHER_FEE: 'OTHER_FEE'
};

export type FeeType = (typeof FeeType)[keyof typeof FeeType]


export const PaymentType: {
  ROOM_FEE: 'ROOM_FEE',
  ELECTRICITY: 'ELECTRICITY',
  WATER: 'WATER',
  PARKING: 'PARKING',
  OTHER_FEE: 'OTHER_FEE'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const InvoiceStatus: {
  UNPAID: 'UNPAID',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const UtilityType: {
  ELECTRICITY: 'ELECTRICITY',
  WATER: 'WATER'
};

export type UtilityType = (typeof UtilityType)[keyof typeof UtilityType]


export const MaintenanceStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MaintenanceStatus = (typeof MaintenanceStatus)[keyof typeof MaintenanceStatus]


export const TransferStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const VehicleType: {
  BICYCLE: 'BICYCLE',
  MOTORBIKE: 'MOTORBIKE',
  ELECTRIC_BICYCLE: 'ELECTRIC_BICYCLE',
  CAR: 'CAR',
  OTHER: 'OTHER'
};

export type VehicleType = (typeof VehicleType)[keyof typeof VehicleType]


export const MediaType: {
  USER_AVATAR: 'USER_AVATAR',
  ROOM_IMAGE: 'ROOM_IMAGE',
  BUILDING_IMAGE: 'BUILDING_IMAGE',
  VEHICLE_IMAGE: 'VEHICLE_IMAGE',
  MAINTENANCE_IMAGE: 'MAINTENANCE_IMAGE',
  OTHER: 'OTHER'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type StudentStatus = $Enums.StudentStatus

export const StudentStatus: typeof $Enums.StudentStatus

export type RoomType = $Enums.RoomType

export const RoomType: typeof $Enums.RoomType

export type RoomStatus = $Enums.RoomStatus

export const RoomStatus: typeof $Enums.RoomStatus

export type FeeType = $Enums.FeeType

export const FeeType: typeof $Enums.FeeType

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type UtilityType = $Enums.UtilityType

export const UtilityType: typeof $Enums.UtilityType

export type MaintenanceStatus = $Enums.MaintenanceStatus

export const MaintenanceStatus: typeof $Enums.MaintenanceStatus

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type VehicleType = $Enums.VehicleType

export const VehicleType: typeof $Enums.VehicleType

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffProfile`: Exposes CRUD operations for the **StaffProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffProfiles
    * const staffProfiles = await prisma.staffProfile.findMany()
    * ```
    */
  get staffProfile(): Prisma.StaffProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentProfile`: Exposes CRUD operations for the **StudentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentProfiles
    * const studentProfiles = await prisma.studentProfile.findMany()
    * ```
    */
  get studentProfile(): Prisma.StudentProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.BuildingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomAmenity`: Exposes CRUD operations for the **RoomAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomAmenities
    * const roomAmenities = await prisma.roomAmenity.findMany()
    * ```
    */
  get roomAmenity(): Prisma.RoomAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeRate`: Exposes CRUD operations for the **FeeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeRates
    * const feeRates = await prisma.feeRate.findMany()
    * ```
    */
  get feeRate(): Prisma.FeeRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utilityMeterReading`: Exposes CRUD operations for the **UtilityMeterReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UtilityMeterReadings
    * const utilityMeterReadings = await prisma.utilityMeterReading.findMany()
    * ```
    */
  get utilityMeterReading(): Prisma.UtilityMeterReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance`: Exposes CRUD operations for the **Maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenances
    * const maintenances = await prisma.maintenance.findMany()
    * ```
    */
  get maintenance(): Prisma.MaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomTransfer`: Exposes CRUD operations for the **RoomTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTransfers
    * const roomTransfers = await prisma.roomTransfer.findMany()
    * ```
    */
  get roomTransfer(): Prisma.RoomTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleRegistration`: Exposes CRUD operations for the **VehicleRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleRegistrations
    * const vehicleRegistrations = await prisma.vehicleRegistration.findMany()
    * ```
    */
  get vehicleRegistration(): Prisma.VehicleRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginLog`: Exposes CRUD operations for the **LoginLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginLogs
    * const loginLogs = await prisma.loginLog.findMany()
    * ```
    */
  get loginLog(): Prisma.LoginLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    StaffProfile: 'StaffProfile',
    StudentProfile: 'StudentProfile',
    Building: 'Building',
    Room: 'Room',
    Amenity: 'Amenity',
    RoomAmenity: 'RoomAmenity',
    FeeRate: 'FeeRate',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    UtilityMeterReading: 'UtilityMeterReading',
    Maintenance: 'Maintenance',
    RoomTransfer: 'RoomTransfer',
    VehicleRegistration: 'VehicleRegistration',
    Media: 'Media',
    LoginLog: 'LoginLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "staffProfile" | "studentProfile" | "building" | "room" | "amenity" | "roomAmenity" | "feeRate" | "invoice" | "invoiceItem" | "payment" | "utilityMeterReading" | "maintenance" | "roomTransfer" | "vehicleRegistration" | "media" | "loginLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      StaffProfile: {
        payload: Prisma.$StaffProfilePayload<ExtArgs>
        fields: Prisma.StaffProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          findFirst: {
            args: Prisma.StaffProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          findMany: {
            args: Prisma.StaffProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          create: {
            args: Prisma.StaffProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          createMany: {
            args: Prisma.StaffProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          delete: {
            args: Prisma.StaffProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          update: {
            args: Prisma.StaffProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          deleteMany: {
            args: Prisma.StaffProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          upsert: {
            args: Prisma.StaffProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          aggregate: {
            args: Prisma.StaffProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffProfile>
          }
          groupBy: {
            args: Prisma.StaffProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StaffProfileCountAggregateOutputType> | number
          }
        }
      }
      StudentProfile: {
        payload: Prisma.$StudentProfilePayload<ExtArgs>
        fields: Prisma.StudentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findFirst: {
            args: Prisma.StudentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findMany: {
            args: Prisma.StudentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          create: {
            args: Prisma.StudentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          createMany: {
            args: Prisma.StudentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          delete: {
            args: Prisma.StudentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          update: {
            args: Prisma.StudentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          deleteMany: {
            args: Prisma.StudentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          upsert: {
            args: Prisma.StudentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          aggregate: {
            args: Prisma.StudentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentProfile>
          }
          groupBy: {
            args: Prisma.StudentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileCountAggregateOutputType> | number
          }
        }
      }
      Building: {
        payload: Prisma.$BuildingPayload<ExtArgs>
        fields: Prisma.BuildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findFirst: {
            args: Prisma.BuildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findMany: {
            args: Prisma.BuildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          create: {
            args: Prisma.BuildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          createMany: {
            args: Prisma.BuildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuildingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          delete: {
            args: Prisma.BuildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          update: {
            args: Prisma.BuildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          deleteMany: {
            args: Prisma.BuildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BuildingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          upsert: {
            args: Prisma.BuildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.BuildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      RoomAmenity: {
        payload: Prisma.$RoomAmenityPayload<ExtArgs>
        fields: Prisma.RoomAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          findFirst: {
            args: Prisma.RoomAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          findMany: {
            args: Prisma.RoomAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          create: {
            args: Prisma.RoomAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          createMany: {
            args: Prisma.RoomAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          delete: {
            args: Prisma.RoomAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          update: {
            args: Prisma.RoomAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          deleteMany: {
            args: Prisma.RoomAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>[]
          }
          upsert: {
            args: Prisma.RoomAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAmenityPayload>
          }
          aggregate: {
            args: Prisma.RoomAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomAmenity>
          }
          groupBy: {
            args: Prisma.RoomAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<RoomAmenityCountAggregateOutputType> | number
          }
        }
      }
      FeeRate: {
        payload: Prisma.$FeeRatePayload<ExtArgs>
        fields: Prisma.FeeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>
          }
          findFirst: {
            args: Prisma.FeeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>
          }
          findMany: {
            args: Prisma.FeeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>[]
          }
          create: {
            args: Prisma.FeeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>
          }
          createMany: {
            args: Prisma.FeeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>[]
          }
          delete: {
            args: Prisma.FeeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>
          }
          update: {
            args: Prisma.FeeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>
          }
          deleteMany: {
            args: Prisma.FeeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>[]
          }
          upsert: {
            args: Prisma.FeeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeRatePayload>
          }
          aggregate: {
            args: Prisma.FeeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeRate>
          }
          groupBy: {
            args: Prisma.FeeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeRateCountArgs<ExtArgs>
            result: $Utils.Optional<FeeRateCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      UtilityMeterReading: {
        payload: Prisma.$UtilityMeterReadingPayload<ExtArgs>
        fields: Prisma.UtilityMeterReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtilityMeterReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtilityMeterReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>
          }
          findFirst: {
            args: Prisma.UtilityMeterReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtilityMeterReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>
          }
          findMany: {
            args: Prisma.UtilityMeterReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>[]
          }
          create: {
            args: Prisma.UtilityMeterReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>
          }
          createMany: {
            args: Prisma.UtilityMeterReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UtilityMeterReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>[]
          }
          delete: {
            args: Prisma.UtilityMeterReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>
          }
          update: {
            args: Prisma.UtilityMeterReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>
          }
          deleteMany: {
            args: Prisma.UtilityMeterReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UtilityMeterReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UtilityMeterReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>[]
          }
          upsert: {
            args: Prisma.UtilityMeterReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilityMeterReadingPayload>
          }
          aggregate: {
            args: Prisma.UtilityMeterReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilityMeterReading>
          }
          groupBy: {
            args: Prisma.UtilityMeterReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilityMeterReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UtilityMeterReadingCountArgs<ExtArgs>
            result: $Utils.Optional<UtilityMeterReadingCountAggregateOutputType> | number
          }
        }
      }
      Maintenance: {
        payload: Prisma.$MaintenancePayload<ExtArgs>
        fields: Prisma.MaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findFirst: {
            args: Prisma.MaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findMany: {
            args: Prisma.MaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          create: {
            args: Prisma.MaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          createMany: {
            args: Prisma.MaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          delete: {
            args: Prisma.MaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          update: {
            args: Prisma.MaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          aggregate: {
            args: Prisma.MaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance>
          }
          groupBy: {
            args: Prisma.MaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCountAggregateOutputType> | number
          }
        }
      }
      RoomTransfer: {
        payload: Prisma.$RoomTransferPayload<ExtArgs>
        fields: Prisma.RoomTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>
          }
          findFirst: {
            args: Prisma.RoomTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>
          }
          findMany: {
            args: Prisma.RoomTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>[]
          }
          create: {
            args: Prisma.RoomTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>
          }
          createMany: {
            args: Prisma.RoomTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>[]
          }
          delete: {
            args: Prisma.RoomTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>
          }
          update: {
            args: Prisma.RoomTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>
          }
          deleteMany: {
            args: Prisma.RoomTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>[]
          }
          upsert: {
            args: Prisma.RoomTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTransferPayload>
          }
          aggregate: {
            args: Prisma.RoomTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomTransfer>
          }
          groupBy: {
            args: Prisma.RoomTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTransferCountArgs<ExtArgs>
            result: $Utils.Optional<RoomTransferCountAggregateOutputType> | number
          }
        }
      }
      VehicleRegistration: {
        payload: Prisma.$VehicleRegistrationPayload<ExtArgs>
        fields: Prisma.VehicleRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>
          }
          findFirst: {
            args: Prisma.VehicleRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>
          }
          findMany: {
            args: Prisma.VehicleRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>[]
          }
          create: {
            args: Prisma.VehicleRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>
          }
          createMany: {
            args: Prisma.VehicleRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>[]
          }
          delete: {
            args: Prisma.VehicleRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>
          }
          update: {
            args: Prisma.VehicleRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.VehicleRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.VehicleRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleRegistrationPayload>
          }
          aggregate: {
            args: Prisma.VehicleRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleRegistration>
          }
          groupBy: {
            args: Prisma.VehicleRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleRegistrationCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      LoginLog: {
        payload: Prisma.$LoginLogPayload<ExtArgs>
        fields: Prisma.LoginLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          findFirst: {
            args: Prisma.LoginLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          findMany: {
            args: Prisma.LoginLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>[]
          }
          create: {
            args: Prisma.LoginLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          createMany: {
            args: Prisma.LoginLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>[]
          }
          delete: {
            args: Prisma.LoginLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          update: {
            args: Prisma.LoginLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          deleteMany: {
            args: Prisma.LoginLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoginLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>[]
          }
          upsert: {
            args: Prisma.LoginLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginLogPayload>
          }
          aggregate: {
            args: Prisma.LoginLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginLog>
          }
          groupBy: {
            args: Prisma.LoginLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginLogCountArgs<ExtArgs>
            result: $Utils.Optional<LoginLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    staffProfile?: StaffProfileOmit
    studentProfile?: StudentProfileOmit
    building?: BuildingOmit
    room?: RoomOmit
    amenity?: AmenityOmit
    roomAmenity?: RoomAmenityOmit
    feeRate?: FeeRateOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    payment?: PaymentOmit
    utilityMeterReading?: UtilityMeterReadingOmit
    maintenance?: MaintenanceOmit
    roomTransfer?: RoomTransferOmit
    vehicleRegistration?: VehicleRegistrationOmit
    media?: MediaOmit
    loginLog?: LoginLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    loginLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginLogs?: boolean | UserCountOutputTypeCountLoginLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginLogWhereInput
  }


  /**
   * Count Type StaffProfileCountOutputType
   */

  export type StaffProfileCountOutputType = {
    assignedMaintenances: number
    approvedTransfers: number
  }

  export type StaffProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedMaintenances?: boolean | StaffProfileCountOutputTypeCountAssignedMaintenancesArgs
    approvedTransfers?: boolean | StaffProfileCountOutputTypeCountApprovedTransfersArgs
  }

  // Custom InputTypes
  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfileCountOutputType
     */
    select?: StaffProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountAssignedMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountApprovedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTransferWhereInput
  }


  /**
   * Count Type StudentProfileCountOutputType
   */

  export type StudentProfileCountOutputType = {
    invoices: number
    payments: number
    roomTransfers: number
    reportedMaintenances: number
    vehicleRegistrations: number
  }

  export type StudentProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | StudentProfileCountOutputTypeCountInvoicesArgs
    payments?: boolean | StudentProfileCountOutputTypeCountPaymentsArgs
    roomTransfers?: boolean | StudentProfileCountOutputTypeCountRoomTransfersArgs
    reportedMaintenances?: boolean | StudentProfileCountOutputTypeCountReportedMaintenancesArgs
    vehicleRegistrations?: boolean | StudentProfileCountOutputTypeCountVehicleRegistrationsArgs
  }

  // Custom InputTypes
  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfileCountOutputType
     */
    select?: StudentProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountRoomTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTransferWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountReportedMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountVehicleRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleRegistrationWhereInput
  }


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    images: number
    rooms: number
    staff: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | BuildingCountOutputTypeCountImagesArgs
    rooms?: boolean | BuildingCountOutputTypeCountRoomsArgs
    staff?: boolean | BuildingCountOutputTypeCountStaffArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffProfileWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    images: number
    residents: number
    amenities: number
    meterReadings: number
    invoices: number
    maintenances: number
    fromTransfers: number
    toTransfers: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | RoomCountOutputTypeCountImagesArgs
    residents?: boolean | RoomCountOutputTypeCountResidentsArgs
    amenities?: boolean | RoomCountOutputTypeCountAmenitiesArgs
    meterReadings?: boolean | RoomCountOutputTypeCountMeterReadingsArgs
    invoices?: boolean | RoomCountOutputTypeCountInvoicesArgs
    maintenances?: boolean | RoomCountOutputTypeCountMaintenancesArgs
    fromTransfers?: boolean | RoomCountOutputTypeCountFromTransfersArgs
    toTransfers?: boolean | RoomCountOutputTypeCountToTransfersArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountResidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenityWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountMeterReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilityMeterReadingWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountFromTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTransferWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountToTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTransferWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    rooms: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | AmenityCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenityWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type MaintenanceCountOutputType
   */

  export type MaintenanceCountOutputType = {
    images: number
  }

  export type MaintenanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | MaintenanceCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCountOutputType
     */
    select?: MaintenanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type VehicleRegistrationCountOutputType
   */

  export type VehicleRegistrationCountOutputType = {
    images: number
  }

  export type VehicleRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VehicleRegistrationCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * VehicleRegistrationCountOutputType without action
   */
  export type VehicleRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistrationCountOutputType
     */
    select?: VehicleRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleRegistrationCountOutputType without action
   */
  export type VehicleRegistrationCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    avatarFor: number
    roomImages: number
    buildingImages: number
    vehicleImages: number
    maintenanceImages: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFor?: boolean | MediaCountOutputTypeCountAvatarForArgs
    roomImages?: boolean | MediaCountOutputTypeCountRoomImagesArgs
    buildingImages?: boolean | MediaCountOutputTypeCountBuildingImagesArgs
    vehicleImages?: boolean | MediaCountOutputTypeCountVehicleImagesArgs
    maintenanceImages?: boolean | MediaCountOutputTypeCountMaintenanceImagesArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountAvatarForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountRoomImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountBuildingImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountVehicleImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleRegistrationWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountMaintenanceImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    avatarId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    avatarId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    avatarId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    avatarId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    resetToken: number
    resetTokenExpiry: number
    avatarId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    avatarId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    avatarId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    avatarId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    avatarId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    avatarId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: $Enums.Role
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    resetToken: string | null
    resetTokenExpiry: Date | null
    avatarId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    avatarId?: boolean
    avatar?: boolean | User$avatarArgs<ExtArgs>
    staffProfile?: boolean | User$staffProfileArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    loginLogs?: boolean | User$loginLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    avatarId?: boolean
    avatar?: boolean | User$avatarArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    avatarId?: boolean
    avatar?: boolean | User$avatarArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    avatarId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "isActive" | "createdAt" | "updatedAt" | "resetToken" | "resetTokenExpiry" | "avatarId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | User$avatarArgs<ExtArgs>
    staffProfile?: boolean | User$staffProfileArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    loginLogs?: boolean | User$loginLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | User$avatarArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | User$avatarArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      avatar: Prisma.$MediaPayload<ExtArgs> | null
      staffProfile: Prisma.$StaffProfilePayload<ExtArgs> | null
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs> | null
      loginLogs: Prisma.$LoginLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: $Enums.Role
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      resetToken: string | null
      resetTokenExpiry: Date | null
      avatarId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatar<T extends User$avatarArgs<ExtArgs> = {}>(args?: Subset<T, User$avatarArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffProfile<T extends User$staffProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$staffProfileArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentProfile<T extends User$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$studentProfileArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    loginLogs<T extends User$loginLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$loginLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly avatarId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.avatar
   */
  export type User$avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * User.staffProfile
   */
  export type User$staffProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * User.studentProfile
   */
  export type User$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * User.loginLogs
   */
  export type User$loginLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    where?: LoginLogWhereInput
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    cursor?: LoginLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model StaffProfile
   */

  export type AggregateStaffProfile = {
    _count: StaffProfileCountAggregateOutputType | null
    _avg: StaffProfileAvgAggregateOutputType | null
    _sum: StaffProfileSumAggregateOutputType | null
    _min: StaffProfileMinAggregateOutputType | null
    _max: StaffProfileMaxAggregateOutputType | null
  }

  export type StaffProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    managedBuildingId: number | null
  }

  export type StaffProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
    managedBuildingId: number | null
  }

  export type StaffProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    phoneNumber: string | null
    position: string | null
    identityCardNumber: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    address: string | null
    managedBuildingId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    phoneNumber: string | null
    position: string | null
    identityCardNumber: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    address: string | null
    managedBuildingId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    phoneNumber: number
    position: number
    identityCardNumber: number
    gender: number
    birthDate: number
    address: number
    managedBuildingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffProfileAvgAggregateInputType = {
    id?: true
    userId?: true
    managedBuildingId?: true
  }

  export type StaffProfileSumAggregateInputType = {
    id?: true
    userId?: true
    managedBuildingId?: true
  }

  export type StaffProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phoneNumber?: true
    position?: true
    identityCardNumber?: true
    gender?: true
    birthDate?: true
    address?: true
    managedBuildingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phoneNumber?: true
    position?: true
    identityCardNumber?: true
    gender?: true
    birthDate?: true
    address?: true
    managedBuildingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phoneNumber?: true
    position?: true
    identityCardNumber?: true
    gender?: true
    birthDate?: true
    address?: true
    managedBuildingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffProfile to aggregate.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffProfiles
    **/
    _count?: true | StaffProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffProfileMaxAggregateInputType
  }

  export type GetStaffProfileAggregateType<T extends StaffProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffProfile[P]>
      : GetScalarType<T[P], AggregateStaffProfile[P]>
  }




  export type StaffProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffProfileWhereInput
    orderBy?: StaffProfileOrderByWithAggregationInput | StaffProfileOrderByWithAggregationInput[]
    by: StaffProfileScalarFieldEnum[] | StaffProfileScalarFieldEnum
    having?: StaffProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffProfileCountAggregateInputType | true
    _avg?: StaffProfileAvgAggregateInputType
    _sum?: StaffProfileSumAggregateInputType
    _min?: StaffProfileMinAggregateInputType
    _max?: StaffProfileMaxAggregateInputType
  }

  export type StaffProfileGroupByOutputType = {
    id: number
    userId: number
    fullName: string
    phoneNumber: string | null
    position: string | null
    identityCardNumber: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    address: string | null
    managedBuildingId: number | null
    createdAt: Date
    updatedAt: Date
    _count: StaffProfileCountAggregateOutputType | null
    _avg: StaffProfileAvgAggregateOutputType | null
    _sum: StaffProfileSumAggregateOutputType | null
    _min: StaffProfileMinAggregateOutputType | null
    _max: StaffProfileMaxAggregateOutputType | null
  }

  type GetStaffProfileGroupByPayload<T extends StaffProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StaffProfileGroupByOutputType[P]>
        }
      >
    >


  export type StaffProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    position?: boolean
    identityCardNumber?: boolean
    gender?: boolean
    birthDate?: boolean
    address?: boolean
    managedBuildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    managedBuilding?: boolean | StaffProfile$managedBuildingArgs<ExtArgs>
    assignedMaintenances?: boolean | StaffProfile$assignedMaintenancesArgs<ExtArgs>
    approvedTransfers?: boolean | StaffProfile$approvedTransfersArgs<ExtArgs>
    _count?: boolean | StaffProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    position?: boolean
    identityCardNumber?: boolean
    gender?: boolean
    birthDate?: boolean
    address?: boolean
    managedBuildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    managedBuilding?: boolean | StaffProfile$managedBuildingArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    position?: boolean
    identityCardNumber?: boolean
    gender?: boolean
    birthDate?: boolean
    address?: boolean
    managedBuildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    managedBuilding?: boolean | StaffProfile$managedBuildingArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    position?: boolean
    identityCardNumber?: boolean
    gender?: boolean
    birthDate?: boolean
    address?: boolean
    managedBuildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "phoneNumber" | "position" | "identityCardNumber" | "gender" | "birthDate" | "address" | "managedBuildingId" | "createdAt" | "updatedAt", ExtArgs["result"]["staffProfile"]>
  export type StaffProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    managedBuilding?: boolean | StaffProfile$managedBuildingArgs<ExtArgs>
    assignedMaintenances?: boolean | StaffProfile$assignedMaintenancesArgs<ExtArgs>
    approvedTransfers?: boolean | StaffProfile$approvedTransfersArgs<ExtArgs>
    _count?: boolean | StaffProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    managedBuilding?: boolean | StaffProfile$managedBuildingArgs<ExtArgs>
  }
  export type StaffProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    managedBuilding?: boolean | StaffProfile$managedBuildingArgs<ExtArgs>
  }

  export type $StaffProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      managedBuilding: Prisma.$BuildingPayload<ExtArgs> | null
      assignedMaintenances: Prisma.$MaintenancePayload<ExtArgs>[]
      approvedTransfers: Prisma.$RoomTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      fullName: string
      phoneNumber: string | null
      position: string | null
      identityCardNumber: string | null
      gender: $Enums.Gender | null
      birthDate: Date | null
      address: string | null
      managedBuildingId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffProfile"]>
    composites: {}
  }

  type StaffProfileGetPayload<S extends boolean | null | undefined | StaffProfileDefaultArgs> = $Result.GetResult<Prisma.$StaffProfilePayload, S>

  type StaffProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffProfileCountAggregateInputType | true
    }

  export interface StaffProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffProfile'], meta: { name: 'StaffProfile' } }
    /**
     * Find zero or one StaffProfile that matches the filter.
     * @param {StaffProfileFindUniqueArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffProfileFindUniqueArgs>(args: SelectSubset<T, StaffProfileFindUniqueArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffProfileFindUniqueOrThrowArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindFirstArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffProfileFindFirstArgs>(args?: SelectSubset<T, StaffProfileFindFirstArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindFirstOrThrowArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffProfiles
     * const staffProfiles = await prisma.staffProfile.findMany()
     * 
     * // Get first 10 StaffProfiles
     * const staffProfiles = await prisma.staffProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffProfileFindManyArgs>(args?: SelectSubset<T, StaffProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffProfile.
     * @param {StaffProfileCreateArgs} args - Arguments to create a StaffProfile.
     * @example
     * // Create one StaffProfile
     * const StaffProfile = await prisma.staffProfile.create({
     *   data: {
     *     // ... data to create a StaffProfile
     *   }
     * })
     * 
     */
    create<T extends StaffProfileCreateArgs>(args: SelectSubset<T, StaffProfileCreateArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffProfiles.
     * @param {StaffProfileCreateManyArgs} args - Arguments to create many StaffProfiles.
     * @example
     * // Create many StaffProfiles
     * const staffProfile = await prisma.staffProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffProfileCreateManyArgs>(args?: SelectSubset<T, StaffProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffProfiles and returns the data saved in the database.
     * @param {StaffProfileCreateManyAndReturnArgs} args - Arguments to create many StaffProfiles.
     * @example
     * // Create many StaffProfiles
     * const staffProfile = await prisma.staffProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffProfiles and only return the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffProfile.
     * @param {StaffProfileDeleteArgs} args - Arguments to delete one StaffProfile.
     * @example
     * // Delete one StaffProfile
     * const StaffProfile = await prisma.staffProfile.delete({
     *   where: {
     *     // ... filter to delete one StaffProfile
     *   }
     * })
     * 
     */
    delete<T extends StaffProfileDeleteArgs>(args: SelectSubset<T, StaffProfileDeleteArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffProfile.
     * @param {StaffProfileUpdateArgs} args - Arguments to update one StaffProfile.
     * @example
     * // Update one StaffProfile
     * const staffProfile = await prisma.staffProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffProfileUpdateArgs>(args: SelectSubset<T, StaffProfileUpdateArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffProfiles.
     * @param {StaffProfileDeleteManyArgs} args - Arguments to filter StaffProfiles to delete.
     * @example
     * // Delete a few StaffProfiles
     * const { count } = await prisma.staffProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffProfileDeleteManyArgs>(args?: SelectSubset<T, StaffProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffProfiles
     * const staffProfile = await prisma.staffProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffProfileUpdateManyArgs>(args: SelectSubset<T, StaffProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffProfiles and returns the data updated in the database.
     * @param {StaffProfileUpdateManyAndReturnArgs} args - Arguments to update many StaffProfiles.
     * @example
     * // Update many StaffProfiles
     * const staffProfile = await prisma.staffProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffProfiles and only return the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffProfile.
     * @param {StaffProfileUpsertArgs} args - Arguments to update or create a StaffProfile.
     * @example
     * // Update or create a StaffProfile
     * const staffProfile = await prisma.staffProfile.upsert({
     *   create: {
     *     // ... data to create a StaffProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffProfile we want to update
     *   }
     * })
     */
    upsert<T extends StaffProfileUpsertArgs>(args: SelectSubset<T, StaffProfileUpsertArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileCountArgs} args - Arguments to filter StaffProfiles to count.
     * @example
     * // Count the number of StaffProfiles
     * const count = await prisma.staffProfile.count({
     *   where: {
     *     // ... the filter for the StaffProfiles we want to count
     *   }
     * })
    **/
    count<T extends StaffProfileCountArgs>(
      args?: Subset<T, StaffProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffProfileAggregateArgs>(args: Subset<T, StaffProfileAggregateArgs>): Prisma.PrismaPromise<GetStaffProfileAggregateType<T>>

    /**
     * Group by StaffProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffProfileGroupByArgs['orderBy'] }
        : { orderBy?: StaffProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffProfile model
   */
  readonly fields: StaffProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    managedBuilding<T extends StaffProfile$managedBuildingArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$managedBuildingArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedMaintenances<T extends StaffProfile$assignedMaintenancesArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$assignedMaintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedTransfers<T extends StaffProfile$approvedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$approvedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffProfile model
   */
  interface StaffProfileFieldRefs {
    readonly id: FieldRef<"StaffProfile", 'Int'>
    readonly userId: FieldRef<"StaffProfile", 'Int'>
    readonly fullName: FieldRef<"StaffProfile", 'String'>
    readonly phoneNumber: FieldRef<"StaffProfile", 'String'>
    readonly position: FieldRef<"StaffProfile", 'String'>
    readonly identityCardNumber: FieldRef<"StaffProfile", 'String'>
    readonly gender: FieldRef<"StaffProfile", 'Gender'>
    readonly birthDate: FieldRef<"StaffProfile", 'DateTime'>
    readonly address: FieldRef<"StaffProfile", 'String'>
    readonly managedBuildingId: FieldRef<"StaffProfile", 'Int'>
    readonly createdAt: FieldRef<"StaffProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffProfile findUnique
   */
  export type StaffProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile findUniqueOrThrow
   */
  export type StaffProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile findFirst
   */
  export type StaffProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffProfiles.
     */
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile findFirstOrThrow
   */
  export type StaffProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffProfiles.
     */
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile findMany
   */
  export type StaffProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfiles to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile create
   */
  export type StaffProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffProfile.
     */
    data: XOR<StaffProfileCreateInput, StaffProfileUncheckedCreateInput>
  }

  /**
   * StaffProfile createMany
   */
  export type StaffProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffProfiles.
     */
    data: StaffProfileCreateManyInput | StaffProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffProfile createManyAndReturn
   */
  export type StaffProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * The data used to create many StaffProfiles.
     */
    data: StaffProfileCreateManyInput | StaffProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffProfile update
   */
  export type StaffProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffProfile.
     */
    data: XOR<StaffProfileUpdateInput, StaffProfileUncheckedUpdateInput>
    /**
     * Choose, which StaffProfile to update.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile updateMany
   */
  export type StaffProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffProfiles.
     */
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyInput>
    /**
     * Filter which StaffProfiles to update
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to update.
     */
    limit?: number
  }

  /**
   * StaffProfile updateManyAndReturn
   */
  export type StaffProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * The data used to update StaffProfiles.
     */
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyInput>
    /**
     * Filter which StaffProfiles to update
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffProfile upsert
   */
  export type StaffProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffProfile to update in case it exists.
     */
    where: StaffProfileWhereUniqueInput
    /**
     * In case the StaffProfile found by the `where` argument doesn't exist, create a new StaffProfile with this data.
     */
    create: XOR<StaffProfileCreateInput, StaffProfileUncheckedCreateInput>
    /**
     * In case the StaffProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffProfileUpdateInput, StaffProfileUncheckedUpdateInput>
  }

  /**
   * StaffProfile delete
   */
  export type StaffProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter which StaffProfile to delete.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile deleteMany
   */
  export type StaffProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffProfiles to delete
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to delete.
     */
    limit?: number
  }

  /**
   * StaffProfile.managedBuilding
   */
  export type StaffProfile$managedBuildingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    where?: BuildingWhereInput
  }

  /**
   * StaffProfile.assignedMaintenances
   */
  export type StaffProfile$assignedMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * StaffProfile.approvedTransfers
   */
  export type StaffProfile$approvedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    where?: RoomTransferWhereInput
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    cursor?: RoomTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * StaffProfile without action
   */
  export type StaffProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
  }


  /**
   * Model StudentProfile
   */

  export type AggregateStudentProfile = {
    _count: StudentProfileCountAggregateOutputType | null
    _avg: StudentProfileAvgAggregateOutputType | null
    _sum: StudentProfileSumAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  export type StudentProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseYear: number | null
    fatherDobYear: number | null
    motherDobYear: number | null
    roomId: number | null
  }

  export type StudentProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseYear: number | null
    fatherDobYear: number | null
    motherDobYear: number | null
    roomId: number | null
  }

  export type StudentProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    studentId: string | null
    fullName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    identityCardNumber: string | null
    ethnicity: string | null
    religion: string | null
    priorityObject: string | null
    phoneNumber: string | null
    personalEmail: string | null
    faculty: string | null
    courseYear: number | null
    className: string | null
    permanentProvince: string | null
    permanentDistrict: string | null
    permanentAddress: string | null
    status: $Enums.StudentStatus | null
    startDate: Date | null
    checkInDate: Date | null
    checkOutDate: Date | null
    contractEndDate: Date | null
    fatherName: string | null
    fatherDobYear: number | null
    fatherPhone: string | null
    fatherAddress: string | null
    motherName: string | null
    motherDobYear: number | null
    motherPhone: string | null
    motherAddress: string | null
    emergencyContactRelation: string | null
    emergencyContactPhone: string | null
    emergencyContactAddress: string | null
    roomId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    studentId: string | null
    fullName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    identityCardNumber: string | null
    ethnicity: string | null
    religion: string | null
    priorityObject: string | null
    phoneNumber: string | null
    personalEmail: string | null
    faculty: string | null
    courseYear: number | null
    className: string | null
    permanentProvince: string | null
    permanentDistrict: string | null
    permanentAddress: string | null
    status: $Enums.StudentStatus | null
    startDate: Date | null
    checkInDate: Date | null
    checkOutDate: Date | null
    contractEndDate: Date | null
    fatherName: string | null
    fatherDobYear: number | null
    fatherPhone: string | null
    fatherAddress: string | null
    motherName: string | null
    motherDobYear: number | null
    motherPhone: string | null
    motherAddress: string | null
    emergencyContactRelation: string | null
    emergencyContactPhone: string | null
    emergencyContactAddress: string | null
    roomId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileCountAggregateOutputType = {
    id: number
    userId: number
    studentId: number
    fullName: number
    gender: number
    birthDate: number
    identityCardNumber: number
    ethnicity: number
    religion: number
    priorityObject: number
    phoneNumber: number
    personalEmail: number
    faculty: number
    courseYear: number
    className: number
    permanentProvince: number
    permanentDistrict: number
    permanentAddress: number
    status: number
    startDate: number
    checkInDate: number
    checkOutDate: number
    contractEndDate: number
    fatherName: number
    fatherDobYear: number
    fatherPhone: number
    fatherAddress: number
    motherName: number
    motherDobYear: number
    motherPhone: number
    motherAddress: number
    emergencyContactRelation: number
    emergencyContactPhone: number
    emergencyContactAddress: number
    roomId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentProfileAvgAggregateInputType = {
    id?: true
    userId?: true
    courseYear?: true
    fatherDobYear?: true
    motherDobYear?: true
    roomId?: true
  }

  export type StudentProfileSumAggregateInputType = {
    id?: true
    userId?: true
    courseYear?: true
    fatherDobYear?: true
    motherDobYear?: true
    roomId?: true
  }

  export type StudentProfileMinAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    fullName?: true
    gender?: true
    birthDate?: true
    identityCardNumber?: true
    ethnicity?: true
    religion?: true
    priorityObject?: true
    phoneNumber?: true
    personalEmail?: true
    faculty?: true
    courseYear?: true
    className?: true
    permanentProvince?: true
    permanentDistrict?: true
    permanentAddress?: true
    status?: true
    startDate?: true
    checkInDate?: true
    checkOutDate?: true
    contractEndDate?: true
    fatherName?: true
    fatherDobYear?: true
    fatherPhone?: true
    fatherAddress?: true
    motherName?: true
    motherDobYear?: true
    motherPhone?: true
    motherAddress?: true
    emergencyContactRelation?: true
    emergencyContactPhone?: true
    emergencyContactAddress?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    fullName?: true
    gender?: true
    birthDate?: true
    identityCardNumber?: true
    ethnicity?: true
    religion?: true
    priorityObject?: true
    phoneNumber?: true
    personalEmail?: true
    faculty?: true
    courseYear?: true
    className?: true
    permanentProvince?: true
    permanentDistrict?: true
    permanentAddress?: true
    status?: true
    startDate?: true
    checkInDate?: true
    checkOutDate?: true
    contractEndDate?: true
    fatherName?: true
    fatherDobYear?: true
    fatherPhone?: true
    fatherAddress?: true
    motherName?: true
    motherDobYear?: true
    motherPhone?: true
    motherAddress?: true
    emergencyContactRelation?: true
    emergencyContactPhone?: true
    emergencyContactAddress?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileCountAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    fullName?: true
    gender?: true
    birthDate?: true
    identityCardNumber?: true
    ethnicity?: true
    religion?: true
    priorityObject?: true
    phoneNumber?: true
    personalEmail?: true
    faculty?: true
    courseYear?: true
    className?: true
    permanentProvince?: true
    permanentDistrict?: true
    permanentAddress?: true
    status?: true
    startDate?: true
    checkInDate?: true
    checkOutDate?: true
    contractEndDate?: true
    fatherName?: true
    fatherDobYear?: true
    fatherPhone?: true
    fatherAddress?: true
    motherName?: true
    motherDobYear?: true
    motherPhone?: true
    motherAddress?: true
    emergencyContactRelation?: true
    emergencyContactPhone?: true
    emergencyContactAddress?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfile to aggregate.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentProfiles
    **/
    _count?: true | StudentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentProfileMaxAggregateInputType
  }

  export type GetStudentProfileAggregateType<T extends StudentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentProfile[P]>
      : GetScalarType<T[P], AggregateStudentProfile[P]>
  }




  export type StudentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithAggregationInput | StudentProfileOrderByWithAggregationInput[]
    by: StudentProfileScalarFieldEnum[] | StudentProfileScalarFieldEnum
    having?: StudentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentProfileCountAggregateInputType | true
    _avg?: StudentProfileAvgAggregateInputType
    _sum?: StudentProfileSumAggregateInputType
    _min?: StudentProfileMinAggregateInputType
    _max?: StudentProfileMaxAggregateInputType
  }

  export type StudentProfileGroupByOutputType = {
    id: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date
    identityCardNumber: string
    ethnicity: string | null
    religion: string | null
    priorityObject: string | null
    phoneNumber: string
    personalEmail: string | null
    faculty: string
    courseYear: number
    className: string | null
    permanentProvince: string | null
    permanentDistrict: string | null
    permanentAddress: string | null
    status: $Enums.StudentStatus
    startDate: Date
    checkInDate: Date | null
    checkOutDate: Date | null
    contractEndDate: Date
    fatherName: string | null
    fatherDobYear: number | null
    fatherPhone: string | null
    fatherAddress: string | null
    motherName: string | null
    motherDobYear: number | null
    motherPhone: string | null
    motherAddress: string | null
    emergencyContactRelation: string | null
    emergencyContactPhone: string | null
    emergencyContactAddress: string | null
    roomId: number | null
    createdAt: Date
    updatedAt: Date
    _count: StudentProfileCountAggregateOutputType | null
    _avg: StudentProfileAvgAggregateOutputType | null
    _sum: StudentProfileSumAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  type GetStudentProfileGroupByPayload<T extends StudentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
        }
      >
    >


  export type StudentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    fullName?: boolean
    gender?: boolean
    birthDate?: boolean
    identityCardNumber?: boolean
    ethnicity?: boolean
    religion?: boolean
    priorityObject?: boolean
    phoneNumber?: boolean
    personalEmail?: boolean
    faculty?: boolean
    courseYear?: boolean
    className?: boolean
    permanentProvince?: boolean
    permanentDistrict?: boolean
    permanentAddress?: boolean
    status?: boolean
    startDate?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    contractEndDate?: boolean
    fatherName?: boolean
    fatherDobYear?: boolean
    fatherPhone?: boolean
    fatherAddress?: boolean
    motherName?: boolean
    motherDobYear?: boolean
    motherPhone?: boolean
    motherAddress?: boolean
    emergencyContactRelation?: boolean
    emergencyContactPhone?: boolean
    emergencyContactAddress?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | StudentProfile$roomArgs<ExtArgs>
    invoices?: boolean | StudentProfile$invoicesArgs<ExtArgs>
    payments?: boolean | StudentProfile$paymentsArgs<ExtArgs>
    roomTransfers?: boolean | StudentProfile$roomTransfersArgs<ExtArgs>
    reportedMaintenances?: boolean | StudentProfile$reportedMaintenancesArgs<ExtArgs>
    vehicleRegistrations?: boolean | StudentProfile$vehicleRegistrationsArgs<ExtArgs>
    _count?: boolean | StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    fullName?: boolean
    gender?: boolean
    birthDate?: boolean
    identityCardNumber?: boolean
    ethnicity?: boolean
    religion?: boolean
    priorityObject?: boolean
    phoneNumber?: boolean
    personalEmail?: boolean
    faculty?: boolean
    courseYear?: boolean
    className?: boolean
    permanentProvince?: boolean
    permanentDistrict?: boolean
    permanentAddress?: boolean
    status?: boolean
    startDate?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    contractEndDate?: boolean
    fatherName?: boolean
    fatherDobYear?: boolean
    fatherPhone?: boolean
    fatherAddress?: boolean
    motherName?: boolean
    motherDobYear?: boolean
    motherPhone?: boolean
    motherAddress?: boolean
    emergencyContactRelation?: boolean
    emergencyContactPhone?: boolean
    emergencyContactAddress?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | StudentProfile$roomArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    fullName?: boolean
    gender?: boolean
    birthDate?: boolean
    identityCardNumber?: boolean
    ethnicity?: boolean
    religion?: boolean
    priorityObject?: boolean
    phoneNumber?: boolean
    personalEmail?: boolean
    faculty?: boolean
    courseYear?: boolean
    className?: boolean
    permanentProvince?: boolean
    permanentDistrict?: boolean
    permanentAddress?: boolean
    status?: boolean
    startDate?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    contractEndDate?: boolean
    fatherName?: boolean
    fatherDobYear?: boolean
    fatherPhone?: boolean
    fatherAddress?: boolean
    motherName?: boolean
    motherDobYear?: boolean
    motherPhone?: boolean
    motherAddress?: boolean
    emergencyContactRelation?: boolean
    emergencyContactPhone?: boolean
    emergencyContactAddress?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | StudentProfile$roomArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    studentId?: boolean
    fullName?: boolean
    gender?: boolean
    birthDate?: boolean
    identityCardNumber?: boolean
    ethnicity?: boolean
    religion?: boolean
    priorityObject?: boolean
    phoneNumber?: boolean
    personalEmail?: boolean
    faculty?: boolean
    courseYear?: boolean
    className?: boolean
    permanentProvince?: boolean
    permanentDistrict?: boolean
    permanentAddress?: boolean
    status?: boolean
    startDate?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    contractEndDate?: boolean
    fatherName?: boolean
    fatherDobYear?: boolean
    fatherPhone?: boolean
    fatherAddress?: boolean
    motherName?: boolean
    motherDobYear?: boolean
    motherPhone?: boolean
    motherAddress?: boolean
    emergencyContactRelation?: boolean
    emergencyContactPhone?: boolean
    emergencyContactAddress?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentId" | "fullName" | "gender" | "birthDate" | "identityCardNumber" | "ethnicity" | "religion" | "priorityObject" | "phoneNumber" | "personalEmail" | "faculty" | "courseYear" | "className" | "permanentProvince" | "permanentDistrict" | "permanentAddress" | "status" | "startDate" | "checkInDate" | "checkOutDate" | "contractEndDate" | "fatherName" | "fatherDobYear" | "fatherPhone" | "fatherAddress" | "motherName" | "motherDobYear" | "motherPhone" | "motherAddress" | "emergencyContactRelation" | "emergencyContactPhone" | "emergencyContactAddress" | "roomId" | "createdAt" | "updatedAt", ExtArgs["result"]["studentProfile"]>
  export type StudentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | StudentProfile$roomArgs<ExtArgs>
    invoices?: boolean | StudentProfile$invoicesArgs<ExtArgs>
    payments?: boolean | StudentProfile$paymentsArgs<ExtArgs>
    roomTransfers?: boolean | StudentProfile$roomTransfersArgs<ExtArgs>
    reportedMaintenances?: boolean | StudentProfile$reportedMaintenancesArgs<ExtArgs>
    vehicleRegistrations?: boolean | StudentProfile$vehicleRegistrationsArgs<ExtArgs>
    _count?: boolean | StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | StudentProfile$roomArgs<ExtArgs>
  }
  export type StudentProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | StudentProfile$roomArgs<ExtArgs>
  }

  export type $StudentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      roomTransfers: Prisma.$RoomTransferPayload<ExtArgs>[]
      reportedMaintenances: Prisma.$MaintenancePayload<ExtArgs>[]
      vehicleRegistrations: Prisma.$VehicleRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      studentId: string
      fullName: string
      gender: $Enums.Gender
      birthDate: Date
      identityCardNumber: string
      ethnicity: string | null
      religion: string | null
      priorityObject: string | null
      phoneNumber: string
      personalEmail: string | null
      faculty: string
      courseYear: number
      className: string | null
      permanentProvince: string | null
      permanentDistrict: string | null
      permanentAddress: string | null
      status: $Enums.StudentStatus
      startDate: Date
      checkInDate: Date | null
      checkOutDate: Date | null
      contractEndDate: Date
      fatherName: string | null
      fatherDobYear: number | null
      fatherPhone: string | null
      fatherAddress: string | null
      motherName: string | null
      motherDobYear: number | null
      motherPhone: string | null
      motherAddress: string | null
      emergencyContactRelation: string | null
      emergencyContactPhone: string | null
      emergencyContactAddress: string | null
      roomId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentProfile"]>
    composites: {}
  }

  type StudentProfileGetPayload<S extends boolean | null | undefined | StudentProfileDefaultArgs> = $Result.GetResult<Prisma.$StudentProfilePayload, S>

  type StudentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentProfileCountAggregateInputType | true
    }

  export interface StudentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentProfile'], meta: { name: 'StudentProfile' } }
    /**
     * Find zero or one StudentProfile that matches the filter.
     * @param {StudentProfileFindUniqueArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentProfileFindUniqueArgs>(args: SelectSubset<T, StudentProfileFindUniqueArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentProfileFindUniqueOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentProfileFindFirstArgs>(args?: SelectSubset<T, StudentProfileFindFirstArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany()
     * 
     * // Get first 10 StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentProfileFindManyArgs>(args?: SelectSubset<T, StudentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentProfile.
     * @param {StudentProfileCreateArgs} args - Arguments to create a StudentProfile.
     * @example
     * // Create one StudentProfile
     * const StudentProfile = await prisma.studentProfile.create({
     *   data: {
     *     // ... data to create a StudentProfile
     *   }
     * })
     * 
     */
    create<T extends StudentProfileCreateArgs>(args: SelectSubset<T, StudentProfileCreateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentProfiles.
     * @param {StudentProfileCreateManyArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentProfileCreateManyArgs>(args?: SelectSubset<T, StudentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentProfiles and returns the data saved in the database.
     * @param {StudentProfileCreateManyAndReturnArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentProfile.
     * @param {StudentProfileDeleteArgs} args - Arguments to delete one StudentProfile.
     * @example
     * // Delete one StudentProfile
     * const StudentProfile = await prisma.studentProfile.delete({
     *   where: {
     *     // ... filter to delete one StudentProfile
     *   }
     * })
     * 
     */
    delete<T extends StudentProfileDeleteArgs>(args: SelectSubset<T, StudentProfileDeleteArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentProfile.
     * @param {StudentProfileUpdateArgs} args - Arguments to update one StudentProfile.
     * @example
     * // Update one StudentProfile
     * const studentProfile = await prisma.studentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentProfileUpdateArgs>(args: SelectSubset<T, StudentProfileUpdateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentProfiles.
     * @param {StudentProfileDeleteManyArgs} args - Arguments to filter StudentProfiles to delete.
     * @example
     * // Delete a few StudentProfiles
     * const { count } = await prisma.studentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentProfileDeleteManyArgs>(args?: SelectSubset<T, StudentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentProfileUpdateManyArgs>(args: SelectSubset<T, StudentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles and returns the data updated in the database.
     * @param {StudentProfileUpdateManyAndReturnArgs} args - Arguments to update many StudentProfiles.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentProfile.
     * @param {StudentProfileUpsertArgs} args - Arguments to update or create a StudentProfile.
     * @example
     * // Update or create a StudentProfile
     * const studentProfile = await prisma.studentProfile.upsert({
     *   create: {
     *     // ... data to create a StudentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentProfile we want to update
     *   }
     * })
     */
    upsert<T extends StudentProfileUpsertArgs>(args: SelectSubset<T, StudentProfileUpsertArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileCountArgs} args - Arguments to filter StudentProfiles to count.
     * @example
     * // Count the number of StudentProfiles
     * const count = await prisma.studentProfile.count({
     *   where: {
     *     // ... the filter for the StudentProfiles we want to count
     *   }
     * })
    **/
    count<T extends StudentProfileCountArgs>(
      args?: Subset<T, StudentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentProfileAggregateArgs>(args: Subset<T, StudentProfileAggregateArgs>): Prisma.PrismaPromise<GetStudentProfileAggregateType<T>>

    /**
     * Group by StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentProfileGroupByArgs['orderBy'] }
        : { orderBy?: StudentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentProfile model
   */
  readonly fields: StudentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends StudentProfile$roomArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends StudentProfile$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends StudentProfile$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomTransfers<T extends StudentProfile$roomTransfersArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$roomTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedMaintenances<T extends StudentProfile$reportedMaintenancesArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$reportedMaintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleRegistrations<T extends StudentProfile$vehicleRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$vehicleRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentProfile model
   */
  interface StudentProfileFieldRefs {
    readonly id: FieldRef<"StudentProfile", 'Int'>
    readonly userId: FieldRef<"StudentProfile", 'Int'>
    readonly studentId: FieldRef<"StudentProfile", 'String'>
    readonly fullName: FieldRef<"StudentProfile", 'String'>
    readonly gender: FieldRef<"StudentProfile", 'Gender'>
    readonly birthDate: FieldRef<"StudentProfile", 'DateTime'>
    readonly identityCardNumber: FieldRef<"StudentProfile", 'String'>
    readonly ethnicity: FieldRef<"StudentProfile", 'String'>
    readonly religion: FieldRef<"StudentProfile", 'String'>
    readonly priorityObject: FieldRef<"StudentProfile", 'String'>
    readonly phoneNumber: FieldRef<"StudentProfile", 'String'>
    readonly personalEmail: FieldRef<"StudentProfile", 'String'>
    readonly faculty: FieldRef<"StudentProfile", 'String'>
    readonly courseYear: FieldRef<"StudentProfile", 'Int'>
    readonly className: FieldRef<"StudentProfile", 'String'>
    readonly permanentProvince: FieldRef<"StudentProfile", 'String'>
    readonly permanentDistrict: FieldRef<"StudentProfile", 'String'>
    readonly permanentAddress: FieldRef<"StudentProfile", 'String'>
    readonly status: FieldRef<"StudentProfile", 'StudentStatus'>
    readonly startDate: FieldRef<"StudentProfile", 'DateTime'>
    readonly checkInDate: FieldRef<"StudentProfile", 'DateTime'>
    readonly checkOutDate: FieldRef<"StudentProfile", 'DateTime'>
    readonly contractEndDate: FieldRef<"StudentProfile", 'DateTime'>
    readonly fatherName: FieldRef<"StudentProfile", 'String'>
    readonly fatherDobYear: FieldRef<"StudentProfile", 'Int'>
    readonly fatherPhone: FieldRef<"StudentProfile", 'String'>
    readonly fatherAddress: FieldRef<"StudentProfile", 'String'>
    readonly motherName: FieldRef<"StudentProfile", 'String'>
    readonly motherDobYear: FieldRef<"StudentProfile", 'Int'>
    readonly motherPhone: FieldRef<"StudentProfile", 'String'>
    readonly motherAddress: FieldRef<"StudentProfile", 'String'>
    readonly emergencyContactRelation: FieldRef<"StudentProfile", 'String'>
    readonly emergencyContactPhone: FieldRef<"StudentProfile", 'String'>
    readonly emergencyContactAddress: FieldRef<"StudentProfile", 'String'>
    readonly roomId: FieldRef<"StudentProfile", 'Int'>
    readonly createdAt: FieldRef<"StudentProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentProfile findUnique
   */
  export type StudentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findUniqueOrThrow
   */
  export type StudentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findFirst
   */
  export type StudentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findFirstOrThrow
   */
  export type StudentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findMany
   */
  export type StudentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfiles to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile create
   */
  export type StudentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentProfile.
     */
    data: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
  }

  /**
   * StudentProfile createMany
   */
  export type StudentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentProfile createManyAndReturn
   */
  export type StudentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile update
   */
  export type StudentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentProfile.
     */
    data: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
    /**
     * Choose, which StudentProfile to update.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile updateMany
   */
  export type StudentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to update.
     */
    limit?: number
  }

  /**
   * StudentProfile updateManyAndReturn
   */
  export type StudentProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile upsert
   */
  export type StudentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentProfile to update in case it exists.
     */
    where: StudentProfileWhereUniqueInput
    /**
     * In case the StudentProfile found by the `where` argument doesn't exist, create a new StudentProfile with this data.
     */
    create: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
    /**
     * In case the StudentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
  }

  /**
   * StudentProfile delete
   */
  export type StudentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter which StudentProfile to delete.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile deleteMany
   */
  export type StudentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfiles to delete
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to delete.
     */
    limit?: number
  }

  /**
   * StudentProfile.room
   */
  export type StudentProfile$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * StudentProfile.invoices
   */
  export type StudentProfile$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * StudentProfile.payments
   */
  export type StudentProfile$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * StudentProfile.roomTransfers
   */
  export type StudentProfile$roomTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    where?: RoomTransferWhereInput
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    cursor?: RoomTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * StudentProfile.reportedMaintenances
   */
  export type StudentProfile$reportedMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * StudentProfile.vehicleRegistrations
   */
  export type StudentProfile$vehicleRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    where?: VehicleRegistrationWhereInput
    orderBy?: VehicleRegistrationOrderByWithRelationInput | VehicleRegistrationOrderByWithRelationInput[]
    cursor?: VehicleRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleRegistrationScalarFieldEnum | VehicleRegistrationScalarFieldEnum[]
  }

  /**
   * StudentProfile without action
   */
  export type StudentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
  }


  /**
   * Model Building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingAvgAggregateOutputType = {
    id: number | null
  }

  export type BuildingSumAggregateOutputType = {
    id: number | null
  }

  export type BuildingMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    id: number
    name: number
    address: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuildingAvgAggregateInputType = {
    id?: true
  }

  export type BuildingSumAggregateInputType = {
    id?: true
  }

  export type BuildingMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Building to aggregate.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type BuildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithAggregationInput | BuildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: BuildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _avg?: BuildingAvgAggregateInputType
    _sum?: BuildingSumAggregateInputType
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    id: number
    name: string
    address: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends BuildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | Building$imagesArgs<ExtArgs>
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    staff?: boolean | Building$staffArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type BuildingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["building"]>

  export type BuildingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["building"]>

  export type BuildingSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuildingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["building"]>
  export type BuildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Building$imagesArgs<ExtArgs>
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    staff?: boolean | Building$staffArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuildingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BuildingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BuildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Building"
    objects: {
      images: Prisma.$MediaPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      staff: Prisma.$StaffProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type BuildingGetPayload<S extends boolean | null | undefined | BuildingDefaultArgs> = $Result.GetResult<Prisma.$BuildingPayload, S>

  type BuildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuildingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface BuildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Building'], meta: { name: 'Building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {BuildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildingFindUniqueArgs>(args: SelectSubset<T, BuildingFindUniqueArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildingFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildingFindFirstArgs>(args?: SelectSubset<T, BuildingFindFirstArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildingFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildingFindManyArgs>(args?: SelectSubset<T, BuildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Building.
     * @param {BuildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends BuildingCreateArgs>(args: SelectSubset<T, BuildingCreateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buildings.
     * @param {BuildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildingCreateManyArgs>(args?: SelectSubset<T, BuildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Buildings and returns the data saved in the database.
     * @param {BuildingCreateManyAndReturnArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Buildings and only return the `id`
     * const buildingWithIdOnly = await prisma.building.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuildingCreateManyAndReturnArgs>(args?: SelectSubset<T, BuildingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Building.
     * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends BuildingDeleteArgs>(args: SelectSubset<T, BuildingDeleteArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Building.
     * @param {BuildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildingUpdateArgs>(args: SelectSubset<T, BuildingUpdateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buildings.
     * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildingDeleteManyArgs>(args?: SelectSubset<T, BuildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildingUpdateManyArgs>(args: SelectSubset<T, BuildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings and returns the data updated in the database.
     * @param {BuildingUpdateManyAndReturnArgs} args - Arguments to update many Buildings.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Buildings and only return the `id`
     * const buildingWithIdOnly = await prisma.building.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BuildingUpdateManyAndReturnArgs>(args: SelectSubset<T, BuildingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Building.
     * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends BuildingUpsertArgs>(args: SelectSubset<T, BuildingUpsertArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends BuildingCountArgs>(
      args?: Subset<T, BuildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingGroupByArgs['orderBy'] }
        : { orderBy?: BuildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Building model
   */
  readonly fields: BuildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Building$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Building$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rooms<T extends Building$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Building$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Building$staffArgs<ExtArgs> = {}>(args?: Subset<T, Building$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Building model
   */
  interface BuildingFieldRefs {
    readonly id: FieldRef<"Building", 'Int'>
    readonly name: FieldRef<"Building", 'String'>
    readonly address: FieldRef<"Building", 'String'>
    readonly description: FieldRef<"Building", 'String'>
    readonly createdAt: FieldRef<"Building", 'DateTime'>
    readonly updatedAt: FieldRef<"Building", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Building findUnique
   */
  export type BuildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findUniqueOrThrow
   */
  export type BuildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findFirst
   */
  export type BuildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findFirstOrThrow
   */
  export type BuildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findMany
   */
  export type BuildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Buildings to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building create
   */
  export type BuildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to create a Building.
     */
    data: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
  }

  /**
   * Building createMany
   */
  export type BuildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Building createManyAndReturn
   */
  export type BuildingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Building update
   */
  export type BuildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to update a Building.
     */
    data: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
    /**
     * Choose, which Building to update.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building updateMany
   */
  export type BuildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to update.
     */
    limit?: number
  }

  /**
   * Building updateManyAndReturn
   */
  export type BuildingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to update.
     */
    limit?: number
  }

  /**
   * Building upsert
   */
  export type BuildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The filter to search for the Building to update in case it exists.
     */
    where: BuildingWhereUniqueInput
    /**
     * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
     */
    create: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
    /**
     * In case the Building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
  }

  /**
   * Building delete
   */
  export type BuildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter which Building to delete.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building deleteMany
   */
  export type BuildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buildings to delete
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to delete.
     */
    limit?: number
  }

  /**
   * Building.images
   */
  export type Building$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Building.rooms
   */
  export type Building$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Building.staff
   */
  export type Building$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    cursor?: StaffProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * Building without action
   */
  export type BuildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    buildingId: number | null
    capacity: number | null
    actualOccupancy: number | null
    floor: number | null
    roomFee: Decimal | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    buildingId: number | null
    capacity: number | null
    actualOccupancy: number | null
    floor: number | null
    roomFee: Decimal | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    buildingId: number | null
    number: string | null
    type: $Enums.RoomType | null
    capacity: number | null
    actualOccupancy: number | null
    floor: number | null
    status: $Enums.RoomStatus | null
    description: string | null
    roomFee: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    buildingId: number | null
    number: string | null
    type: $Enums.RoomType | null
    capacity: number | null
    actualOccupancy: number | null
    floor: number | null
    status: $Enums.RoomStatus | null
    description: string | null
    roomFee: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    buildingId: number
    number: number
    type: number
    capacity: number
    actualOccupancy: number
    floor: number
    status: number
    description: number
    roomFee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    buildingId?: true
    capacity?: true
    actualOccupancy?: true
    floor?: true
    roomFee?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    buildingId?: true
    capacity?: true
    actualOccupancy?: true
    floor?: true
    roomFee?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    buildingId?: true
    number?: true
    type?: true
    capacity?: true
    actualOccupancy?: true
    floor?: true
    status?: true
    description?: true
    roomFee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    buildingId?: true
    number?: true
    type?: true
    capacity?: true
    actualOccupancy?: true
    floor?: true
    status?: true
    description?: true
    roomFee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    buildingId?: true
    number?: true
    type?: true
    capacity?: true
    actualOccupancy?: true
    floor?: true
    status?: true
    description?: true
    roomFee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy: number
    floor: number
    status: $Enums.RoomStatus
    description: string | null
    roomFee: Decimal
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildingId?: boolean
    number?: boolean
    type?: boolean
    capacity?: boolean
    actualOccupancy?: boolean
    floor?: boolean
    status?: boolean
    description?: boolean
    roomFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    images?: boolean | Room$imagesArgs<ExtArgs>
    residents?: boolean | Room$residentsArgs<ExtArgs>
    amenities?: boolean | Room$amenitiesArgs<ExtArgs>
    meterReadings?: boolean | Room$meterReadingsArgs<ExtArgs>
    invoices?: boolean | Room$invoicesArgs<ExtArgs>
    maintenances?: boolean | Room$maintenancesArgs<ExtArgs>
    fromTransfers?: boolean | Room$fromTransfersArgs<ExtArgs>
    toTransfers?: boolean | Room$toTransfersArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildingId?: boolean
    number?: boolean
    type?: boolean
    capacity?: boolean
    actualOccupancy?: boolean
    floor?: boolean
    status?: boolean
    description?: boolean
    roomFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildingId?: boolean
    number?: boolean
    type?: boolean
    capacity?: boolean
    actualOccupancy?: boolean
    floor?: boolean
    status?: boolean
    description?: boolean
    roomFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    buildingId?: boolean
    number?: boolean
    type?: boolean
    capacity?: boolean
    actualOccupancy?: boolean
    floor?: boolean
    status?: boolean
    description?: boolean
    roomFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buildingId" | "number" | "type" | "capacity" | "actualOccupancy" | "floor" | "status" | "description" | "roomFee" | "createdAt" | "updatedAt", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    images?: boolean | Room$imagesArgs<ExtArgs>
    residents?: boolean | Room$residentsArgs<ExtArgs>
    amenities?: boolean | Room$amenitiesArgs<ExtArgs>
    meterReadings?: boolean | Room$meterReadingsArgs<ExtArgs>
    invoices?: boolean | Room$invoicesArgs<ExtArgs>
    maintenances?: boolean | Room$maintenancesArgs<ExtArgs>
    fromTransfers?: boolean | Room$fromTransfersArgs<ExtArgs>
    toTransfers?: boolean | Room$toTransfersArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
  }
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      building: Prisma.$BuildingPayload<ExtArgs>
      images: Prisma.$MediaPayload<ExtArgs>[]
      residents: Prisma.$StudentProfilePayload<ExtArgs>[]
      amenities: Prisma.$RoomAmenityPayload<ExtArgs>[]
      meterReadings: Prisma.$UtilityMeterReadingPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      maintenances: Prisma.$MaintenancePayload<ExtArgs>[]
      fromTransfers: Prisma.$RoomTransferPayload<ExtArgs>[]
      toTransfers: Prisma.$RoomTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buildingId: number
      number: string
      type: $Enums.RoomType
      capacity: number
      actualOccupancy: number
      floor: number
      status: $Enums.RoomStatus
      description: string | null
      roomFee: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building<T extends BuildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildingDefaultArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends Room$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Room$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    residents<T extends Room$residentsArgs<ExtArgs> = {}>(args?: Subset<T, Room$residentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Room$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Room$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meterReadings<T extends Room$meterReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Room$meterReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Room$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Room$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenances<T extends Room$maintenancesArgs<ExtArgs> = {}>(args?: Subset<T, Room$maintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fromTransfers<T extends Room$fromTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Room$fromTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toTransfers<T extends Room$toTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Room$toTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly buildingId: FieldRef<"Room", 'Int'>
    readonly number: FieldRef<"Room", 'String'>
    readonly type: FieldRef<"Room", 'RoomType'>
    readonly capacity: FieldRef<"Room", 'Int'>
    readonly actualOccupancy: FieldRef<"Room", 'Int'>
    readonly floor: FieldRef<"Room", 'Int'>
    readonly status: FieldRef<"Room", 'RoomStatus'>
    readonly description: FieldRef<"Room", 'String'>
    readonly roomFee: FieldRef<"Room", 'Decimal'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.images
   */
  export type Room$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Room.residents
   */
  export type Room$residentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    cursor?: StudentProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * Room.amenities
   */
  export type Room$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    where?: RoomAmenityWhereInput
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    cursor?: RoomAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * Room.meterReadings
   */
  export type Room$meterReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    where?: UtilityMeterReadingWhereInput
    orderBy?: UtilityMeterReadingOrderByWithRelationInput | UtilityMeterReadingOrderByWithRelationInput[]
    cursor?: UtilityMeterReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtilityMeterReadingScalarFieldEnum | UtilityMeterReadingScalarFieldEnum[]
  }

  /**
   * Room.invoices
   */
  export type Room$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Room.maintenances
   */
  export type Room$maintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Room.fromTransfers
   */
  export type Room$fromTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    where?: RoomTransferWhereInput
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    cursor?: RoomTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * Room.toTransfers
   */
  export type Room$toTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    where?: RoomTransferWhereInput
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    cursor?: RoomTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityAvgAggregateOutputType = {
    id: number | null
  }

  export type AmenitySumAggregateOutputType = {
    id: number | null
  }

  export type AmenityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmenityAvgAggregateInputType = {
    id?: true
  }

  export type AmenitySumAggregateInputType = {
    id?: true
  }

  export type AmenityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _avg?: AmenityAvgAggregateInputType
    _sum?: AmenitySumAggregateInputType
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: number
    name: string
    description: string | null
    url: string | null
    createdAt: Date
    updatedAt: Date
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rooms?: boolean | Amenity$roomsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "url" | "createdAt" | "updatedAt", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Amenity$roomsArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      rooms: Prisma.$RoomAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      url: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenityCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenityUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Amenity$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'Int'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly url: FieldRef<"Amenity", 'String'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
    readonly updatedAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity createManyAndReturn
   */
  export type AmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity updateManyAndReturn
   */
  export type AmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.rooms
   */
  export type Amenity$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    where?: RoomAmenityWhereInput
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    cursor?: RoomAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model RoomAmenity
   */

  export type AggregateRoomAmenity = {
    _count: RoomAmenityCountAggregateOutputType | null
    _avg: RoomAmenityAvgAggregateOutputType | null
    _sum: RoomAmenitySumAggregateOutputType | null
    _min: RoomAmenityMinAggregateOutputType | null
    _max: RoomAmenityMaxAggregateOutputType | null
  }

  export type RoomAmenityAvgAggregateOutputType = {
    roomId: number | null
    amenityId: number | null
    quantity: number | null
  }

  export type RoomAmenitySumAggregateOutputType = {
    roomId: number | null
    amenityId: number | null
    quantity: number | null
  }

  export type RoomAmenityMinAggregateOutputType = {
    roomId: number | null
    amenityId: number | null
    quantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomAmenityMaxAggregateOutputType = {
    roomId: number | null
    amenityId: number | null
    quantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomAmenityCountAggregateOutputType = {
    roomId: number
    amenityId: number
    quantity: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAmenityAvgAggregateInputType = {
    roomId?: true
    amenityId?: true
    quantity?: true
  }

  export type RoomAmenitySumAggregateInputType = {
    roomId?: true
    amenityId?: true
    quantity?: true
  }

  export type RoomAmenityMinAggregateInputType = {
    roomId?: true
    amenityId?: true
    quantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomAmenityMaxAggregateInputType = {
    roomId?: true
    amenityId?: true
    quantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomAmenityCountAggregateInputType = {
    roomId?: true
    amenityId?: true
    quantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenity to aggregate.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomAmenities
    **/
    _count?: true | RoomAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomAmenityMaxAggregateInputType
  }

  export type GetRoomAmenityAggregateType<T extends RoomAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomAmenity[P]>
      : GetScalarType<T[P], AggregateRoomAmenity[P]>
  }




  export type RoomAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAmenityWhereInput
    orderBy?: RoomAmenityOrderByWithAggregationInput | RoomAmenityOrderByWithAggregationInput[]
    by: RoomAmenityScalarFieldEnum[] | RoomAmenityScalarFieldEnum
    having?: RoomAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomAmenityCountAggregateInputType | true
    _avg?: RoomAmenityAvgAggregateInputType
    _sum?: RoomAmenitySumAggregateInputType
    _min?: RoomAmenityMinAggregateInputType
    _max?: RoomAmenityMaxAggregateInputType
  }

  export type RoomAmenityGroupByOutputType = {
    roomId: number
    amenityId: number
    quantity: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoomAmenityCountAggregateOutputType | null
    _avg: RoomAmenityAvgAggregateOutputType | null
    _sum: RoomAmenitySumAggregateOutputType | null
    _min: RoomAmenityMinAggregateOutputType | null
    _max: RoomAmenityMaxAggregateOutputType | null
  }

  type GetRoomAmenityGroupByPayload<T extends RoomAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], RoomAmenityGroupByOutputType[P]>
        }
      >
    >


  export type RoomAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    amenityId?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAmenity"]>

  export type RoomAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    amenityId?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAmenity"]>

  export type RoomAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    amenityId?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAmenity"]>

  export type RoomAmenitySelectScalar = {
    roomId?: boolean
    amenityId?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roomId" | "amenityId" | "quantity" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["roomAmenity"]>
  export type RoomAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type RoomAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type RoomAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }

  export type $RoomAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomAmenity"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      amenity: Prisma.$AmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roomId: number
      amenityId: number
      quantity: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomAmenity"]>
    composites: {}
  }

  type RoomAmenityGetPayload<S extends boolean | null | undefined | RoomAmenityDefaultArgs> = $Result.GetResult<Prisma.$RoomAmenityPayload, S>

  type RoomAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomAmenityCountAggregateInputType | true
    }

  export interface RoomAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomAmenity'], meta: { name: 'RoomAmenity' } }
    /**
     * Find zero or one RoomAmenity that matches the filter.
     * @param {RoomAmenityFindUniqueArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomAmenityFindUniqueArgs>(args: SelectSubset<T, RoomAmenityFindUniqueArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomAmenityFindUniqueOrThrowArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindFirstArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomAmenityFindFirstArgs>(args?: SelectSubset<T, RoomAmenityFindFirstArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindFirstOrThrowArgs} args - Arguments to find a RoomAmenity
     * @example
     * // Get one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomAmenities
     * const roomAmenities = await prisma.roomAmenity.findMany()
     * 
     * // Get first 10 RoomAmenities
     * const roomAmenities = await prisma.roomAmenity.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const roomAmenityWithRoomIdOnly = await prisma.roomAmenity.findMany({ select: { roomId: true } })
     * 
     */
    findMany<T extends RoomAmenityFindManyArgs>(args?: SelectSubset<T, RoomAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomAmenity.
     * @param {RoomAmenityCreateArgs} args - Arguments to create a RoomAmenity.
     * @example
     * // Create one RoomAmenity
     * const RoomAmenity = await prisma.roomAmenity.create({
     *   data: {
     *     // ... data to create a RoomAmenity
     *   }
     * })
     * 
     */
    create<T extends RoomAmenityCreateArgs>(args: SelectSubset<T, RoomAmenityCreateArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomAmenities.
     * @param {RoomAmenityCreateManyArgs} args - Arguments to create many RoomAmenities.
     * @example
     * // Create many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomAmenityCreateManyArgs>(args?: SelectSubset<T, RoomAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomAmenities and returns the data saved in the database.
     * @param {RoomAmenityCreateManyAndReturnArgs} args - Arguments to create many RoomAmenities.
     * @example
     * // Create many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomAmenities and only return the `roomId`
     * const roomAmenityWithRoomIdOnly = await prisma.roomAmenity.createManyAndReturn({
     *   select: { roomId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomAmenity.
     * @param {RoomAmenityDeleteArgs} args - Arguments to delete one RoomAmenity.
     * @example
     * // Delete one RoomAmenity
     * const RoomAmenity = await prisma.roomAmenity.delete({
     *   where: {
     *     // ... filter to delete one RoomAmenity
     *   }
     * })
     * 
     */
    delete<T extends RoomAmenityDeleteArgs>(args: SelectSubset<T, RoomAmenityDeleteArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomAmenity.
     * @param {RoomAmenityUpdateArgs} args - Arguments to update one RoomAmenity.
     * @example
     * // Update one RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomAmenityUpdateArgs>(args: SelectSubset<T, RoomAmenityUpdateArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomAmenities.
     * @param {RoomAmenityDeleteManyArgs} args - Arguments to filter RoomAmenities to delete.
     * @example
     * // Delete a few RoomAmenities
     * const { count } = await prisma.roomAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomAmenityDeleteManyArgs>(args?: SelectSubset<T, RoomAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomAmenityUpdateManyArgs>(args: SelectSubset<T, RoomAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAmenities and returns the data updated in the database.
     * @param {RoomAmenityUpdateManyAndReturnArgs} args - Arguments to update many RoomAmenities.
     * @example
     * // Update many RoomAmenities
     * const roomAmenity = await prisma.roomAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomAmenities and only return the `roomId`
     * const roomAmenityWithRoomIdOnly = await prisma.roomAmenity.updateManyAndReturn({
     *   select: { roomId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomAmenity.
     * @param {RoomAmenityUpsertArgs} args - Arguments to update or create a RoomAmenity.
     * @example
     * // Update or create a RoomAmenity
     * const roomAmenity = await prisma.roomAmenity.upsert({
     *   create: {
     *     // ... data to create a RoomAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomAmenity we want to update
     *   }
     * })
     */
    upsert<T extends RoomAmenityUpsertArgs>(args: SelectSubset<T, RoomAmenityUpsertArgs<ExtArgs>>): Prisma__RoomAmenityClient<$Result.GetResult<Prisma.$RoomAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityCountArgs} args - Arguments to filter RoomAmenities to count.
     * @example
     * // Count the number of RoomAmenities
     * const count = await prisma.roomAmenity.count({
     *   where: {
     *     // ... the filter for the RoomAmenities we want to count
     *   }
     * })
    **/
    count<T extends RoomAmenityCountArgs>(
      args?: Subset<T, RoomAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAmenityAggregateArgs>(args: Subset<T, RoomAmenityAggregateArgs>): Prisma.PrismaPromise<GetRoomAmenityAggregateType<T>>

    /**
     * Group by RoomAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomAmenityGroupByArgs['orderBy'] }
        : { orderBy?: RoomAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomAmenity model
   */
  readonly fields: RoomAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomAmenity model
   */
  interface RoomAmenityFieldRefs {
    readonly roomId: FieldRef<"RoomAmenity", 'Int'>
    readonly amenityId: FieldRef<"RoomAmenity", 'Int'>
    readonly quantity: FieldRef<"RoomAmenity", 'Int'>
    readonly notes: FieldRef<"RoomAmenity", 'String'>
    readonly createdAt: FieldRef<"RoomAmenity", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomAmenity findUnique
   */
  export type RoomAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity findUniqueOrThrow
   */
  export type RoomAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity findFirst
   */
  export type RoomAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenities.
     */
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity findFirstOrThrow
   */
  export type RoomAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenity to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAmenities.
     */
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity findMany
   */
  export type RoomAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomAmenities to fetch.
     */
    where?: RoomAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAmenities to fetch.
     */
    orderBy?: RoomAmenityOrderByWithRelationInput | RoomAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomAmenities.
     */
    cursor?: RoomAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAmenities.
     */
    skip?: number
    distinct?: RoomAmenityScalarFieldEnum | RoomAmenityScalarFieldEnum[]
  }

  /**
   * RoomAmenity create
   */
  export type RoomAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomAmenity.
     */
    data: XOR<RoomAmenityCreateInput, RoomAmenityUncheckedCreateInput>
  }

  /**
   * RoomAmenity createMany
   */
  export type RoomAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomAmenities.
     */
    data: RoomAmenityCreateManyInput | RoomAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomAmenity createManyAndReturn
   */
  export type RoomAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many RoomAmenities.
     */
    data: RoomAmenityCreateManyInput | RoomAmenityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomAmenity update
   */
  export type RoomAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomAmenity.
     */
    data: XOR<RoomAmenityUpdateInput, RoomAmenityUncheckedUpdateInput>
    /**
     * Choose, which RoomAmenity to update.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity updateMany
   */
  export type RoomAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomAmenities.
     */
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomAmenities to update
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to update.
     */
    limit?: number
  }

  /**
   * RoomAmenity updateManyAndReturn
   */
  export type RoomAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * The data used to update RoomAmenities.
     */
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomAmenities to update
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomAmenity upsert
   */
  export type RoomAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomAmenity to update in case it exists.
     */
    where: RoomAmenityWhereUniqueInput
    /**
     * In case the RoomAmenity found by the `where` argument doesn't exist, create a new RoomAmenity with this data.
     */
    create: XOR<RoomAmenityCreateInput, RoomAmenityUncheckedCreateInput>
    /**
     * In case the RoomAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomAmenityUpdateInput, RoomAmenityUncheckedUpdateInput>
  }

  /**
   * RoomAmenity delete
   */
  export type RoomAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
    /**
     * Filter which RoomAmenity to delete.
     */
    where: RoomAmenityWhereUniqueInput
  }

  /**
   * RoomAmenity deleteMany
   */
  export type RoomAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAmenities to delete
     */
    where?: RoomAmenityWhereInput
    /**
     * Limit how many RoomAmenities to delete.
     */
    limit?: number
  }

  /**
   * RoomAmenity without action
   */
  export type RoomAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAmenity
     */
    select?: RoomAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAmenity
     */
    omit?: RoomAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAmenityInclude<ExtArgs> | null
  }


  /**
   * Model FeeRate
   */

  export type AggregateFeeRate = {
    _count: FeeRateCountAggregateOutputType | null
    _avg: FeeRateAvgAggregateOutputType | null
    _sum: FeeRateSumAggregateOutputType | null
    _min: FeeRateMinAggregateOutputType | null
    _max: FeeRateMaxAggregateOutputType | null
  }

  export type FeeRateAvgAggregateOutputType = {
    id: number | null
    unitPrice: Decimal | null
  }

  export type FeeRateSumAggregateOutputType = {
    id: number | null
    unitPrice: Decimal | null
  }

  export type FeeRateMinAggregateOutputType = {
    id: number | null
    name: string | null
    feeType: $Enums.FeeType | null
    vehicleType: $Enums.VehicleType | null
    unitPrice: Decimal | null
    unit: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeRateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    feeType: $Enums.FeeType | null
    vehicleType: $Enums.VehicleType | null
    unitPrice: Decimal | null
    unit: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeRateCountAggregateOutputType = {
    id: number
    name: number
    feeType: number
    vehicleType: number
    unitPrice: number
    unit: number
    effectiveFrom: number
    effectiveTo: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeRateAvgAggregateInputType = {
    id?: true
    unitPrice?: true
  }

  export type FeeRateSumAggregateInputType = {
    id?: true
    unitPrice?: true
  }

  export type FeeRateMinAggregateInputType = {
    id?: true
    name?: true
    feeType?: true
    vehicleType?: true
    unitPrice?: true
    unit?: true
    effectiveFrom?: true
    effectiveTo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeRateMaxAggregateInputType = {
    id?: true
    name?: true
    feeType?: true
    vehicleType?: true
    unitPrice?: true
    unit?: true
    effectiveFrom?: true
    effectiveTo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeRateCountAggregateInputType = {
    id?: true
    name?: true
    feeType?: true
    vehicleType?: true
    unitPrice?: true
    unit?: true
    effectiveFrom?: true
    effectiveTo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeRate to aggregate.
     */
    where?: FeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeRates to fetch.
     */
    orderBy?: FeeRateOrderByWithRelationInput | FeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeRates
    **/
    _count?: true | FeeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeRateMaxAggregateInputType
  }

  export type GetFeeRateAggregateType<T extends FeeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeRate[P]>
      : GetScalarType<T[P], AggregateFeeRate[P]>
  }




  export type FeeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeRateWhereInput
    orderBy?: FeeRateOrderByWithAggregationInput | FeeRateOrderByWithAggregationInput[]
    by: FeeRateScalarFieldEnum[] | FeeRateScalarFieldEnum
    having?: FeeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeRateCountAggregateInputType | true
    _avg?: FeeRateAvgAggregateInputType
    _sum?: FeeRateSumAggregateInputType
    _min?: FeeRateMinAggregateInputType
    _max?: FeeRateMaxAggregateInputType
  }

  export type FeeRateGroupByOutputType = {
    id: number
    name: string
    feeType: $Enums.FeeType
    vehicleType: $Enums.VehicleType | null
    unitPrice: Decimal
    unit: string | null
    effectiveFrom: Date
    effectiveTo: Date | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeeRateCountAggregateOutputType | null
    _avg: FeeRateAvgAggregateOutputType | null
    _sum: FeeRateSumAggregateOutputType | null
    _min: FeeRateMinAggregateOutputType | null
    _max: FeeRateMaxAggregateOutputType | null
  }

  type GetFeeRateGroupByPayload<T extends FeeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeRateGroupByOutputType[P]>
            : GetScalarType<T[P], FeeRateGroupByOutputType[P]>
        }
      >
    >


  export type FeeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    feeType?: boolean
    vehicleType?: boolean
    unitPrice?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feeRate"]>

  export type FeeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    feeType?: boolean
    vehicleType?: boolean
    unitPrice?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feeRate"]>

  export type FeeRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    feeType?: boolean
    vehicleType?: boolean
    unitPrice?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feeRate"]>

  export type FeeRateSelectScalar = {
    id?: boolean
    name?: boolean
    feeType?: boolean
    vehicleType?: boolean
    unitPrice?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "feeType" | "vehicleType" | "unitPrice" | "unit" | "effectiveFrom" | "effectiveTo" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["feeRate"]>

  export type $FeeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      feeType: $Enums.FeeType
      vehicleType: $Enums.VehicleType | null
      unitPrice: Prisma.Decimal
      unit: string | null
      effectiveFrom: Date
      effectiveTo: Date | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeRate"]>
    composites: {}
  }

  type FeeRateGetPayload<S extends boolean | null | undefined | FeeRateDefaultArgs> = $Result.GetResult<Prisma.$FeeRatePayload, S>

  type FeeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeRateCountAggregateInputType | true
    }

  export interface FeeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeRate'], meta: { name: 'FeeRate' } }
    /**
     * Find zero or one FeeRate that matches the filter.
     * @param {FeeRateFindUniqueArgs} args - Arguments to find a FeeRate
     * @example
     * // Get one FeeRate
     * const feeRate = await prisma.feeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeRateFindUniqueArgs>(args: SelectSubset<T, FeeRateFindUniqueArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeRateFindUniqueOrThrowArgs} args - Arguments to find a FeeRate
     * @example
     * // Get one FeeRate
     * const feeRate = await prisma.feeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateFindFirstArgs} args - Arguments to find a FeeRate
     * @example
     * // Get one FeeRate
     * const feeRate = await prisma.feeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeRateFindFirstArgs>(args?: SelectSubset<T, FeeRateFindFirstArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateFindFirstOrThrowArgs} args - Arguments to find a FeeRate
     * @example
     * // Get one FeeRate
     * const feeRate = await prisma.feeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeRates
     * const feeRates = await prisma.feeRate.findMany()
     * 
     * // Get first 10 FeeRates
     * const feeRates = await prisma.feeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeRateWithIdOnly = await prisma.feeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeRateFindManyArgs>(args?: SelectSubset<T, FeeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeRate.
     * @param {FeeRateCreateArgs} args - Arguments to create a FeeRate.
     * @example
     * // Create one FeeRate
     * const FeeRate = await prisma.feeRate.create({
     *   data: {
     *     // ... data to create a FeeRate
     *   }
     * })
     * 
     */
    create<T extends FeeRateCreateArgs>(args: SelectSubset<T, FeeRateCreateArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeRates.
     * @param {FeeRateCreateManyArgs} args - Arguments to create many FeeRates.
     * @example
     * // Create many FeeRates
     * const feeRate = await prisma.feeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeRateCreateManyArgs>(args?: SelectSubset<T, FeeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeRates and returns the data saved in the database.
     * @param {FeeRateCreateManyAndReturnArgs} args - Arguments to create many FeeRates.
     * @example
     * // Create many FeeRates
     * const feeRate = await prisma.feeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeRates and only return the `id`
     * const feeRateWithIdOnly = await prisma.feeRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeRate.
     * @param {FeeRateDeleteArgs} args - Arguments to delete one FeeRate.
     * @example
     * // Delete one FeeRate
     * const FeeRate = await prisma.feeRate.delete({
     *   where: {
     *     // ... filter to delete one FeeRate
     *   }
     * })
     * 
     */
    delete<T extends FeeRateDeleteArgs>(args: SelectSubset<T, FeeRateDeleteArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeRate.
     * @param {FeeRateUpdateArgs} args - Arguments to update one FeeRate.
     * @example
     * // Update one FeeRate
     * const feeRate = await prisma.feeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeRateUpdateArgs>(args: SelectSubset<T, FeeRateUpdateArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeRates.
     * @param {FeeRateDeleteManyArgs} args - Arguments to filter FeeRates to delete.
     * @example
     * // Delete a few FeeRates
     * const { count } = await prisma.feeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeRateDeleteManyArgs>(args?: SelectSubset<T, FeeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeRates
     * const feeRate = await prisma.feeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeRateUpdateManyArgs>(args: SelectSubset<T, FeeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeRates and returns the data updated in the database.
     * @param {FeeRateUpdateManyAndReturnArgs} args - Arguments to update many FeeRates.
     * @example
     * // Update many FeeRates
     * const feeRate = await prisma.feeRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeRates and only return the `id`
     * const feeRateWithIdOnly = await prisma.feeRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeRateUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeRate.
     * @param {FeeRateUpsertArgs} args - Arguments to update or create a FeeRate.
     * @example
     * // Update or create a FeeRate
     * const feeRate = await prisma.feeRate.upsert({
     *   create: {
     *     // ... data to create a FeeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeRate we want to update
     *   }
     * })
     */
    upsert<T extends FeeRateUpsertArgs>(args: SelectSubset<T, FeeRateUpsertArgs<ExtArgs>>): Prisma__FeeRateClient<$Result.GetResult<Prisma.$FeeRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateCountArgs} args - Arguments to filter FeeRates to count.
     * @example
     * // Count the number of FeeRates
     * const count = await prisma.feeRate.count({
     *   where: {
     *     // ... the filter for the FeeRates we want to count
     *   }
     * })
    **/
    count<T extends FeeRateCountArgs>(
      args?: Subset<T, FeeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeRateAggregateArgs>(args: Subset<T, FeeRateAggregateArgs>): Prisma.PrismaPromise<GetFeeRateAggregateType<T>>

    /**
     * Group by FeeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeRateGroupByArgs['orderBy'] }
        : { orderBy?: FeeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeRate model
   */
  readonly fields: FeeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeRate model
   */
  interface FeeRateFieldRefs {
    readonly id: FieldRef<"FeeRate", 'Int'>
    readonly name: FieldRef<"FeeRate", 'String'>
    readonly feeType: FieldRef<"FeeRate", 'FeeType'>
    readonly vehicleType: FieldRef<"FeeRate", 'VehicleType'>
    readonly unitPrice: FieldRef<"FeeRate", 'Decimal'>
    readonly unit: FieldRef<"FeeRate", 'String'>
    readonly effectiveFrom: FieldRef<"FeeRate", 'DateTime'>
    readonly effectiveTo: FieldRef<"FeeRate", 'DateTime'>
    readonly description: FieldRef<"FeeRate", 'String'>
    readonly isActive: FieldRef<"FeeRate", 'Boolean'>
    readonly createdAt: FieldRef<"FeeRate", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeRate findUnique
   */
  export type FeeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * Filter, which FeeRate to fetch.
     */
    where: FeeRateWhereUniqueInput
  }

  /**
   * FeeRate findUniqueOrThrow
   */
  export type FeeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * Filter, which FeeRate to fetch.
     */
    where: FeeRateWhereUniqueInput
  }

  /**
   * FeeRate findFirst
   */
  export type FeeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * Filter, which FeeRate to fetch.
     */
    where?: FeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeRates to fetch.
     */
    orderBy?: FeeRateOrderByWithRelationInput | FeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeRates.
     */
    cursor?: FeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeRates.
     */
    distinct?: FeeRateScalarFieldEnum | FeeRateScalarFieldEnum[]
  }

  /**
   * FeeRate findFirstOrThrow
   */
  export type FeeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * Filter, which FeeRate to fetch.
     */
    where?: FeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeRates to fetch.
     */
    orderBy?: FeeRateOrderByWithRelationInput | FeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeRates.
     */
    cursor?: FeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeRates.
     */
    distinct?: FeeRateScalarFieldEnum | FeeRateScalarFieldEnum[]
  }

  /**
   * FeeRate findMany
   */
  export type FeeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * Filter, which FeeRates to fetch.
     */
    where?: FeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeRates to fetch.
     */
    orderBy?: FeeRateOrderByWithRelationInput | FeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeRates.
     */
    cursor?: FeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeRates.
     */
    skip?: number
    distinct?: FeeRateScalarFieldEnum | FeeRateScalarFieldEnum[]
  }

  /**
   * FeeRate create
   */
  export type FeeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * The data needed to create a FeeRate.
     */
    data: XOR<FeeRateCreateInput, FeeRateUncheckedCreateInput>
  }

  /**
   * FeeRate createMany
   */
  export type FeeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeRates.
     */
    data: FeeRateCreateManyInput | FeeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeRate createManyAndReturn
   */
  export type FeeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * The data used to create many FeeRates.
     */
    data: FeeRateCreateManyInput | FeeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeRate update
   */
  export type FeeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * The data needed to update a FeeRate.
     */
    data: XOR<FeeRateUpdateInput, FeeRateUncheckedUpdateInput>
    /**
     * Choose, which FeeRate to update.
     */
    where: FeeRateWhereUniqueInput
  }

  /**
   * FeeRate updateMany
   */
  export type FeeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeRates.
     */
    data: XOR<FeeRateUpdateManyMutationInput, FeeRateUncheckedUpdateManyInput>
    /**
     * Filter which FeeRates to update
     */
    where?: FeeRateWhereInput
    /**
     * Limit how many FeeRates to update.
     */
    limit?: number
  }

  /**
   * FeeRate updateManyAndReturn
   */
  export type FeeRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * The data used to update FeeRates.
     */
    data: XOR<FeeRateUpdateManyMutationInput, FeeRateUncheckedUpdateManyInput>
    /**
     * Filter which FeeRates to update
     */
    where?: FeeRateWhereInput
    /**
     * Limit how many FeeRates to update.
     */
    limit?: number
  }

  /**
   * FeeRate upsert
   */
  export type FeeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * The filter to search for the FeeRate to update in case it exists.
     */
    where: FeeRateWhereUniqueInput
    /**
     * In case the FeeRate found by the `where` argument doesn't exist, create a new FeeRate with this data.
     */
    create: XOR<FeeRateCreateInput, FeeRateUncheckedCreateInput>
    /**
     * In case the FeeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeRateUpdateInput, FeeRateUncheckedUpdateInput>
  }

  /**
   * FeeRate delete
   */
  export type FeeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
    /**
     * Filter which FeeRate to delete.
     */
    where: FeeRateWhereUniqueInput
  }

  /**
   * FeeRate deleteMany
   */
  export type FeeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeRates to delete
     */
    where?: FeeRateWhereInput
    /**
     * Limit how many FeeRates to delete.
     */
    limit?: number
  }

  /**
   * FeeRate without action
   */
  export type FeeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeRate
     */
    select?: FeeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeRate
     */
    omit?: FeeRateOmit<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    roomId: number | null
    billingMonth: number | null
    billingYear: number | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    roomId: number | null
    billingMonth: number | null
    billingYear: number | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    roomId: number | null
    billingMonth: number | null
    billingYear: number | null
    issueDate: Date | null
    dueDate: Date | null
    paymentDeadline: Date | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    roomId: number | null
    billingMonth: number | null
    billingYear: number | null
    issueDate: Date | null
    dueDate: Date | null
    paymentDeadline: Date | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    studentProfileId: number
    roomId: number
    billingMonth: number
    billingYear: number
    issueDate: number
    dueDate: number
    paymentDeadline: number
    totalAmount: number
    paidAmount: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    studentProfileId?: true
    roomId?: true
    billingMonth?: true
    billingYear?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    studentProfileId?: true
    roomId?: true
    billingMonth?: true
    billingYear?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    studentProfileId?: true
    roomId?: true
    billingMonth?: true
    billingYear?: true
    issueDate?: true
    dueDate?: true
    paymentDeadline?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    studentProfileId?: true
    roomId?: true
    billingMonth?: true
    billingYear?: true
    issueDate?: true
    dueDate?: true
    paymentDeadline?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    studentProfileId?: true
    roomId?: true
    billingMonth?: true
    billingYear?: true
    issueDate?: true
    dueDate?: true
    paymentDeadline?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    studentProfileId: number | null
    roomId: number | null
    billingMonth: number
    billingYear: number
    issueDate: Date
    dueDate: Date
    paymentDeadline: Date
    totalAmount: Decimal
    paidAmount: Decimal
    status: $Enums.InvoiceStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    roomId?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paymentDeadline?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | Invoice$studentProfileArgs<ExtArgs>
    room?: boolean | Invoice$roomArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    roomId?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paymentDeadline?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | Invoice$studentProfileArgs<ExtArgs>
    room?: boolean | Invoice$roomArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    roomId?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paymentDeadline?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | Invoice$studentProfileArgs<ExtArgs>
    room?: boolean | Invoice$roomArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    studentProfileId?: boolean
    roomId?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paymentDeadline?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentProfileId" | "roomId" | "billingMonth" | "billingYear" | "issueDate" | "dueDate" | "paymentDeadline" | "totalAmount" | "paidAmount" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | Invoice$studentProfileArgs<ExtArgs>
    room?: boolean | Invoice$roomArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | Invoice$studentProfileArgs<ExtArgs>
    room?: boolean | Invoice$roomArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | Invoice$studentProfileArgs<ExtArgs>
    room?: boolean | Invoice$roomArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs> | null
      room: Prisma.$RoomPayload<ExtArgs> | null
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentProfileId: number | null
      roomId: number | null
      billingMonth: number
      billingYear: number
      issueDate: Date
      dueDate: Date
      paymentDeadline: Date
      totalAmount: Prisma.Decimal
      paidAmount: Prisma.Decimal
      status: $Enums.InvoiceStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentProfile<T extends Invoice$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$studentProfileArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    room<T extends Invoice$roomArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly studentProfileId: FieldRef<"Invoice", 'Int'>
    readonly roomId: FieldRef<"Invoice", 'Int'>
    readonly billingMonth: FieldRef<"Invoice", 'Int'>
    readonly billingYear: FieldRef<"Invoice", 'Int'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paymentDeadline: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly paidAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.studentProfile
   */
  export type Invoice$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * Invoice.room
   */
  export type Invoice$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    type: $Enums.PaymentType | null
    description: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    type: $Enums.PaymentType | null
    description: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    type: number
    description: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    type?: true
    description?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    type?: true
    description?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    type?: true
    description?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    type: $Enums.PaymentType
    description: string
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "type" | "description" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      type: $Enums.PaymentType
      description: string
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'Int'>
    readonly type: FieldRef<"InvoiceItem", 'PaymentType'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly amount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    studentProfileId: number | null
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    studentProfileId: number | null
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    studentProfileId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: string | null
    transactionCode: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    studentProfileId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: string | null
    transactionCode: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    studentProfileId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    transactionCode: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    studentProfileId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    invoiceId?: true
    studentProfileId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    studentProfileId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    transactionCode?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    studentProfileId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    transactionCode?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    studentProfileId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    transactionCode?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    invoiceId: number
    studentProfileId: number
    amount: Decimal
    paymentDate: Date
    paymentMethod: string | null
    transactionCode: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    studentProfileId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    transactionCode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    studentProfileId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    transactionCode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    studentProfileId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    transactionCode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    studentProfileId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    transactionCode?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "studentProfileId" | "amount" | "paymentDate" | "paymentMethod" | "transactionCode" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      studentProfileId: number
      amount: Prisma.Decimal
      paymentDate: Date
      paymentMethod: string | null
      transactionCode: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentProfile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly invoiceId: FieldRef<"Payment", 'Int'>
    readonly studentProfileId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly transactionCode: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model UtilityMeterReading
   */

  export type AggregateUtilityMeterReading = {
    _count: UtilityMeterReadingCountAggregateOutputType | null
    _avg: UtilityMeterReadingAvgAggregateOutputType | null
    _sum: UtilityMeterReadingSumAggregateOutputType | null
    _min: UtilityMeterReadingMinAggregateOutputType | null
    _max: UtilityMeterReadingMaxAggregateOutputType | null
  }

  export type UtilityMeterReadingAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    indexValue: number | null
    billingMonth: number | null
    billingYear: number | null
  }

  export type UtilityMeterReadingSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    indexValue: number | null
    billingMonth: number | null
    billingYear: number | null
  }

  export type UtilityMeterReadingMinAggregateOutputType = {
    id: number | null
    roomId: number | null
    type: $Enums.UtilityType | null
    readingDate: Date | null
    indexValue: number | null
    billingMonth: number | null
    billingYear: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UtilityMeterReadingMaxAggregateOutputType = {
    id: number | null
    roomId: number | null
    type: $Enums.UtilityType | null
    readingDate: Date | null
    indexValue: number | null
    billingMonth: number | null
    billingYear: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UtilityMeterReadingCountAggregateOutputType = {
    id: number
    roomId: number
    type: number
    readingDate: number
    indexValue: number
    billingMonth: number
    billingYear: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UtilityMeterReadingAvgAggregateInputType = {
    id?: true
    roomId?: true
    indexValue?: true
    billingMonth?: true
    billingYear?: true
  }

  export type UtilityMeterReadingSumAggregateInputType = {
    id?: true
    roomId?: true
    indexValue?: true
    billingMonth?: true
    billingYear?: true
  }

  export type UtilityMeterReadingMinAggregateInputType = {
    id?: true
    roomId?: true
    type?: true
    readingDate?: true
    indexValue?: true
    billingMonth?: true
    billingYear?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UtilityMeterReadingMaxAggregateInputType = {
    id?: true
    roomId?: true
    type?: true
    readingDate?: true
    indexValue?: true
    billingMonth?: true
    billingYear?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UtilityMeterReadingCountAggregateInputType = {
    id?: true
    roomId?: true
    type?: true
    readingDate?: true
    indexValue?: true
    billingMonth?: true
    billingYear?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UtilityMeterReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UtilityMeterReading to aggregate.
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtilityMeterReadings to fetch.
     */
    orderBy?: UtilityMeterReadingOrderByWithRelationInput | UtilityMeterReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtilityMeterReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtilityMeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtilityMeterReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UtilityMeterReadings
    **/
    _count?: true | UtilityMeterReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilityMeterReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilityMeterReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilityMeterReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilityMeterReadingMaxAggregateInputType
  }

  export type GetUtilityMeterReadingAggregateType<T extends UtilityMeterReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilityMeterReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilityMeterReading[P]>
      : GetScalarType<T[P], AggregateUtilityMeterReading[P]>
  }




  export type UtilityMeterReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilityMeterReadingWhereInput
    orderBy?: UtilityMeterReadingOrderByWithAggregationInput | UtilityMeterReadingOrderByWithAggregationInput[]
    by: UtilityMeterReadingScalarFieldEnum[] | UtilityMeterReadingScalarFieldEnum
    having?: UtilityMeterReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilityMeterReadingCountAggregateInputType | true
    _avg?: UtilityMeterReadingAvgAggregateInputType
    _sum?: UtilityMeterReadingSumAggregateInputType
    _min?: UtilityMeterReadingMinAggregateInputType
    _max?: UtilityMeterReadingMaxAggregateInputType
  }

  export type UtilityMeterReadingGroupByOutputType = {
    id: number
    roomId: number
    type: $Enums.UtilityType
    readingDate: Date
    indexValue: number
    billingMonth: number
    billingYear: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: UtilityMeterReadingCountAggregateOutputType | null
    _avg: UtilityMeterReadingAvgAggregateOutputType | null
    _sum: UtilityMeterReadingSumAggregateOutputType | null
    _min: UtilityMeterReadingMinAggregateOutputType | null
    _max: UtilityMeterReadingMaxAggregateOutputType | null
  }

  type GetUtilityMeterReadingGroupByPayload<T extends UtilityMeterReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilityMeterReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilityMeterReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilityMeterReadingGroupByOutputType[P]>
            : GetScalarType<T[P], UtilityMeterReadingGroupByOutputType[P]>
        }
      >
    >


  export type UtilityMeterReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    type?: boolean
    readingDate?: boolean
    indexValue?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilityMeterReading"]>

  export type UtilityMeterReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    type?: boolean
    readingDate?: boolean
    indexValue?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilityMeterReading"]>

  export type UtilityMeterReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    type?: boolean
    readingDate?: boolean
    indexValue?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilityMeterReading"]>

  export type UtilityMeterReadingSelectScalar = {
    id?: boolean
    roomId?: boolean
    type?: boolean
    readingDate?: boolean
    indexValue?: boolean
    billingMonth?: boolean
    billingYear?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UtilityMeterReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "type" | "readingDate" | "indexValue" | "billingMonth" | "billingYear" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["utilityMeterReading"]>
  export type UtilityMeterReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type UtilityMeterReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type UtilityMeterReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $UtilityMeterReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UtilityMeterReading"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomId: number
      type: $Enums.UtilityType
      readingDate: Date
      indexValue: number
      billingMonth: number
      billingYear: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["utilityMeterReading"]>
    composites: {}
  }

  type UtilityMeterReadingGetPayload<S extends boolean | null | undefined | UtilityMeterReadingDefaultArgs> = $Result.GetResult<Prisma.$UtilityMeterReadingPayload, S>

  type UtilityMeterReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UtilityMeterReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtilityMeterReadingCountAggregateInputType | true
    }

  export interface UtilityMeterReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UtilityMeterReading'], meta: { name: 'UtilityMeterReading' } }
    /**
     * Find zero or one UtilityMeterReading that matches the filter.
     * @param {UtilityMeterReadingFindUniqueArgs} args - Arguments to find a UtilityMeterReading
     * @example
     * // Get one UtilityMeterReading
     * const utilityMeterReading = await prisma.utilityMeterReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UtilityMeterReadingFindUniqueArgs>(args: SelectSubset<T, UtilityMeterReadingFindUniqueArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UtilityMeterReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UtilityMeterReadingFindUniqueOrThrowArgs} args - Arguments to find a UtilityMeterReading
     * @example
     * // Get one UtilityMeterReading
     * const utilityMeterReading = await prisma.utilityMeterReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UtilityMeterReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, UtilityMeterReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UtilityMeterReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingFindFirstArgs} args - Arguments to find a UtilityMeterReading
     * @example
     * // Get one UtilityMeterReading
     * const utilityMeterReading = await prisma.utilityMeterReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UtilityMeterReadingFindFirstArgs>(args?: SelectSubset<T, UtilityMeterReadingFindFirstArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UtilityMeterReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingFindFirstOrThrowArgs} args - Arguments to find a UtilityMeterReading
     * @example
     * // Get one UtilityMeterReading
     * const utilityMeterReading = await prisma.utilityMeterReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UtilityMeterReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, UtilityMeterReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UtilityMeterReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UtilityMeterReadings
     * const utilityMeterReadings = await prisma.utilityMeterReading.findMany()
     * 
     * // Get first 10 UtilityMeterReadings
     * const utilityMeterReadings = await prisma.utilityMeterReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utilityMeterReadingWithIdOnly = await prisma.utilityMeterReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UtilityMeterReadingFindManyArgs>(args?: SelectSubset<T, UtilityMeterReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UtilityMeterReading.
     * @param {UtilityMeterReadingCreateArgs} args - Arguments to create a UtilityMeterReading.
     * @example
     * // Create one UtilityMeterReading
     * const UtilityMeterReading = await prisma.utilityMeterReading.create({
     *   data: {
     *     // ... data to create a UtilityMeterReading
     *   }
     * })
     * 
     */
    create<T extends UtilityMeterReadingCreateArgs>(args: SelectSubset<T, UtilityMeterReadingCreateArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UtilityMeterReadings.
     * @param {UtilityMeterReadingCreateManyArgs} args - Arguments to create many UtilityMeterReadings.
     * @example
     * // Create many UtilityMeterReadings
     * const utilityMeterReading = await prisma.utilityMeterReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UtilityMeterReadingCreateManyArgs>(args?: SelectSubset<T, UtilityMeterReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UtilityMeterReadings and returns the data saved in the database.
     * @param {UtilityMeterReadingCreateManyAndReturnArgs} args - Arguments to create many UtilityMeterReadings.
     * @example
     * // Create many UtilityMeterReadings
     * const utilityMeterReading = await prisma.utilityMeterReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UtilityMeterReadings and only return the `id`
     * const utilityMeterReadingWithIdOnly = await prisma.utilityMeterReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UtilityMeterReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, UtilityMeterReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UtilityMeterReading.
     * @param {UtilityMeterReadingDeleteArgs} args - Arguments to delete one UtilityMeterReading.
     * @example
     * // Delete one UtilityMeterReading
     * const UtilityMeterReading = await prisma.utilityMeterReading.delete({
     *   where: {
     *     // ... filter to delete one UtilityMeterReading
     *   }
     * })
     * 
     */
    delete<T extends UtilityMeterReadingDeleteArgs>(args: SelectSubset<T, UtilityMeterReadingDeleteArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UtilityMeterReading.
     * @param {UtilityMeterReadingUpdateArgs} args - Arguments to update one UtilityMeterReading.
     * @example
     * // Update one UtilityMeterReading
     * const utilityMeterReading = await prisma.utilityMeterReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UtilityMeterReadingUpdateArgs>(args: SelectSubset<T, UtilityMeterReadingUpdateArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UtilityMeterReadings.
     * @param {UtilityMeterReadingDeleteManyArgs} args - Arguments to filter UtilityMeterReadings to delete.
     * @example
     * // Delete a few UtilityMeterReadings
     * const { count } = await prisma.utilityMeterReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UtilityMeterReadingDeleteManyArgs>(args?: SelectSubset<T, UtilityMeterReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UtilityMeterReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UtilityMeterReadings
     * const utilityMeterReading = await prisma.utilityMeterReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UtilityMeterReadingUpdateManyArgs>(args: SelectSubset<T, UtilityMeterReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UtilityMeterReadings and returns the data updated in the database.
     * @param {UtilityMeterReadingUpdateManyAndReturnArgs} args - Arguments to update many UtilityMeterReadings.
     * @example
     * // Update many UtilityMeterReadings
     * const utilityMeterReading = await prisma.utilityMeterReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UtilityMeterReadings and only return the `id`
     * const utilityMeterReadingWithIdOnly = await prisma.utilityMeterReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UtilityMeterReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, UtilityMeterReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UtilityMeterReading.
     * @param {UtilityMeterReadingUpsertArgs} args - Arguments to update or create a UtilityMeterReading.
     * @example
     * // Update or create a UtilityMeterReading
     * const utilityMeterReading = await prisma.utilityMeterReading.upsert({
     *   create: {
     *     // ... data to create a UtilityMeterReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UtilityMeterReading we want to update
     *   }
     * })
     */
    upsert<T extends UtilityMeterReadingUpsertArgs>(args: SelectSubset<T, UtilityMeterReadingUpsertArgs<ExtArgs>>): Prisma__UtilityMeterReadingClient<$Result.GetResult<Prisma.$UtilityMeterReadingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UtilityMeterReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingCountArgs} args - Arguments to filter UtilityMeterReadings to count.
     * @example
     * // Count the number of UtilityMeterReadings
     * const count = await prisma.utilityMeterReading.count({
     *   where: {
     *     // ... the filter for the UtilityMeterReadings we want to count
     *   }
     * })
    **/
    count<T extends UtilityMeterReadingCountArgs>(
      args?: Subset<T, UtilityMeterReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilityMeterReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UtilityMeterReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilityMeterReadingAggregateArgs>(args: Subset<T, UtilityMeterReadingAggregateArgs>): Prisma.PrismaPromise<GetUtilityMeterReadingAggregateType<T>>

    /**
     * Group by UtilityMeterReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilityMeterReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtilityMeterReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtilityMeterReadingGroupByArgs['orderBy'] }
        : { orderBy?: UtilityMeterReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtilityMeterReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilityMeterReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UtilityMeterReading model
   */
  readonly fields: UtilityMeterReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UtilityMeterReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtilityMeterReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UtilityMeterReading model
   */
  interface UtilityMeterReadingFieldRefs {
    readonly id: FieldRef<"UtilityMeterReading", 'Int'>
    readonly roomId: FieldRef<"UtilityMeterReading", 'Int'>
    readonly type: FieldRef<"UtilityMeterReading", 'UtilityType'>
    readonly readingDate: FieldRef<"UtilityMeterReading", 'DateTime'>
    readonly indexValue: FieldRef<"UtilityMeterReading", 'Float'>
    readonly billingMonth: FieldRef<"UtilityMeterReading", 'Int'>
    readonly billingYear: FieldRef<"UtilityMeterReading", 'Int'>
    readonly notes: FieldRef<"UtilityMeterReading", 'String'>
    readonly createdAt: FieldRef<"UtilityMeterReading", 'DateTime'>
    readonly updatedAt: FieldRef<"UtilityMeterReading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UtilityMeterReading findUnique
   */
  export type UtilityMeterReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * Filter, which UtilityMeterReading to fetch.
     */
    where: UtilityMeterReadingWhereUniqueInput
  }

  /**
   * UtilityMeterReading findUniqueOrThrow
   */
  export type UtilityMeterReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * Filter, which UtilityMeterReading to fetch.
     */
    where: UtilityMeterReadingWhereUniqueInput
  }

  /**
   * UtilityMeterReading findFirst
   */
  export type UtilityMeterReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * Filter, which UtilityMeterReading to fetch.
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtilityMeterReadings to fetch.
     */
    orderBy?: UtilityMeterReadingOrderByWithRelationInput | UtilityMeterReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UtilityMeterReadings.
     */
    cursor?: UtilityMeterReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtilityMeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtilityMeterReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UtilityMeterReadings.
     */
    distinct?: UtilityMeterReadingScalarFieldEnum | UtilityMeterReadingScalarFieldEnum[]
  }

  /**
   * UtilityMeterReading findFirstOrThrow
   */
  export type UtilityMeterReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * Filter, which UtilityMeterReading to fetch.
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtilityMeterReadings to fetch.
     */
    orderBy?: UtilityMeterReadingOrderByWithRelationInput | UtilityMeterReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UtilityMeterReadings.
     */
    cursor?: UtilityMeterReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtilityMeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtilityMeterReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UtilityMeterReadings.
     */
    distinct?: UtilityMeterReadingScalarFieldEnum | UtilityMeterReadingScalarFieldEnum[]
  }

  /**
   * UtilityMeterReading findMany
   */
  export type UtilityMeterReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * Filter, which UtilityMeterReadings to fetch.
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtilityMeterReadings to fetch.
     */
    orderBy?: UtilityMeterReadingOrderByWithRelationInput | UtilityMeterReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UtilityMeterReadings.
     */
    cursor?: UtilityMeterReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtilityMeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtilityMeterReadings.
     */
    skip?: number
    distinct?: UtilityMeterReadingScalarFieldEnum | UtilityMeterReadingScalarFieldEnum[]
  }

  /**
   * UtilityMeterReading create
   */
  export type UtilityMeterReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a UtilityMeterReading.
     */
    data: XOR<UtilityMeterReadingCreateInput, UtilityMeterReadingUncheckedCreateInput>
  }

  /**
   * UtilityMeterReading createMany
   */
  export type UtilityMeterReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UtilityMeterReadings.
     */
    data: UtilityMeterReadingCreateManyInput | UtilityMeterReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UtilityMeterReading createManyAndReturn
   */
  export type UtilityMeterReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * The data used to create many UtilityMeterReadings.
     */
    data: UtilityMeterReadingCreateManyInput | UtilityMeterReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UtilityMeterReading update
   */
  export type UtilityMeterReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a UtilityMeterReading.
     */
    data: XOR<UtilityMeterReadingUpdateInput, UtilityMeterReadingUncheckedUpdateInput>
    /**
     * Choose, which UtilityMeterReading to update.
     */
    where: UtilityMeterReadingWhereUniqueInput
  }

  /**
   * UtilityMeterReading updateMany
   */
  export type UtilityMeterReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UtilityMeterReadings.
     */
    data: XOR<UtilityMeterReadingUpdateManyMutationInput, UtilityMeterReadingUncheckedUpdateManyInput>
    /**
     * Filter which UtilityMeterReadings to update
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * Limit how many UtilityMeterReadings to update.
     */
    limit?: number
  }

  /**
   * UtilityMeterReading updateManyAndReturn
   */
  export type UtilityMeterReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * The data used to update UtilityMeterReadings.
     */
    data: XOR<UtilityMeterReadingUpdateManyMutationInput, UtilityMeterReadingUncheckedUpdateManyInput>
    /**
     * Filter which UtilityMeterReadings to update
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * Limit how many UtilityMeterReadings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UtilityMeterReading upsert
   */
  export type UtilityMeterReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the UtilityMeterReading to update in case it exists.
     */
    where: UtilityMeterReadingWhereUniqueInput
    /**
     * In case the UtilityMeterReading found by the `where` argument doesn't exist, create a new UtilityMeterReading with this data.
     */
    create: XOR<UtilityMeterReadingCreateInput, UtilityMeterReadingUncheckedCreateInput>
    /**
     * In case the UtilityMeterReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtilityMeterReadingUpdateInput, UtilityMeterReadingUncheckedUpdateInput>
  }

  /**
   * UtilityMeterReading delete
   */
  export type UtilityMeterReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
    /**
     * Filter which UtilityMeterReading to delete.
     */
    where: UtilityMeterReadingWhereUniqueInput
  }

  /**
   * UtilityMeterReading deleteMany
   */
  export type UtilityMeterReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UtilityMeterReadings to delete
     */
    where?: UtilityMeterReadingWhereInput
    /**
     * Limit how many UtilityMeterReadings to delete.
     */
    limit?: number
  }

  /**
   * UtilityMeterReading without action
   */
  export type UtilityMeterReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilityMeterReading
     */
    select?: UtilityMeterReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtilityMeterReading
     */
    omit?: UtilityMeterReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilityMeterReadingInclude<ExtArgs> | null
  }


  /**
   * Model Maintenance
   */

  export type AggregateMaintenance = {
    _count: MaintenanceCountAggregateOutputType | null
    _avg: MaintenanceAvgAggregateOutputType | null
    _sum: MaintenanceSumAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  export type MaintenanceAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type MaintenanceSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    reportedById: number | null
    assignedToId: number | null
  }

  export type MaintenanceMinAggregateOutputType = {
    id: number | null
    roomId: number | null
    reportedById: number | null
    issue: string | null
    reportDate: Date | null
    status: $Enums.MaintenanceStatus | null
    assignedToId: number | null
    completedDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceMaxAggregateOutputType = {
    id: number | null
    roomId: number | null
    reportedById: number | null
    issue: string | null
    reportDate: Date | null
    status: $Enums.MaintenanceStatus | null
    assignedToId: number | null
    completedDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceCountAggregateOutputType = {
    id: number
    roomId: number
    reportedById: number
    issue: number
    reportDate: number
    status: number
    assignedToId: number
    completedDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceAvgAggregateInputType = {
    id?: true
    roomId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type MaintenanceSumAggregateInputType = {
    id?: true
    roomId?: true
    reportedById?: true
    assignedToId?: true
  }

  export type MaintenanceMinAggregateInputType = {
    id?: true
    roomId?: true
    reportedById?: true
    issue?: true
    reportDate?: true
    status?: true
    assignedToId?: true
    completedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceMaxAggregateInputType = {
    id?: true
    roomId?: true
    reportedById?: true
    issue?: true
    reportDate?: true
    status?: true
    assignedToId?: true
    completedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceCountAggregateInputType = {
    id?: true
    roomId?: true
    reportedById?: true
    issue?: true
    reportDate?: true
    status?: true
    assignedToId?: true
    completedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenance to aggregate.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintenances
    **/
    _count?: true | MaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaxAggregateInputType
  }

  export type GetMaintenanceAggregateType<T extends MaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance[P]>
      : GetScalarType<T[P], AggregateMaintenance[P]>
  }




  export type MaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithAggregationInput | MaintenanceOrderByWithAggregationInput[]
    by: MaintenanceScalarFieldEnum[] | MaintenanceScalarFieldEnum
    having?: MaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCountAggregateInputType | true
    _avg?: MaintenanceAvgAggregateInputType
    _sum?: MaintenanceSumAggregateInputType
    _min?: MaintenanceMinAggregateInputType
    _max?: MaintenanceMaxAggregateInputType
  }

  export type MaintenanceGroupByOutputType = {
    id: number
    roomId: number
    reportedById: number
    issue: string
    reportDate: Date
    status: $Enums.MaintenanceStatus
    assignedToId: number | null
    completedDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceCountAggregateOutputType | null
    _avg: MaintenanceAvgAggregateOutputType | null
    _sum: MaintenanceSumAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  type GetMaintenanceGroupByPayload<T extends MaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    reportedById?: boolean
    issue?: boolean
    reportDate?: boolean
    status?: boolean
    assignedToId?: boolean
    completedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    reportedBy?: boolean | StudentProfileDefaultArgs<ExtArgs>
    assignedTo?: boolean | Maintenance$assignedToArgs<ExtArgs>
    images?: boolean | Maintenance$imagesArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    reportedById?: boolean
    issue?: boolean
    reportDate?: boolean
    status?: boolean
    assignedToId?: boolean
    completedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    reportedBy?: boolean | StudentProfileDefaultArgs<ExtArgs>
    assignedTo?: boolean | Maintenance$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    reportedById?: boolean
    issue?: boolean
    reportDate?: boolean
    status?: boolean
    assignedToId?: boolean
    completedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    reportedBy?: boolean | StudentProfileDefaultArgs<ExtArgs>
    assignedTo?: boolean | Maintenance$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectScalar = {
    id?: boolean
    roomId?: boolean
    reportedById?: boolean
    issue?: boolean
    reportDate?: boolean
    status?: boolean
    assignedToId?: boolean
    completedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "reportedById" | "issue" | "reportDate" | "status" | "assignedToId" | "completedDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenance"]>
  export type MaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    reportedBy?: boolean | StudentProfileDefaultArgs<ExtArgs>
    assignedTo?: boolean | Maintenance$assignedToArgs<ExtArgs>
    images?: boolean | Maintenance$imagesArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    reportedBy?: boolean | StudentProfileDefaultArgs<ExtArgs>
    assignedTo?: boolean | Maintenance$assignedToArgs<ExtArgs>
  }
  export type MaintenanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    reportedBy?: boolean | StudentProfileDefaultArgs<ExtArgs>
    assignedTo?: boolean | Maintenance$assignedToArgs<ExtArgs>
  }

  export type $MaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintenance"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      reportedBy: Prisma.$StudentProfilePayload<ExtArgs>
      assignedTo: Prisma.$StaffProfilePayload<ExtArgs> | null
      images: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomId: number
      reportedById: number
      issue: string
      reportDate: Date
      status: $Enums.MaintenanceStatus
      assignedToId: number | null
      completedDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenance"]>
    composites: {}
  }

  type MaintenanceGetPayload<S extends boolean | null | undefined | MaintenanceDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePayload, S>

  type MaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceCountAggregateInputType | true
    }

  export interface MaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintenance'], meta: { name: 'Maintenance' } }
    /**
     * Find zero or one Maintenance that matches the filter.
     * @param {MaintenanceFindUniqueArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceFindUniqueArgs>(args: SelectSubset<T, MaintenanceFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceFindUniqueOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceFindFirstArgs>(args?: SelectSubset<T, MaintenanceFindFirstArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenances
     * const maintenances = await prisma.maintenance.findMany()
     * 
     * // Get first 10 Maintenances
     * const maintenances = await prisma.maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceFindManyArgs>(args?: SelectSubset<T, MaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance.
     * @param {MaintenanceCreateArgs} args - Arguments to create a Maintenance.
     * @example
     * // Create one Maintenance
     * const Maintenance = await prisma.maintenance.create({
     *   data: {
     *     // ... data to create a Maintenance
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCreateArgs>(args: SelectSubset<T, MaintenanceCreateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenances.
     * @param {MaintenanceCreateManyArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCreateManyArgs>(args?: SelectSubset<T, MaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenances and returns the data saved in the database.
     * @param {MaintenanceCreateManyAndReturnArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintenance.
     * @param {MaintenanceDeleteArgs} args - Arguments to delete one Maintenance.
     * @example
     * // Delete one Maintenance
     * const Maintenance = await prisma.maintenance.delete({
     *   where: {
     *     // ... filter to delete one Maintenance
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDeleteArgs>(args: SelectSubset<T, MaintenanceDeleteArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance.
     * @param {MaintenanceUpdateArgs} args - Arguments to update one Maintenance.
     * @example
     * // Update one Maintenance
     * const maintenance = await prisma.maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceUpdateArgs>(args: SelectSubset<T, MaintenanceUpdateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenances.
     * @param {MaintenanceDeleteManyArgs} args - Arguments to filter Maintenances to delete.
     * @example
     * // Delete a few Maintenances
     * const { count } = await prisma.maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceUpdateManyArgs>(args: SelectSubset<T, MaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances and returns the data updated in the database.
     * @param {MaintenanceUpdateManyAndReturnArgs} args - Arguments to update many Maintenances.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintenance.
     * @param {MaintenanceUpsertArgs} args - Arguments to update or create a Maintenance.
     * @example
     * // Update or create a Maintenance
     * const maintenance = await prisma.maintenance.upsert({
     *   create: {
     *     // ... data to create a Maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceUpsertArgs>(args: SelectSubset<T, MaintenanceUpsertArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCountArgs} args - Arguments to filter Maintenances to count.
     * @example
     * // Count the number of Maintenances
     * const count = await prisma.maintenance.count({
     *   where: {
     *     // ... the filter for the Maintenances we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCountArgs>(
      args?: Subset<T, MaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceAggregateArgs>(args: Subset<T, MaintenanceAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceAggregateType<T>>

    /**
     * Group by Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintenance model
   */
  readonly fields: MaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedBy<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Maintenance$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$assignedToArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends Maintenance$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintenance model
   */
  interface MaintenanceFieldRefs {
    readonly id: FieldRef<"Maintenance", 'Int'>
    readonly roomId: FieldRef<"Maintenance", 'Int'>
    readonly reportedById: FieldRef<"Maintenance", 'Int'>
    readonly issue: FieldRef<"Maintenance", 'String'>
    readonly reportDate: FieldRef<"Maintenance", 'DateTime'>
    readonly status: FieldRef<"Maintenance", 'MaintenanceStatus'>
    readonly assignedToId: FieldRef<"Maintenance", 'Int'>
    readonly completedDate: FieldRef<"Maintenance", 'DateTime'>
    readonly notes: FieldRef<"Maintenance", 'String'>
    readonly createdAt: FieldRef<"Maintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"Maintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Maintenance findUnique
   */
  export type MaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findUniqueOrThrow
   */
  export type MaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findFirst
   */
  export type MaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findFirstOrThrow
   */
  export type MaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findMany
   */
  export type MaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenances to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance create
   */
  export type MaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintenance.
     */
    data: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
  }

  /**
   * Maintenance createMany
   */
  export type MaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance createManyAndReturn
   */
  export type MaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance update
   */
  export type MaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintenance.
     */
    data: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
    /**
     * Choose, which Maintenance to update.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance updateMany
   */
  export type MaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
  }

  /**
   * Maintenance updateManyAndReturn
   */
  export type MaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance upsert
   */
  export type MaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintenance to update in case it exists.
     */
    where: MaintenanceWhereUniqueInput
    /**
     * In case the Maintenance found by the `where` argument doesn't exist, create a new Maintenance with this data.
     */
    create: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
    /**
     * In case the Maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
  }

  /**
   * Maintenance delete
   */
  export type MaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter which Maintenance to delete.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance deleteMany
   */
  export type MaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenances to delete
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to delete.
     */
    limit?: number
  }

  /**
   * Maintenance.assignedTo
   */
  export type Maintenance$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * Maintenance.images
   */
  export type Maintenance$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Maintenance without action
   */
  export type MaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model RoomTransfer
   */

  export type AggregateRoomTransfer = {
    _count: RoomTransferCountAggregateOutputType | null
    _avg: RoomTransferAvgAggregateOutputType | null
    _sum: RoomTransferSumAggregateOutputType | null
    _min: RoomTransferMinAggregateOutputType | null
    _max: RoomTransferMaxAggregateOutputType | null
  }

  export type RoomTransferAvgAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    fromRoomId: number | null
    toRoomId: number | null
    approvedById: number | null
  }

  export type RoomTransferSumAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    fromRoomId: number | null
    toRoomId: number | null
    approvedById: number | null
  }

  export type RoomTransferMinAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    fromRoomId: number | null
    toRoomId: number | null
    transferDate: Date | null
    reason: string | null
    adminNotes: string | null
    approvedById: number | null
    status: $Enums.TransferStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomTransferMaxAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    fromRoomId: number | null
    toRoomId: number | null
    transferDate: Date | null
    reason: string | null
    adminNotes: string | null
    approvedById: number | null
    status: $Enums.TransferStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomTransferCountAggregateOutputType = {
    id: number
    studentProfileId: number
    fromRoomId: number
    toRoomId: number
    transferDate: number
    reason: number
    adminNotes: number
    approvedById: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomTransferAvgAggregateInputType = {
    id?: true
    studentProfileId?: true
    fromRoomId?: true
    toRoomId?: true
    approvedById?: true
  }

  export type RoomTransferSumAggregateInputType = {
    id?: true
    studentProfileId?: true
    fromRoomId?: true
    toRoomId?: true
    approvedById?: true
  }

  export type RoomTransferMinAggregateInputType = {
    id?: true
    studentProfileId?: true
    fromRoomId?: true
    toRoomId?: true
    transferDate?: true
    reason?: true
    adminNotes?: true
    approvedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomTransferMaxAggregateInputType = {
    id?: true
    studentProfileId?: true
    fromRoomId?: true
    toRoomId?: true
    transferDate?: true
    reason?: true
    adminNotes?: true
    approvedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomTransferCountAggregateInputType = {
    id?: true
    studentProfileId?: true
    fromRoomId?: true
    toRoomId?: true
    transferDate?: true
    reason?: true
    adminNotes?: true
    approvedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTransfer to aggregate.
     */
    where?: RoomTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTransfers to fetch.
     */
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTransfers
    **/
    _count?: true | RoomTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTransferMaxAggregateInputType
  }

  export type GetRoomTransferAggregateType<T extends RoomTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomTransfer[P]>
      : GetScalarType<T[P], AggregateRoomTransfer[P]>
  }




  export type RoomTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTransferWhereInput
    orderBy?: RoomTransferOrderByWithAggregationInput | RoomTransferOrderByWithAggregationInput[]
    by: RoomTransferScalarFieldEnum[] | RoomTransferScalarFieldEnum
    having?: RoomTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTransferCountAggregateInputType | true
    _avg?: RoomTransferAvgAggregateInputType
    _sum?: RoomTransferSumAggregateInputType
    _min?: RoomTransferMinAggregateInputType
    _max?: RoomTransferMaxAggregateInputType
  }

  export type RoomTransferGroupByOutputType = {
    id: number
    studentProfileId: number
    fromRoomId: number | null
    toRoomId: number
    transferDate: Date
    reason: string | null
    adminNotes: string | null
    approvedById: number | null
    status: $Enums.TransferStatus
    createdAt: Date
    updatedAt: Date
    _count: RoomTransferCountAggregateOutputType | null
    _avg: RoomTransferAvgAggregateOutputType | null
    _sum: RoomTransferSumAggregateOutputType | null
    _min: RoomTransferMinAggregateOutputType | null
    _max: RoomTransferMaxAggregateOutputType | null
  }

  type GetRoomTransferGroupByPayload<T extends RoomTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTransferGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTransferGroupByOutputType[P]>
        }
      >
    >


  export type RoomTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    fromRoomId?: boolean
    toRoomId?: boolean
    transferDate?: boolean
    reason?: boolean
    adminNotes?: boolean
    approvedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    fromRoom?: boolean | RoomTransfer$fromRoomArgs<ExtArgs>
    toRoom?: boolean | RoomDefaultArgs<ExtArgs>
    approvedBy?: boolean | RoomTransfer$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["roomTransfer"]>

  export type RoomTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    fromRoomId?: boolean
    toRoomId?: boolean
    transferDate?: boolean
    reason?: boolean
    adminNotes?: boolean
    approvedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    fromRoom?: boolean | RoomTransfer$fromRoomArgs<ExtArgs>
    toRoom?: boolean | RoomDefaultArgs<ExtArgs>
    approvedBy?: boolean | RoomTransfer$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["roomTransfer"]>

  export type RoomTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    fromRoomId?: boolean
    toRoomId?: boolean
    transferDate?: boolean
    reason?: boolean
    adminNotes?: boolean
    approvedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    fromRoom?: boolean | RoomTransfer$fromRoomArgs<ExtArgs>
    toRoom?: boolean | RoomDefaultArgs<ExtArgs>
    approvedBy?: boolean | RoomTransfer$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["roomTransfer"]>

  export type RoomTransferSelectScalar = {
    id?: boolean
    studentProfileId?: boolean
    fromRoomId?: boolean
    toRoomId?: boolean
    transferDate?: boolean
    reason?: boolean
    adminNotes?: boolean
    approvedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentProfileId" | "fromRoomId" | "toRoomId" | "transferDate" | "reason" | "adminNotes" | "approvedById" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["roomTransfer"]>
  export type RoomTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    fromRoom?: boolean | RoomTransfer$fromRoomArgs<ExtArgs>
    toRoom?: boolean | RoomDefaultArgs<ExtArgs>
    approvedBy?: boolean | RoomTransfer$approvedByArgs<ExtArgs>
  }
  export type RoomTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    fromRoom?: boolean | RoomTransfer$fromRoomArgs<ExtArgs>
    toRoom?: boolean | RoomDefaultArgs<ExtArgs>
    approvedBy?: boolean | RoomTransfer$approvedByArgs<ExtArgs>
  }
  export type RoomTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    fromRoom?: boolean | RoomTransfer$fromRoomArgs<ExtArgs>
    toRoom?: boolean | RoomDefaultArgs<ExtArgs>
    approvedBy?: boolean | RoomTransfer$approvedByArgs<ExtArgs>
  }

  export type $RoomTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomTransfer"
    objects: {
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs>
      fromRoom: Prisma.$RoomPayload<ExtArgs> | null
      toRoom: Prisma.$RoomPayload<ExtArgs>
      approvedBy: Prisma.$StaffProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentProfileId: number
      fromRoomId: number | null
      toRoomId: number
      transferDate: Date
      reason: string | null
      adminNotes: string | null
      approvedById: number | null
      status: $Enums.TransferStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomTransfer"]>
    composites: {}
  }

  type RoomTransferGetPayload<S extends boolean | null | undefined | RoomTransferDefaultArgs> = $Result.GetResult<Prisma.$RoomTransferPayload, S>

  type RoomTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomTransferCountAggregateInputType | true
    }

  export interface RoomTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomTransfer'], meta: { name: 'RoomTransfer' } }
    /**
     * Find zero or one RoomTransfer that matches the filter.
     * @param {RoomTransferFindUniqueArgs} args - Arguments to find a RoomTransfer
     * @example
     * // Get one RoomTransfer
     * const roomTransfer = await prisma.roomTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomTransferFindUniqueArgs>(args: SelectSubset<T, RoomTransferFindUniqueArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomTransferFindUniqueOrThrowArgs} args - Arguments to find a RoomTransfer
     * @example
     * // Get one RoomTransfer
     * const roomTransfer = await prisma.roomTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferFindFirstArgs} args - Arguments to find a RoomTransfer
     * @example
     * // Get one RoomTransfer
     * const roomTransfer = await prisma.roomTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomTransferFindFirstArgs>(args?: SelectSubset<T, RoomTransferFindFirstArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferFindFirstOrThrowArgs} args - Arguments to find a RoomTransfer
     * @example
     * // Get one RoomTransfer
     * const roomTransfer = await prisma.roomTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTransfers
     * const roomTransfers = await prisma.roomTransfer.findMany()
     * 
     * // Get first 10 RoomTransfers
     * const roomTransfers = await prisma.roomTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomTransferWithIdOnly = await prisma.roomTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomTransferFindManyArgs>(args?: SelectSubset<T, RoomTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomTransfer.
     * @param {RoomTransferCreateArgs} args - Arguments to create a RoomTransfer.
     * @example
     * // Create one RoomTransfer
     * const RoomTransfer = await prisma.roomTransfer.create({
     *   data: {
     *     // ... data to create a RoomTransfer
     *   }
     * })
     * 
     */
    create<T extends RoomTransferCreateArgs>(args: SelectSubset<T, RoomTransferCreateArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomTransfers.
     * @param {RoomTransferCreateManyArgs} args - Arguments to create many RoomTransfers.
     * @example
     * // Create many RoomTransfers
     * const roomTransfer = await prisma.roomTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomTransferCreateManyArgs>(args?: SelectSubset<T, RoomTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomTransfers and returns the data saved in the database.
     * @param {RoomTransferCreateManyAndReturnArgs} args - Arguments to create many RoomTransfers.
     * @example
     * // Create many RoomTransfers
     * const roomTransfer = await prisma.roomTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomTransfers and only return the `id`
     * const roomTransferWithIdOnly = await prisma.roomTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomTransfer.
     * @param {RoomTransferDeleteArgs} args - Arguments to delete one RoomTransfer.
     * @example
     * // Delete one RoomTransfer
     * const RoomTransfer = await prisma.roomTransfer.delete({
     *   where: {
     *     // ... filter to delete one RoomTransfer
     *   }
     * })
     * 
     */
    delete<T extends RoomTransferDeleteArgs>(args: SelectSubset<T, RoomTransferDeleteArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomTransfer.
     * @param {RoomTransferUpdateArgs} args - Arguments to update one RoomTransfer.
     * @example
     * // Update one RoomTransfer
     * const roomTransfer = await prisma.roomTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomTransferUpdateArgs>(args: SelectSubset<T, RoomTransferUpdateArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomTransfers.
     * @param {RoomTransferDeleteManyArgs} args - Arguments to filter RoomTransfers to delete.
     * @example
     * // Delete a few RoomTransfers
     * const { count } = await prisma.roomTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomTransferDeleteManyArgs>(args?: SelectSubset<T, RoomTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTransfers
     * const roomTransfer = await prisma.roomTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomTransferUpdateManyArgs>(args: SelectSubset<T, RoomTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTransfers and returns the data updated in the database.
     * @param {RoomTransferUpdateManyAndReturnArgs} args - Arguments to update many RoomTransfers.
     * @example
     * // Update many RoomTransfers
     * const roomTransfer = await prisma.roomTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomTransfers and only return the `id`
     * const roomTransferWithIdOnly = await prisma.roomTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomTransfer.
     * @param {RoomTransferUpsertArgs} args - Arguments to update or create a RoomTransfer.
     * @example
     * // Update or create a RoomTransfer
     * const roomTransfer = await prisma.roomTransfer.upsert({
     *   create: {
     *     // ... data to create a RoomTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomTransfer we want to update
     *   }
     * })
     */
    upsert<T extends RoomTransferUpsertArgs>(args: SelectSubset<T, RoomTransferUpsertArgs<ExtArgs>>): Prisma__RoomTransferClient<$Result.GetResult<Prisma.$RoomTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferCountArgs} args - Arguments to filter RoomTransfers to count.
     * @example
     * // Count the number of RoomTransfers
     * const count = await prisma.roomTransfer.count({
     *   where: {
     *     // ... the filter for the RoomTransfers we want to count
     *   }
     * })
    **/
    count<T extends RoomTransferCountArgs>(
      args?: Subset<T, RoomTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTransferAggregateArgs>(args: Subset<T, RoomTransferAggregateArgs>): Prisma.PrismaPromise<GetRoomTransferAggregateType<T>>

    /**
     * Group by RoomTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTransferGroupByArgs['orderBy'] }
        : { orderBy?: RoomTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomTransfer model
   */
  readonly fields: RoomTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentProfile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromRoom<T extends RoomTransfer$fromRoomArgs<ExtArgs> = {}>(args?: Subset<T, RoomTransfer$fromRoomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toRoom<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends RoomTransfer$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, RoomTransfer$approvedByArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomTransfer model
   */
  interface RoomTransferFieldRefs {
    readonly id: FieldRef<"RoomTransfer", 'Int'>
    readonly studentProfileId: FieldRef<"RoomTransfer", 'Int'>
    readonly fromRoomId: FieldRef<"RoomTransfer", 'Int'>
    readonly toRoomId: FieldRef<"RoomTransfer", 'Int'>
    readonly transferDate: FieldRef<"RoomTransfer", 'DateTime'>
    readonly reason: FieldRef<"RoomTransfer", 'String'>
    readonly adminNotes: FieldRef<"RoomTransfer", 'String'>
    readonly approvedById: FieldRef<"RoomTransfer", 'Int'>
    readonly status: FieldRef<"RoomTransfer", 'TransferStatus'>
    readonly createdAt: FieldRef<"RoomTransfer", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomTransfer findUnique
   */
  export type RoomTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * Filter, which RoomTransfer to fetch.
     */
    where: RoomTransferWhereUniqueInput
  }

  /**
   * RoomTransfer findUniqueOrThrow
   */
  export type RoomTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * Filter, which RoomTransfer to fetch.
     */
    where: RoomTransferWhereUniqueInput
  }

  /**
   * RoomTransfer findFirst
   */
  export type RoomTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * Filter, which RoomTransfer to fetch.
     */
    where?: RoomTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTransfers to fetch.
     */
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTransfers.
     */
    cursor?: RoomTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTransfers.
     */
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * RoomTransfer findFirstOrThrow
   */
  export type RoomTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * Filter, which RoomTransfer to fetch.
     */
    where?: RoomTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTransfers to fetch.
     */
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTransfers.
     */
    cursor?: RoomTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTransfers.
     */
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * RoomTransfer findMany
   */
  export type RoomTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * Filter, which RoomTransfers to fetch.
     */
    where?: RoomTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTransfers to fetch.
     */
    orderBy?: RoomTransferOrderByWithRelationInput | RoomTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTransfers.
     */
    cursor?: RoomTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTransfers.
     */
    skip?: number
    distinct?: RoomTransferScalarFieldEnum | RoomTransferScalarFieldEnum[]
  }

  /**
   * RoomTransfer create
   */
  export type RoomTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomTransfer.
     */
    data: XOR<RoomTransferCreateInput, RoomTransferUncheckedCreateInput>
  }

  /**
   * RoomTransfer createMany
   */
  export type RoomTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTransfers.
     */
    data: RoomTransferCreateManyInput | RoomTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomTransfer createManyAndReturn
   */
  export type RoomTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * The data used to create many RoomTransfers.
     */
    data: RoomTransferCreateManyInput | RoomTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomTransfer update
   */
  export type RoomTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomTransfer.
     */
    data: XOR<RoomTransferUpdateInput, RoomTransferUncheckedUpdateInput>
    /**
     * Choose, which RoomTransfer to update.
     */
    where: RoomTransferWhereUniqueInput
  }

  /**
   * RoomTransfer updateMany
   */
  export type RoomTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTransfers.
     */
    data: XOR<RoomTransferUpdateManyMutationInput, RoomTransferUncheckedUpdateManyInput>
    /**
     * Filter which RoomTransfers to update
     */
    where?: RoomTransferWhereInput
    /**
     * Limit how many RoomTransfers to update.
     */
    limit?: number
  }

  /**
   * RoomTransfer updateManyAndReturn
   */
  export type RoomTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * The data used to update RoomTransfers.
     */
    data: XOR<RoomTransferUpdateManyMutationInput, RoomTransferUncheckedUpdateManyInput>
    /**
     * Filter which RoomTransfers to update
     */
    where?: RoomTransferWhereInput
    /**
     * Limit how many RoomTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomTransfer upsert
   */
  export type RoomTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomTransfer to update in case it exists.
     */
    where: RoomTransferWhereUniqueInput
    /**
     * In case the RoomTransfer found by the `where` argument doesn't exist, create a new RoomTransfer with this data.
     */
    create: XOR<RoomTransferCreateInput, RoomTransferUncheckedCreateInput>
    /**
     * In case the RoomTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTransferUpdateInput, RoomTransferUncheckedUpdateInput>
  }

  /**
   * RoomTransfer delete
   */
  export type RoomTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
    /**
     * Filter which RoomTransfer to delete.
     */
    where: RoomTransferWhereUniqueInput
  }

  /**
   * RoomTransfer deleteMany
   */
  export type RoomTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTransfers to delete
     */
    where?: RoomTransferWhereInput
    /**
     * Limit how many RoomTransfers to delete.
     */
    limit?: number
  }

  /**
   * RoomTransfer.fromRoom
   */
  export type RoomTransfer$fromRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * RoomTransfer.approvedBy
   */
  export type RoomTransfer$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * RoomTransfer without action
   */
  export type RoomTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTransfer
     */
    select?: RoomTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTransfer
     */
    omit?: RoomTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTransferInclude<ExtArgs> | null
  }


  /**
   * Model VehicleRegistration
   */

  export type AggregateVehicleRegistration = {
    _count: VehicleRegistrationCountAggregateOutputType | null
    _avg: VehicleRegistrationAvgAggregateOutputType | null
    _sum: VehicleRegistrationSumAggregateOutputType | null
    _min: VehicleRegistrationMinAggregateOutputType | null
    _max: VehicleRegistrationMaxAggregateOutputType | null
  }

  export type VehicleRegistrationAvgAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
  }

  export type VehicleRegistrationSumAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
  }

  export type VehicleRegistrationMinAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    vehicleType: $Enums.VehicleType | null
    licensePlate: string | null
    brand: string | null
    model: string | null
    color: string | null
    parkingCardNo: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleRegistrationMaxAggregateOutputType = {
    id: number | null
    studentProfileId: number | null
    vehicleType: $Enums.VehicleType | null
    licensePlate: string | null
    brand: string | null
    model: string | null
    color: string | null
    parkingCardNo: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleRegistrationCountAggregateOutputType = {
    id: number
    studentProfileId: number
    vehicleType: number
    licensePlate: number
    brand: number
    model: number
    color: number
    parkingCardNo: number
    isActive: number
    startDate: number
    endDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleRegistrationAvgAggregateInputType = {
    id?: true
    studentProfileId?: true
  }

  export type VehicleRegistrationSumAggregateInputType = {
    id?: true
    studentProfileId?: true
  }

  export type VehicleRegistrationMinAggregateInputType = {
    id?: true
    studentProfileId?: true
    vehicleType?: true
    licensePlate?: true
    brand?: true
    model?: true
    color?: true
    parkingCardNo?: true
    isActive?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleRegistrationMaxAggregateInputType = {
    id?: true
    studentProfileId?: true
    vehicleType?: true
    licensePlate?: true
    brand?: true
    model?: true
    color?: true
    parkingCardNo?: true
    isActive?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleRegistrationCountAggregateInputType = {
    id?: true
    studentProfileId?: true
    vehicleType?: true
    licensePlate?: true
    brand?: true
    model?: true
    color?: true
    parkingCardNo?: true
    isActive?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleRegistration to aggregate.
     */
    where?: VehicleRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleRegistrations to fetch.
     */
    orderBy?: VehicleRegistrationOrderByWithRelationInput | VehicleRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleRegistrations
    **/
    _count?: true | VehicleRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleRegistrationMaxAggregateInputType
  }

  export type GetVehicleRegistrationAggregateType<T extends VehicleRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleRegistration[P]>
      : GetScalarType<T[P], AggregateVehicleRegistration[P]>
  }




  export type VehicleRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleRegistrationWhereInput
    orderBy?: VehicleRegistrationOrderByWithAggregationInput | VehicleRegistrationOrderByWithAggregationInput[]
    by: VehicleRegistrationScalarFieldEnum[] | VehicleRegistrationScalarFieldEnum
    having?: VehicleRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleRegistrationCountAggregateInputType | true
    _avg?: VehicleRegistrationAvgAggregateInputType
    _sum?: VehicleRegistrationSumAggregateInputType
    _min?: VehicleRegistrationMinAggregateInputType
    _max?: VehicleRegistrationMaxAggregateInputType
  }

  export type VehicleRegistrationGroupByOutputType = {
    id: number
    studentProfileId: number
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand: string | null
    model: string | null
    color: string | null
    parkingCardNo: string | null
    isActive: boolean
    startDate: Date
    endDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: VehicleRegistrationCountAggregateOutputType | null
    _avg: VehicleRegistrationAvgAggregateOutputType | null
    _sum: VehicleRegistrationSumAggregateOutputType | null
    _min: VehicleRegistrationMinAggregateOutputType | null
    _max: VehicleRegistrationMaxAggregateOutputType | null
  }

  type GetVehicleRegistrationGroupByPayload<T extends VehicleRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type VehicleRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    parkingCardNo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    images?: boolean | VehicleRegistration$imagesArgs<ExtArgs>
    _count?: boolean | VehicleRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleRegistration"]>

  export type VehicleRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    parkingCardNo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleRegistration"]>

  export type VehicleRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentProfileId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    parkingCardNo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleRegistration"]>

  export type VehicleRegistrationSelectScalar = {
    id?: boolean
    studentProfileId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    color?: boolean
    parkingCardNo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentProfileId" | "vehicleType" | "licensePlate" | "brand" | "model" | "color" | "parkingCardNo" | "isActive" | "startDate" | "endDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicleRegistration"]>
  export type VehicleRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    images?: boolean | VehicleRegistration$imagesArgs<ExtArgs>
    _count?: boolean | VehicleRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type VehicleRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $VehicleRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleRegistration"
    objects: {
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs>
      images: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentProfileId: number
      vehicleType: $Enums.VehicleType
      licensePlate: string
      brand: string | null
      model: string | null
      color: string | null
      parkingCardNo: string | null
      isActive: boolean
      startDate: Date
      endDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicleRegistration"]>
    composites: {}
  }

  type VehicleRegistrationGetPayload<S extends boolean | null | undefined | VehicleRegistrationDefaultArgs> = $Result.GetResult<Prisma.$VehicleRegistrationPayload, S>

  type VehicleRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleRegistrationCountAggregateInputType | true
    }

  export interface VehicleRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleRegistration'], meta: { name: 'VehicleRegistration' } }
    /**
     * Find zero or one VehicleRegistration that matches the filter.
     * @param {VehicleRegistrationFindUniqueArgs} args - Arguments to find a VehicleRegistration
     * @example
     * // Get one VehicleRegistration
     * const vehicleRegistration = await prisma.vehicleRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleRegistrationFindUniqueArgs>(args: SelectSubset<T, VehicleRegistrationFindUniqueArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleRegistrationFindUniqueOrThrowArgs} args - Arguments to find a VehicleRegistration
     * @example
     * // Get one VehicleRegistration
     * const vehicleRegistration = await prisma.vehicleRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationFindFirstArgs} args - Arguments to find a VehicleRegistration
     * @example
     * // Get one VehicleRegistration
     * const vehicleRegistration = await prisma.vehicleRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleRegistrationFindFirstArgs>(args?: SelectSubset<T, VehicleRegistrationFindFirstArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationFindFirstOrThrowArgs} args - Arguments to find a VehicleRegistration
     * @example
     * // Get one VehicleRegistration
     * const vehicleRegistration = await prisma.vehicleRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleRegistrations
     * const vehicleRegistrations = await prisma.vehicleRegistration.findMany()
     * 
     * // Get first 10 VehicleRegistrations
     * const vehicleRegistrations = await prisma.vehicleRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleRegistrationWithIdOnly = await prisma.vehicleRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleRegistrationFindManyArgs>(args?: SelectSubset<T, VehicleRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleRegistration.
     * @param {VehicleRegistrationCreateArgs} args - Arguments to create a VehicleRegistration.
     * @example
     * // Create one VehicleRegistration
     * const VehicleRegistration = await prisma.vehicleRegistration.create({
     *   data: {
     *     // ... data to create a VehicleRegistration
     *   }
     * })
     * 
     */
    create<T extends VehicleRegistrationCreateArgs>(args: SelectSubset<T, VehicleRegistrationCreateArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleRegistrations.
     * @param {VehicleRegistrationCreateManyArgs} args - Arguments to create many VehicleRegistrations.
     * @example
     * // Create many VehicleRegistrations
     * const vehicleRegistration = await prisma.vehicleRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleRegistrationCreateManyArgs>(args?: SelectSubset<T, VehicleRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleRegistrations and returns the data saved in the database.
     * @param {VehicleRegistrationCreateManyAndReturnArgs} args - Arguments to create many VehicleRegistrations.
     * @example
     * // Create many VehicleRegistrations
     * const vehicleRegistration = await prisma.vehicleRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleRegistrations and only return the `id`
     * const vehicleRegistrationWithIdOnly = await prisma.vehicleRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleRegistration.
     * @param {VehicleRegistrationDeleteArgs} args - Arguments to delete one VehicleRegistration.
     * @example
     * // Delete one VehicleRegistration
     * const VehicleRegistration = await prisma.vehicleRegistration.delete({
     *   where: {
     *     // ... filter to delete one VehicleRegistration
     *   }
     * })
     * 
     */
    delete<T extends VehicleRegistrationDeleteArgs>(args: SelectSubset<T, VehicleRegistrationDeleteArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleRegistration.
     * @param {VehicleRegistrationUpdateArgs} args - Arguments to update one VehicleRegistration.
     * @example
     * // Update one VehicleRegistration
     * const vehicleRegistration = await prisma.vehicleRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleRegistrationUpdateArgs>(args: SelectSubset<T, VehicleRegistrationUpdateArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleRegistrations.
     * @param {VehicleRegistrationDeleteManyArgs} args - Arguments to filter VehicleRegistrations to delete.
     * @example
     * // Delete a few VehicleRegistrations
     * const { count } = await prisma.vehicleRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleRegistrationDeleteManyArgs>(args?: SelectSubset<T, VehicleRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleRegistrations
     * const vehicleRegistration = await prisma.vehicleRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleRegistrationUpdateManyArgs>(args: SelectSubset<T, VehicleRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleRegistrations and returns the data updated in the database.
     * @param {VehicleRegistrationUpdateManyAndReturnArgs} args - Arguments to update many VehicleRegistrations.
     * @example
     * // Update many VehicleRegistrations
     * const vehicleRegistration = await prisma.vehicleRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleRegistrations and only return the `id`
     * const vehicleRegistrationWithIdOnly = await prisma.vehicleRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleRegistration.
     * @param {VehicleRegistrationUpsertArgs} args - Arguments to update or create a VehicleRegistration.
     * @example
     * // Update or create a VehicleRegistration
     * const vehicleRegistration = await prisma.vehicleRegistration.upsert({
     *   create: {
     *     // ... data to create a VehicleRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleRegistration we want to update
     *   }
     * })
     */
    upsert<T extends VehicleRegistrationUpsertArgs>(args: SelectSubset<T, VehicleRegistrationUpsertArgs<ExtArgs>>): Prisma__VehicleRegistrationClient<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationCountArgs} args - Arguments to filter VehicleRegistrations to count.
     * @example
     * // Count the number of VehicleRegistrations
     * const count = await prisma.vehicleRegistration.count({
     *   where: {
     *     // ... the filter for the VehicleRegistrations we want to count
     *   }
     * })
    **/
    count<T extends VehicleRegistrationCountArgs>(
      args?: Subset<T, VehicleRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleRegistrationAggregateArgs>(args: Subset<T, VehicleRegistrationAggregateArgs>): Prisma.PrismaPromise<GetVehicleRegistrationAggregateType<T>>

    /**
     * Group by VehicleRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: VehicleRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleRegistration model
   */
  readonly fields: VehicleRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentProfile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends VehicleRegistration$imagesArgs<ExtArgs> = {}>(args?: Subset<T, VehicleRegistration$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleRegistration model
   */
  interface VehicleRegistrationFieldRefs {
    readonly id: FieldRef<"VehicleRegistration", 'Int'>
    readonly studentProfileId: FieldRef<"VehicleRegistration", 'Int'>
    readonly vehicleType: FieldRef<"VehicleRegistration", 'VehicleType'>
    readonly licensePlate: FieldRef<"VehicleRegistration", 'String'>
    readonly brand: FieldRef<"VehicleRegistration", 'String'>
    readonly model: FieldRef<"VehicleRegistration", 'String'>
    readonly color: FieldRef<"VehicleRegistration", 'String'>
    readonly parkingCardNo: FieldRef<"VehicleRegistration", 'String'>
    readonly isActive: FieldRef<"VehicleRegistration", 'Boolean'>
    readonly startDate: FieldRef<"VehicleRegistration", 'DateTime'>
    readonly endDate: FieldRef<"VehicleRegistration", 'DateTime'>
    readonly notes: FieldRef<"VehicleRegistration", 'String'>
    readonly createdAt: FieldRef<"VehicleRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"VehicleRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VehicleRegistration findUnique
   */
  export type VehicleRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleRegistration to fetch.
     */
    where: VehicleRegistrationWhereUniqueInput
  }

  /**
   * VehicleRegistration findUniqueOrThrow
   */
  export type VehicleRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleRegistration to fetch.
     */
    where: VehicleRegistrationWhereUniqueInput
  }

  /**
   * VehicleRegistration findFirst
   */
  export type VehicleRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleRegistration to fetch.
     */
    where?: VehicleRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleRegistrations to fetch.
     */
    orderBy?: VehicleRegistrationOrderByWithRelationInput | VehicleRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleRegistrations.
     */
    cursor?: VehicleRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleRegistrations.
     */
    distinct?: VehicleRegistrationScalarFieldEnum | VehicleRegistrationScalarFieldEnum[]
  }

  /**
   * VehicleRegistration findFirstOrThrow
   */
  export type VehicleRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleRegistration to fetch.
     */
    where?: VehicleRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleRegistrations to fetch.
     */
    orderBy?: VehicleRegistrationOrderByWithRelationInput | VehicleRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleRegistrations.
     */
    cursor?: VehicleRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleRegistrations.
     */
    distinct?: VehicleRegistrationScalarFieldEnum | VehicleRegistrationScalarFieldEnum[]
  }

  /**
   * VehicleRegistration findMany
   */
  export type VehicleRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleRegistrations to fetch.
     */
    where?: VehicleRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleRegistrations to fetch.
     */
    orderBy?: VehicleRegistrationOrderByWithRelationInput | VehicleRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleRegistrations.
     */
    cursor?: VehicleRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleRegistrations.
     */
    skip?: number
    distinct?: VehicleRegistrationScalarFieldEnum | VehicleRegistrationScalarFieldEnum[]
  }

  /**
   * VehicleRegistration create
   */
  export type VehicleRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleRegistration.
     */
    data: XOR<VehicleRegistrationCreateInput, VehicleRegistrationUncheckedCreateInput>
  }

  /**
   * VehicleRegistration createMany
   */
  export type VehicleRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleRegistrations.
     */
    data: VehicleRegistrationCreateManyInput | VehicleRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleRegistration createManyAndReturn
   */
  export type VehicleRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleRegistrations.
     */
    data: VehicleRegistrationCreateManyInput | VehicleRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleRegistration update
   */
  export type VehicleRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleRegistration.
     */
    data: XOR<VehicleRegistrationUpdateInput, VehicleRegistrationUncheckedUpdateInput>
    /**
     * Choose, which VehicleRegistration to update.
     */
    where: VehicleRegistrationWhereUniqueInput
  }

  /**
   * VehicleRegistration updateMany
   */
  export type VehicleRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleRegistrations.
     */
    data: XOR<VehicleRegistrationUpdateManyMutationInput, VehicleRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleRegistrations to update
     */
    where?: VehicleRegistrationWhereInput
    /**
     * Limit how many VehicleRegistrations to update.
     */
    limit?: number
  }

  /**
   * VehicleRegistration updateManyAndReturn
   */
  export type VehicleRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update VehicleRegistrations.
     */
    data: XOR<VehicleRegistrationUpdateManyMutationInput, VehicleRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleRegistrations to update
     */
    where?: VehicleRegistrationWhereInput
    /**
     * Limit how many VehicleRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleRegistration upsert
   */
  export type VehicleRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleRegistration to update in case it exists.
     */
    where: VehicleRegistrationWhereUniqueInput
    /**
     * In case the VehicleRegistration found by the `where` argument doesn't exist, create a new VehicleRegistration with this data.
     */
    create: XOR<VehicleRegistrationCreateInput, VehicleRegistrationUncheckedCreateInput>
    /**
     * In case the VehicleRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleRegistrationUpdateInput, VehicleRegistrationUncheckedUpdateInput>
  }

  /**
   * VehicleRegistration delete
   */
  export type VehicleRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    /**
     * Filter which VehicleRegistration to delete.
     */
    where: VehicleRegistrationWhereUniqueInput
  }

  /**
   * VehicleRegistration deleteMany
   */
  export type VehicleRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleRegistrations to delete
     */
    where?: VehicleRegistrationWhereInput
    /**
     * Limit how many VehicleRegistrations to delete.
     */
    limit?: number
  }

  /**
   * VehicleRegistration.images
   */
  export type VehicleRegistration$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * VehicleRegistration without action
   */
  export type VehicleRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    size: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    size: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    filename: string | null
    path: string | null
    mimeType: string | null
    size: number | null
    mediaType: $Enums.MediaType | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    path: string | null
    mimeType: string | null
    size: number | null
    mediaType: $Enums.MediaType | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    filename: number
    path: number
    mimeType: number
    size: number
    mediaType: number
    uploadedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    size?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    size?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    filename?: true
    path?: true
    mimeType?: true
    size?: true
    mediaType?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    filename?: true
    path?: true
    mimeType?: true
    size?: true
    mediaType?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    filename?: true
    path?: true
    mimeType?: true
    size?: true
    mediaType?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarFor?: boolean | Media$avatarForArgs<ExtArgs>
    roomImages?: boolean | Media$roomImagesArgs<ExtArgs>
    buildingImages?: boolean | Media$buildingImagesArgs<ExtArgs>
    vehicleImages?: boolean | Media$vehicleImagesArgs<ExtArgs>
    maintenanceImages?: boolean | Media$maintenanceImagesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    mediaType?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "path" | "mimeType" | "size" | "mediaType" | "uploadedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFor?: boolean | Media$avatarForArgs<ExtArgs>
    roomImages?: boolean | Media$roomImagesArgs<ExtArgs>
    buildingImages?: boolean | Media$buildingImagesArgs<ExtArgs>
    vehicleImages?: boolean | Media$vehicleImagesArgs<ExtArgs>
    maintenanceImages?: boolean | Media$maintenanceImagesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      avatarFor: Prisma.$UserPayload<ExtArgs>[]
      roomImages: Prisma.$RoomPayload<ExtArgs>[]
      buildingImages: Prisma.$BuildingPayload<ExtArgs>[]
      vehicleImages: Prisma.$VehicleRegistrationPayload<ExtArgs>[]
      maintenanceImages: Prisma.$MaintenancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      path: string
      mimeType: string
      size: number
      mediaType: $Enums.MediaType
      uploadedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatarFor<T extends Media$avatarForArgs<ExtArgs> = {}>(args?: Subset<T, Media$avatarForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomImages<T extends Media$roomImagesArgs<ExtArgs> = {}>(args?: Subset<T, Media$roomImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buildingImages<T extends Media$buildingImagesArgs<ExtArgs> = {}>(args?: Subset<T, Media$buildingImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleImages<T extends Media$vehicleImagesArgs<ExtArgs> = {}>(args?: Subset<T, Media$vehicleImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceImages<T extends Media$maintenanceImagesArgs<ExtArgs> = {}>(args?: Subset<T, Media$maintenanceImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'Int'>
    readonly filename: FieldRef<"Media", 'String'>
    readonly path: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly size: FieldRef<"Media", 'Int'>
    readonly mediaType: FieldRef<"Media", 'MediaType'>
    readonly uploadedAt: FieldRef<"Media", 'DateTime'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.avatarFor
   */
  export type Media$avatarForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Media.roomImages
   */
  export type Media$roomImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Media.buildingImages
   */
  export type Media$buildingImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    cursor?: BuildingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Media.vehicleImages
   */
  export type Media$vehicleImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleRegistration
     */
    select?: VehicleRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleRegistration
     */
    omit?: VehicleRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleRegistrationInclude<ExtArgs> | null
    where?: VehicleRegistrationWhereInput
    orderBy?: VehicleRegistrationOrderByWithRelationInput | VehicleRegistrationOrderByWithRelationInput[]
    cursor?: VehicleRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleRegistrationScalarFieldEnum | VehicleRegistrationScalarFieldEnum[]
  }

  /**
   * Media.maintenanceImages
   */
  export type Media$maintenanceImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model LoginLog
   */

  export type AggregateLoginLog = {
    _count: LoginLogCountAggregateOutputType | null
    _avg: LoginLogAvgAggregateOutputType | null
    _sum: LoginLogSumAggregateOutputType | null
    _min: LoginLogMinAggregateOutputType | null
    _max: LoginLogMaxAggregateOutputType | null
  }

  export type LoginLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LoginLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LoginLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    location: string | null
  }

  export type LoginLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    location: string | null
  }

  export type LoginLogCountAggregateOutputType = {
    id: number
    userId: number
    timestamp: number
    ipAddress: number
    userAgent: number
    status: number
    location: number
    _all: number
  }


  export type LoginLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LoginLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LoginLogMinAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    location?: true
  }

  export type LoginLogMaxAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    location?: true
  }

  export type LoginLogCountAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    location?: true
    _all?: true
  }

  export type LoginLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginLog to aggregate.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginLogs
    **/
    _count?: true | LoginLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginLogMaxAggregateInputType
  }

  export type GetLoginLogAggregateType<T extends LoginLogAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginLog[P]>
      : GetScalarType<T[P], AggregateLoginLog[P]>
  }




  export type LoginLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginLogWhereInput
    orderBy?: LoginLogOrderByWithAggregationInput | LoginLogOrderByWithAggregationInput[]
    by: LoginLogScalarFieldEnum[] | LoginLogScalarFieldEnum
    having?: LoginLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginLogCountAggregateInputType | true
    _avg?: LoginLogAvgAggregateInputType
    _sum?: LoginLogSumAggregateInputType
    _min?: LoginLogMinAggregateInputType
    _max?: LoginLogMaxAggregateInputType
  }

  export type LoginLogGroupByOutputType = {
    id: number
    userId: number
    timestamp: Date
    ipAddress: string | null
    userAgent: string | null
    status: string
    location: string | null
    _count: LoginLogCountAggregateOutputType | null
    _avg: LoginLogAvgAggregateOutputType | null
    _sum: LoginLogSumAggregateOutputType | null
    _min: LoginLogMinAggregateOutputType | null
    _max: LoginLogMaxAggregateOutputType | null
  }

  type GetLoginLogGroupByPayload<T extends LoginLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginLogGroupByOutputType[P]>
            : GetScalarType<T[P], LoginLogGroupByOutputType[P]>
        }
      >
    >


  export type LoginLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    location?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginLog"]>

  export type LoginLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    location?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginLog"]>

  export type LoginLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    location?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginLog"]>

  export type LoginLogSelectScalar = {
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    location?: boolean
  }

  export type LoginLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "timestamp" | "ipAddress" | "userAgent" | "status" | "location", ExtArgs["result"]["loginLog"]>
  export type LoginLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoginLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      timestamp: Date
      ipAddress: string | null
      userAgent: string | null
      status: string
      location: string | null
    }, ExtArgs["result"]["loginLog"]>
    composites: {}
  }

  type LoginLogGetPayload<S extends boolean | null | undefined | LoginLogDefaultArgs> = $Result.GetResult<Prisma.$LoginLogPayload, S>

  type LoginLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginLogCountAggregateInputType | true
    }

  export interface LoginLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginLog'], meta: { name: 'LoginLog' } }
    /**
     * Find zero or one LoginLog that matches the filter.
     * @param {LoginLogFindUniqueArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginLogFindUniqueArgs>(args: SelectSubset<T, LoginLogFindUniqueArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginLogFindUniqueOrThrowArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginLogFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogFindFirstArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginLogFindFirstArgs>(args?: SelectSubset<T, LoginLogFindFirstArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogFindFirstOrThrowArgs} args - Arguments to find a LoginLog
     * @example
     * // Get one LoginLog
     * const loginLog = await prisma.loginLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginLogFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginLogs
     * const loginLogs = await prisma.loginLog.findMany()
     * 
     * // Get first 10 LoginLogs
     * const loginLogs = await prisma.loginLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginLogWithIdOnly = await prisma.loginLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginLogFindManyArgs>(args?: SelectSubset<T, LoginLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginLog.
     * @param {LoginLogCreateArgs} args - Arguments to create a LoginLog.
     * @example
     * // Create one LoginLog
     * const LoginLog = await prisma.loginLog.create({
     *   data: {
     *     // ... data to create a LoginLog
     *   }
     * })
     * 
     */
    create<T extends LoginLogCreateArgs>(args: SelectSubset<T, LoginLogCreateArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginLogs.
     * @param {LoginLogCreateManyArgs} args - Arguments to create many LoginLogs.
     * @example
     * // Create many LoginLogs
     * const loginLog = await prisma.loginLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginLogCreateManyArgs>(args?: SelectSubset<T, LoginLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginLogs and returns the data saved in the database.
     * @param {LoginLogCreateManyAndReturnArgs} args - Arguments to create many LoginLogs.
     * @example
     * // Create many LoginLogs
     * const loginLog = await prisma.loginLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginLogs and only return the `id`
     * const loginLogWithIdOnly = await prisma.loginLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginLogCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoginLog.
     * @param {LoginLogDeleteArgs} args - Arguments to delete one LoginLog.
     * @example
     * // Delete one LoginLog
     * const LoginLog = await prisma.loginLog.delete({
     *   where: {
     *     // ... filter to delete one LoginLog
     *   }
     * })
     * 
     */
    delete<T extends LoginLogDeleteArgs>(args: SelectSubset<T, LoginLogDeleteArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginLog.
     * @param {LoginLogUpdateArgs} args - Arguments to update one LoginLog.
     * @example
     * // Update one LoginLog
     * const loginLog = await prisma.loginLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginLogUpdateArgs>(args: SelectSubset<T, LoginLogUpdateArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginLogs.
     * @param {LoginLogDeleteManyArgs} args - Arguments to filter LoginLogs to delete.
     * @example
     * // Delete a few LoginLogs
     * const { count } = await prisma.loginLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginLogDeleteManyArgs>(args?: SelectSubset<T, LoginLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginLogs
     * const loginLog = await prisma.loginLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginLogUpdateManyArgs>(args: SelectSubset<T, LoginLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginLogs and returns the data updated in the database.
     * @param {LoginLogUpdateManyAndReturnArgs} args - Arguments to update many LoginLogs.
     * @example
     * // Update many LoginLogs
     * const loginLog = await prisma.loginLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoginLogs and only return the `id`
     * const loginLogWithIdOnly = await prisma.loginLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoginLogUpdateManyAndReturnArgs>(args: SelectSubset<T, LoginLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoginLog.
     * @param {LoginLogUpsertArgs} args - Arguments to update or create a LoginLog.
     * @example
     * // Update or create a LoginLog
     * const loginLog = await prisma.loginLog.upsert({
     *   create: {
     *     // ... data to create a LoginLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginLog we want to update
     *   }
     * })
     */
    upsert<T extends LoginLogUpsertArgs>(args: SelectSubset<T, LoginLogUpsertArgs<ExtArgs>>): Prisma__LoginLogClient<$Result.GetResult<Prisma.$LoginLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogCountArgs} args - Arguments to filter LoginLogs to count.
     * @example
     * // Count the number of LoginLogs
     * const count = await prisma.loginLog.count({
     *   where: {
     *     // ... the filter for the LoginLogs we want to count
     *   }
     * })
    **/
    count<T extends LoginLogCountArgs>(
      args?: Subset<T, LoginLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginLogAggregateArgs>(args: Subset<T, LoginLogAggregateArgs>): Prisma.PrismaPromise<GetLoginLogAggregateType<T>>

    /**
     * Group by LoginLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginLogGroupByArgs['orderBy'] }
        : { orderBy?: LoginLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginLog model
   */
  readonly fields: LoginLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginLog model
   */
  interface LoginLogFieldRefs {
    readonly id: FieldRef<"LoginLog", 'Int'>
    readonly userId: FieldRef<"LoginLog", 'Int'>
    readonly timestamp: FieldRef<"LoginLog", 'DateTime'>
    readonly ipAddress: FieldRef<"LoginLog", 'String'>
    readonly userAgent: FieldRef<"LoginLog", 'String'>
    readonly status: FieldRef<"LoginLog", 'String'>
    readonly location: FieldRef<"LoginLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LoginLog findUnique
   */
  export type LoginLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog findUniqueOrThrow
   */
  export type LoginLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog findFirst
   */
  export type LoginLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginLogs.
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginLogs.
     */
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * LoginLog findFirstOrThrow
   */
  export type LoginLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLog to fetch.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginLogs.
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginLogs.
     */
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * LoginLog findMany
   */
  export type LoginLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter, which LoginLogs to fetch.
     */
    where?: LoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginLogs to fetch.
     */
    orderBy?: LoginLogOrderByWithRelationInput | LoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginLogs.
     */
    cursor?: LoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginLogs.
     */
    skip?: number
    distinct?: LoginLogScalarFieldEnum | LoginLogScalarFieldEnum[]
  }

  /**
   * LoginLog create
   */
  export type LoginLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginLog.
     */
    data: XOR<LoginLogCreateInput, LoginLogUncheckedCreateInput>
  }

  /**
   * LoginLog createMany
   */
  export type LoginLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginLogs.
     */
    data: LoginLogCreateManyInput | LoginLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginLog createManyAndReturn
   */
  export type LoginLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * The data used to create many LoginLogs.
     */
    data: LoginLogCreateManyInput | LoginLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginLog update
   */
  export type LoginLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginLog.
     */
    data: XOR<LoginLogUpdateInput, LoginLogUncheckedUpdateInput>
    /**
     * Choose, which LoginLog to update.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog updateMany
   */
  export type LoginLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginLogs.
     */
    data: XOR<LoginLogUpdateManyMutationInput, LoginLogUncheckedUpdateManyInput>
    /**
     * Filter which LoginLogs to update
     */
    where?: LoginLogWhereInput
    /**
     * Limit how many LoginLogs to update.
     */
    limit?: number
  }

  /**
   * LoginLog updateManyAndReturn
   */
  export type LoginLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * The data used to update LoginLogs.
     */
    data: XOR<LoginLogUpdateManyMutationInput, LoginLogUncheckedUpdateManyInput>
    /**
     * Filter which LoginLogs to update
     */
    where?: LoginLogWhereInput
    /**
     * Limit how many LoginLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginLog upsert
   */
  export type LoginLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginLog to update in case it exists.
     */
    where: LoginLogWhereUniqueInput
    /**
     * In case the LoginLog found by the `where` argument doesn't exist, create a new LoginLog with this data.
     */
    create: XOR<LoginLogCreateInput, LoginLogUncheckedCreateInput>
    /**
     * In case the LoginLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginLogUpdateInput, LoginLogUncheckedUpdateInput>
  }

  /**
   * LoginLog delete
   */
  export type LoginLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
    /**
     * Filter which LoginLog to delete.
     */
    where: LoginLogWhereUniqueInput
  }

  /**
   * LoginLog deleteMany
   */
  export type LoginLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginLogs to delete
     */
    where?: LoginLogWhereInput
    /**
     * Limit how many LoginLogs to delete.
     */
    limit?: number
  }

  /**
   * LoginLog without action
   */
  export type LoginLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginLog
     */
    select?: LoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginLog
     */
    omit?: LoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    avatarId: 'avatarId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StaffProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    position: 'position',
    identityCardNumber: 'identityCardNumber',
    gender: 'gender',
    birthDate: 'birthDate',
    address: 'address',
    managedBuildingId: 'managedBuildingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffProfileScalarFieldEnum = (typeof StaffProfileScalarFieldEnum)[keyof typeof StaffProfileScalarFieldEnum]


  export const StudentProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentId: 'studentId',
    fullName: 'fullName',
    gender: 'gender',
    birthDate: 'birthDate',
    identityCardNumber: 'identityCardNumber',
    ethnicity: 'ethnicity',
    religion: 'religion',
    priorityObject: 'priorityObject',
    phoneNumber: 'phoneNumber',
    personalEmail: 'personalEmail',
    faculty: 'faculty',
    courseYear: 'courseYear',
    className: 'className',
    permanentProvince: 'permanentProvince',
    permanentDistrict: 'permanentDistrict',
    permanentAddress: 'permanentAddress',
    status: 'status',
    startDate: 'startDate',
    checkInDate: 'checkInDate',
    checkOutDate: 'checkOutDate',
    contractEndDate: 'contractEndDate',
    fatherName: 'fatherName',
    fatherDobYear: 'fatherDobYear',
    fatherPhone: 'fatherPhone',
    fatherAddress: 'fatherAddress',
    motherName: 'motherName',
    motherDobYear: 'motherDobYear',
    motherPhone: 'motherPhone',
    motherAddress: 'motherAddress',
    emergencyContactRelation: 'emergencyContactRelation',
    emergencyContactPhone: 'emergencyContactPhone',
    emergencyContactAddress: 'emergencyContactAddress',
    roomId: 'roomId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentProfileScalarFieldEnum = (typeof StudentProfileScalarFieldEnum)[keyof typeof StudentProfileScalarFieldEnum]


  export const BuildingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    buildingId: 'buildingId',
    number: 'number',
    type: 'type',
    capacity: 'capacity',
    actualOccupancy: 'actualOccupancy',
    floor: 'floor',
    status: 'status',
    description: 'description',
    roomFee: 'roomFee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const RoomAmenityScalarFieldEnum: {
    roomId: 'roomId',
    amenityId: 'amenityId',
    quantity: 'quantity',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomAmenityScalarFieldEnum = (typeof RoomAmenityScalarFieldEnum)[keyof typeof RoomAmenityScalarFieldEnum]


  export const FeeRateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    feeType: 'feeType',
    vehicleType: 'vehicleType',
    unitPrice: 'unitPrice',
    unit: 'unit',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeRateScalarFieldEnum = (typeof FeeRateScalarFieldEnum)[keyof typeof FeeRateScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    studentProfileId: 'studentProfileId',
    roomId: 'roomId',
    billingMonth: 'billingMonth',
    billingYear: 'billingYear',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paymentDeadline: 'paymentDeadline',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    type: 'type',
    description: 'description',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    studentProfileId: 'studentProfileId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    transactionCode: 'transactionCode',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const UtilityMeterReadingScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    type: 'type',
    readingDate: 'readingDate',
    indexValue: 'indexValue',
    billingMonth: 'billingMonth',
    billingYear: 'billingYear',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UtilityMeterReadingScalarFieldEnum = (typeof UtilityMeterReadingScalarFieldEnum)[keyof typeof UtilityMeterReadingScalarFieldEnum]


  export const MaintenanceScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    reportedById: 'reportedById',
    issue: 'issue',
    reportDate: 'reportDate',
    status: 'status',
    assignedToId: 'assignedToId',
    completedDate: 'completedDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


  export const RoomTransferScalarFieldEnum: {
    id: 'id',
    studentProfileId: 'studentProfileId',
    fromRoomId: 'fromRoomId',
    toRoomId: 'toRoomId',
    transferDate: 'transferDate',
    reason: 'reason',
    adminNotes: 'adminNotes',
    approvedById: 'approvedById',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomTransferScalarFieldEnum = (typeof RoomTransferScalarFieldEnum)[keyof typeof RoomTransferScalarFieldEnum]


  export const VehicleRegistrationScalarFieldEnum: {
    id: 'id',
    studentProfileId: 'studentProfileId',
    vehicleType: 'vehicleType',
    licensePlate: 'licensePlate',
    brand: 'brand',
    model: 'model',
    color: 'color',
    parkingCardNo: 'parkingCardNo',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleRegistrationScalarFieldEnum = (typeof VehicleRegistrationScalarFieldEnum)[keyof typeof VehicleRegistrationScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    path: 'path',
    mimeType: 'mimeType',
    size: 'size',
    mediaType: 'mediaType',
    uploadedAt: 'uploadedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const LoginLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    location: 'location'
  };

  export type LoginLogScalarFieldEnum = (typeof LoginLogScalarFieldEnum)[keyof typeof LoginLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'StudentStatus'
   */
  export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus'>
    


  /**
   * Reference to a field of type 'StudentStatus[]'
   */
  export type ListEnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus[]'>
    


  /**
   * Reference to a field of type 'RoomType'
   */
  export type EnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType'>
    


  /**
   * Reference to a field of type 'RoomType[]'
   */
  export type ListEnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType[]'>
    


  /**
   * Reference to a field of type 'RoomStatus'
   */
  export type EnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus'>
    


  /**
   * Reference to a field of type 'RoomStatus[]'
   */
  export type ListEnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'FeeType'
   */
  export type EnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType'>
    


  /**
   * Reference to a field of type 'FeeType[]'
   */
  export type ListEnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType[]'>
    


  /**
   * Reference to a field of type 'VehicleType'
   */
  export type EnumVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleType'>
    


  /**
   * Reference to a field of type 'VehicleType[]'
   */
  export type ListEnumVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'UtilityType'
   */
  export type EnumUtilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UtilityType'>
    


  /**
   * Reference to a field of type 'UtilityType[]'
   */
  export type ListEnumUtilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UtilityType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus'
   */
  export type EnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus[]'
   */
  export type ListEnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarId?: IntNullableFilter<"User"> | number | null
    avatar?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    studentProfile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    loginLogs?: LoginLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    avatarId?: SortOrderInput | SortOrder
    avatar?: MediaOrderByWithRelationInput
    staffProfile?: StaffProfileOrderByWithRelationInput
    studentProfile?: StudentProfileOrderByWithRelationInput
    loginLogs?: LoginLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarId?: IntNullableFilter<"User"> | number | null
    avatar?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    studentProfile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    loginLogs?: LoginLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    avatarId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    avatarId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type StaffProfileWhereInput = {
    AND?: StaffProfileWhereInput | StaffProfileWhereInput[]
    OR?: StaffProfileWhereInput[]
    NOT?: StaffProfileWhereInput | StaffProfileWhereInput[]
    id?: IntFilter<"StaffProfile"> | number
    userId?: IntFilter<"StaffProfile"> | number
    fullName?: StringFilter<"StaffProfile"> | string
    phoneNumber?: StringNullableFilter<"StaffProfile"> | string | null
    position?: StringNullableFilter<"StaffProfile"> | string | null
    identityCardNumber?: StringNullableFilter<"StaffProfile"> | string | null
    gender?: EnumGenderNullableFilter<"StaffProfile"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"StaffProfile"> | Date | string | null
    address?: StringNullableFilter<"StaffProfile"> | string | null
    managedBuildingId?: IntNullableFilter<"StaffProfile"> | number | null
    createdAt?: DateTimeFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StaffProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    managedBuilding?: XOR<BuildingNullableScalarRelationFilter, BuildingWhereInput> | null
    assignedMaintenances?: MaintenanceListRelationFilter
    approvedTransfers?: RoomTransferListRelationFilter
  }

  export type StaffProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    identityCardNumber?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    managedBuildingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    managedBuilding?: BuildingOrderByWithRelationInput
    assignedMaintenances?: MaintenanceOrderByRelationAggregateInput
    approvedTransfers?: RoomTransferOrderByRelationAggregateInput
  }

  export type StaffProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    identityCardNumber?: string
    AND?: StaffProfileWhereInput | StaffProfileWhereInput[]
    OR?: StaffProfileWhereInput[]
    NOT?: StaffProfileWhereInput | StaffProfileWhereInput[]
    fullName?: StringFilter<"StaffProfile"> | string
    phoneNumber?: StringNullableFilter<"StaffProfile"> | string | null
    position?: StringNullableFilter<"StaffProfile"> | string | null
    gender?: EnumGenderNullableFilter<"StaffProfile"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"StaffProfile"> | Date | string | null
    address?: StringNullableFilter<"StaffProfile"> | string | null
    managedBuildingId?: IntNullableFilter<"StaffProfile"> | number | null
    createdAt?: DateTimeFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StaffProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    managedBuilding?: XOR<BuildingNullableScalarRelationFilter, BuildingWhereInput> | null
    assignedMaintenances?: MaintenanceListRelationFilter
    approvedTransfers?: RoomTransferListRelationFilter
  }, "id" | "userId" | "identityCardNumber">

  export type StaffProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    identityCardNumber?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    managedBuildingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffProfileCountOrderByAggregateInput
    _avg?: StaffProfileAvgOrderByAggregateInput
    _max?: StaffProfileMaxOrderByAggregateInput
    _min?: StaffProfileMinOrderByAggregateInput
    _sum?: StaffProfileSumOrderByAggregateInput
  }

  export type StaffProfileScalarWhereWithAggregatesInput = {
    AND?: StaffProfileScalarWhereWithAggregatesInput | StaffProfileScalarWhereWithAggregatesInput[]
    OR?: StaffProfileScalarWhereWithAggregatesInput[]
    NOT?: StaffProfileScalarWhereWithAggregatesInput | StaffProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StaffProfile"> | number
    userId?: IntWithAggregatesFilter<"StaffProfile"> | number
    fullName?: StringWithAggregatesFilter<"StaffProfile"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    position?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    identityCardNumber?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"StaffProfile"> | $Enums.Gender | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"StaffProfile"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    managedBuildingId?: IntNullableWithAggregatesFilter<"StaffProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffProfile"> | Date | string
  }

  export type StudentProfileWhereInput = {
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    id?: IntFilter<"StudentProfile"> | number
    userId?: IntFilter<"StudentProfile"> | number
    studentId?: StringFilter<"StudentProfile"> | string
    fullName?: StringFilter<"StudentProfile"> | string
    gender?: EnumGenderFilter<"StudentProfile"> | $Enums.Gender
    birthDate?: DateTimeFilter<"StudentProfile"> | Date | string
    identityCardNumber?: StringFilter<"StudentProfile"> | string
    ethnicity?: StringNullableFilter<"StudentProfile"> | string | null
    religion?: StringNullableFilter<"StudentProfile"> | string | null
    priorityObject?: StringNullableFilter<"StudentProfile"> | string | null
    phoneNumber?: StringFilter<"StudentProfile"> | string
    personalEmail?: StringNullableFilter<"StudentProfile"> | string | null
    faculty?: StringFilter<"StudentProfile"> | string
    courseYear?: IntFilter<"StudentProfile"> | number
    className?: StringNullableFilter<"StudentProfile"> | string | null
    permanentProvince?: StringNullableFilter<"StudentProfile"> | string | null
    permanentDistrict?: StringNullableFilter<"StudentProfile"> | string | null
    permanentAddress?: StringNullableFilter<"StudentProfile"> | string | null
    status?: EnumStudentStatusFilter<"StudentProfile"> | $Enums.StudentStatus
    startDate?: DateTimeFilter<"StudentProfile"> | Date | string
    checkInDate?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    checkOutDate?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    contractEndDate?: DateTimeFilter<"StudentProfile"> | Date | string
    fatherName?: StringNullableFilter<"StudentProfile"> | string | null
    fatherDobYear?: IntNullableFilter<"StudentProfile"> | number | null
    fatherPhone?: StringNullableFilter<"StudentProfile"> | string | null
    fatherAddress?: StringNullableFilter<"StudentProfile"> | string | null
    motherName?: StringNullableFilter<"StudentProfile"> | string | null
    motherDobYear?: IntNullableFilter<"StudentProfile"> | number | null
    motherPhone?: StringNullableFilter<"StudentProfile"> | string | null
    motherAddress?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactRelation?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactPhone?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactAddress?: StringNullableFilter<"StudentProfile"> | string | null
    roomId?: IntNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    roomTransfers?: RoomTransferListRelationFilter
    reportedMaintenances?: MaintenanceListRelationFilter
    vehicleRegistrations?: VehicleRegistrationListRelationFilter
  }

  export type StudentProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    identityCardNumber?: SortOrder
    ethnicity?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    priorityObject?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    personalEmail?: SortOrderInput | SortOrder
    faculty?: SortOrder
    courseYear?: SortOrder
    className?: SortOrderInput | SortOrder
    permanentProvince?: SortOrderInput | SortOrder
    permanentDistrict?: SortOrderInput | SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    checkInDate?: SortOrderInput | SortOrder
    checkOutDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrder
    fatherName?: SortOrderInput | SortOrder
    fatherDobYear?: SortOrderInput | SortOrder
    fatherPhone?: SortOrderInput | SortOrder
    fatherAddress?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    motherDobYear?: SortOrderInput | SortOrder
    motherPhone?: SortOrderInput | SortOrder
    motherAddress?: SortOrderInput | SortOrder
    emergencyContactRelation?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactAddress?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    roomTransfers?: RoomTransferOrderByRelationAggregateInput
    reportedMaintenances?: MaintenanceOrderByRelationAggregateInput
    vehicleRegistrations?: VehicleRegistrationOrderByRelationAggregateInput
  }

  export type StudentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    studentId?: string
    identityCardNumber?: string
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    fullName?: StringFilter<"StudentProfile"> | string
    gender?: EnumGenderFilter<"StudentProfile"> | $Enums.Gender
    birthDate?: DateTimeFilter<"StudentProfile"> | Date | string
    ethnicity?: StringNullableFilter<"StudentProfile"> | string | null
    religion?: StringNullableFilter<"StudentProfile"> | string | null
    priorityObject?: StringNullableFilter<"StudentProfile"> | string | null
    phoneNumber?: StringFilter<"StudentProfile"> | string
    personalEmail?: StringNullableFilter<"StudentProfile"> | string | null
    faculty?: StringFilter<"StudentProfile"> | string
    courseYear?: IntFilter<"StudentProfile"> | number
    className?: StringNullableFilter<"StudentProfile"> | string | null
    permanentProvince?: StringNullableFilter<"StudentProfile"> | string | null
    permanentDistrict?: StringNullableFilter<"StudentProfile"> | string | null
    permanentAddress?: StringNullableFilter<"StudentProfile"> | string | null
    status?: EnumStudentStatusFilter<"StudentProfile"> | $Enums.StudentStatus
    startDate?: DateTimeFilter<"StudentProfile"> | Date | string
    checkInDate?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    checkOutDate?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    contractEndDate?: DateTimeFilter<"StudentProfile"> | Date | string
    fatherName?: StringNullableFilter<"StudentProfile"> | string | null
    fatherDobYear?: IntNullableFilter<"StudentProfile"> | number | null
    fatherPhone?: StringNullableFilter<"StudentProfile"> | string | null
    fatherAddress?: StringNullableFilter<"StudentProfile"> | string | null
    motherName?: StringNullableFilter<"StudentProfile"> | string | null
    motherDobYear?: IntNullableFilter<"StudentProfile"> | number | null
    motherPhone?: StringNullableFilter<"StudentProfile"> | string | null
    motherAddress?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactRelation?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactPhone?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactAddress?: StringNullableFilter<"StudentProfile"> | string | null
    roomId?: IntNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    roomTransfers?: RoomTransferListRelationFilter
    reportedMaintenances?: MaintenanceListRelationFilter
    vehicleRegistrations?: VehicleRegistrationListRelationFilter
  }, "id" | "userId" | "studentId" | "identityCardNumber">

  export type StudentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    identityCardNumber?: SortOrder
    ethnicity?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    priorityObject?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    personalEmail?: SortOrderInput | SortOrder
    faculty?: SortOrder
    courseYear?: SortOrder
    className?: SortOrderInput | SortOrder
    permanentProvince?: SortOrderInput | SortOrder
    permanentDistrict?: SortOrderInput | SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    checkInDate?: SortOrderInput | SortOrder
    checkOutDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrder
    fatherName?: SortOrderInput | SortOrder
    fatherDobYear?: SortOrderInput | SortOrder
    fatherPhone?: SortOrderInput | SortOrder
    fatherAddress?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    motherDobYear?: SortOrderInput | SortOrder
    motherPhone?: SortOrderInput | SortOrder
    motherAddress?: SortOrderInput | SortOrder
    emergencyContactRelation?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactAddress?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentProfileCountOrderByAggregateInput
    _avg?: StudentProfileAvgOrderByAggregateInput
    _max?: StudentProfileMaxOrderByAggregateInput
    _min?: StudentProfileMinOrderByAggregateInput
    _sum?: StudentProfileSumOrderByAggregateInput
  }

  export type StudentProfileScalarWhereWithAggregatesInput = {
    AND?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    OR?: StudentProfileScalarWhereWithAggregatesInput[]
    NOT?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentProfile"> | number
    userId?: IntWithAggregatesFilter<"StudentProfile"> | number
    studentId?: StringWithAggregatesFilter<"StudentProfile"> | string
    fullName?: StringWithAggregatesFilter<"StudentProfile"> | string
    gender?: EnumGenderWithAggregatesFilter<"StudentProfile"> | $Enums.Gender
    birthDate?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    identityCardNumber?: StringWithAggregatesFilter<"StudentProfile"> | string
    ethnicity?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    religion?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    priorityObject?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"StudentProfile"> | string
    personalEmail?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    faculty?: StringWithAggregatesFilter<"StudentProfile"> | string
    courseYear?: IntWithAggregatesFilter<"StudentProfile"> | number
    className?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    permanentProvince?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    permanentDistrict?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    permanentAddress?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    status?: EnumStudentStatusWithAggregatesFilter<"StudentProfile"> | $Enums.StudentStatus
    startDate?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    checkInDate?: DateTimeNullableWithAggregatesFilter<"StudentProfile"> | Date | string | null
    checkOutDate?: DateTimeNullableWithAggregatesFilter<"StudentProfile"> | Date | string | null
    contractEndDate?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    fatherName?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    fatherDobYear?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    fatherPhone?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    fatherAddress?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    motherName?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    motherDobYear?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    motherPhone?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    motherAddress?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    emergencyContactRelation?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    emergencyContactAddress?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    roomId?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
  }

  export type BuildingWhereInput = {
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    id?: IntFilter<"Building"> | number
    name?: StringFilter<"Building"> | string
    address?: StringNullableFilter<"Building"> | string | null
    description?: StringNullableFilter<"Building"> | string | null
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    images?: MediaListRelationFilter
    rooms?: RoomListRelationFilter
    staff?: StaffProfileListRelationFilter
  }

  export type BuildingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: MediaOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    staff?: StaffProfileOrderByRelationAggregateInput
  }

  export type BuildingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    address?: StringNullableFilter<"Building"> | string | null
    description?: StringNullableFilter<"Building"> | string | null
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    images?: MediaListRelationFilter
    rooms?: RoomListRelationFilter
    staff?: StaffProfileListRelationFilter
  }, "id" | "name">

  export type BuildingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuildingCountOrderByAggregateInput
    _avg?: BuildingAvgOrderByAggregateInput
    _max?: BuildingMaxOrderByAggregateInput
    _min?: BuildingMinOrderByAggregateInput
    _sum?: BuildingSumOrderByAggregateInput
  }

  export type BuildingScalarWhereWithAggregatesInput = {
    AND?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    OR?: BuildingScalarWhereWithAggregatesInput[]
    NOT?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Building"> | number
    name?: StringWithAggregatesFilter<"Building"> | string
    address?: StringNullableWithAggregatesFilter<"Building"> | string | null
    description?: StringNullableWithAggregatesFilter<"Building"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    buildingId?: IntFilter<"Room"> | number
    number?: StringFilter<"Room"> | string
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    capacity?: IntFilter<"Room"> | number
    actualOccupancy?: IntFilter<"Room"> | number
    floor?: IntFilter<"Room"> | number
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    description?: StringNullableFilter<"Room"> | string | null
    roomFee?: DecimalFilter<"Room"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    building?: XOR<BuildingScalarRelationFilter, BuildingWhereInput>
    images?: MediaListRelationFilter
    residents?: StudentProfileListRelationFilter
    amenities?: RoomAmenityListRelationFilter
    meterReadings?: UtilityMeterReadingListRelationFilter
    invoices?: InvoiceListRelationFilter
    maintenances?: MaintenanceListRelationFilter
    fromTransfers?: RoomTransferListRelationFilter
    toTransfers?: RoomTransferListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    buildingId?: SortOrder
    number?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    roomFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    building?: BuildingOrderByWithRelationInput
    images?: MediaOrderByRelationAggregateInput
    residents?: StudentProfileOrderByRelationAggregateInput
    amenities?: RoomAmenityOrderByRelationAggregateInput
    meterReadings?: UtilityMeterReadingOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    maintenances?: MaintenanceOrderByRelationAggregateInput
    fromTransfers?: RoomTransferOrderByRelationAggregateInput
    toTransfers?: RoomTransferOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    buildingId_number?: RoomBuildingIdNumberCompoundUniqueInput
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    buildingId?: IntFilter<"Room"> | number
    number?: StringFilter<"Room"> | string
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    capacity?: IntFilter<"Room"> | number
    actualOccupancy?: IntFilter<"Room"> | number
    floor?: IntFilter<"Room"> | number
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    description?: StringNullableFilter<"Room"> | string | null
    roomFee?: DecimalFilter<"Room"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    building?: XOR<BuildingScalarRelationFilter, BuildingWhereInput>
    images?: MediaListRelationFilter
    residents?: StudentProfileListRelationFilter
    amenities?: RoomAmenityListRelationFilter
    meterReadings?: UtilityMeterReadingListRelationFilter
    invoices?: InvoiceListRelationFilter
    maintenances?: MaintenanceListRelationFilter
    fromTransfers?: RoomTransferListRelationFilter
    toTransfers?: RoomTransferListRelationFilter
  }, "id" | "buildingId_number">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    buildingId?: SortOrder
    number?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    roomFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    buildingId?: IntWithAggregatesFilter<"Room"> | number
    number?: StringWithAggregatesFilter<"Room"> | string
    type?: EnumRoomTypeWithAggregatesFilter<"Room"> | $Enums.RoomType
    capacity?: IntWithAggregatesFilter<"Room"> | number
    actualOccupancy?: IntWithAggregatesFilter<"Room"> | number
    floor?: IntWithAggregatesFilter<"Room"> | number
    status?: EnumRoomStatusWithAggregatesFilter<"Room"> | $Enums.RoomStatus
    description?: StringNullableWithAggregatesFilter<"Room"> | string | null
    roomFee?: DecimalWithAggregatesFilter<"Room"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    url?: StringNullableFilter<"Amenity"> | string | null
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
    rooms?: RoomAmenityListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rooms?: RoomAmenityOrderByRelationAggregateInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    description?: StringNullableFilter<"Amenity"> | string | null
    url?: StringNullableFilter<"Amenity"> | string | null
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
    rooms?: RoomAmenityListRelationFilter
  }, "id" | "name">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _avg?: AmenityAvgOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
    _sum?: AmenitySumOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Amenity"> | number
    name?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    url?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type RoomAmenityWhereInput = {
    AND?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    OR?: RoomAmenityWhereInput[]
    NOT?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    roomId?: IntFilter<"RoomAmenity"> | number
    amenityId?: IntFilter<"RoomAmenity"> | number
    quantity?: IntFilter<"RoomAmenity"> | number
    notes?: StringNullableFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }

  export type RoomAmenityOrderByWithRelationInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
    amenity?: AmenityOrderByWithRelationInput
  }

  export type RoomAmenityWhereUniqueInput = Prisma.AtLeast<{
    roomId_amenityId?: RoomAmenityRoomIdAmenityIdCompoundUniqueInput
    AND?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    OR?: RoomAmenityWhereInput[]
    NOT?: RoomAmenityWhereInput | RoomAmenityWhereInput[]
    roomId?: IntFilter<"RoomAmenity"> | number
    amenityId?: IntFilter<"RoomAmenity"> | number
    quantity?: IntFilter<"RoomAmenity"> | number
    notes?: StringNullableFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }, "roomId_amenityId">

  export type RoomAmenityOrderByWithAggregationInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomAmenityCountOrderByAggregateInput
    _avg?: RoomAmenityAvgOrderByAggregateInput
    _max?: RoomAmenityMaxOrderByAggregateInput
    _min?: RoomAmenityMinOrderByAggregateInput
    _sum?: RoomAmenitySumOrderByAggregateInput
  }

  export type RoomAmenityScalarWhereWithAggregatesInput = {
    AND?: RoomAmenityScalarWhereWithAggregatesInput | RoomAmenityScalarWhereWithAggregatesInput[]
    OR?: RoomAmenityScalarWhereWithAggregatesInput[]
    NOT?: RoomAmenityScalarWhereWithAggregatesInput | RoomAmenityScalarWhereWithAggregatesInput[]
    roomId?: IntWithAggregatesFilter<"RoomAmenity"> | number
    amenityId?: IntWithAggregatesFilter<"RoomAmenity"> | number
    quantity?: IntWithAggregatesFilter<"RoomAmenity"> | number
    notes?: StringNullableWithAggregatesFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomAmenity"> | Date | string
  }

  export type FeeRateWhereInput = {
    AND?: FeeRateWhereInput | FeeRateWhereInput[]
    OR?: FeeRateWhereInput[]
    NOT?: FeeRateWhereInput | FeeRateWhereInput[]
    id?: IntFilter<"FeeRate"> | number
    name?: StringFilter<"FeeRate"> | string
    feeType?: EnumFeeTypeFilter<"FeeRate"> | $Enums.FeeType
    vehicleType?: EnumVehicleTypeNullableFilter<"FeeRate"> | $Enums.VehicleType | null
    unitPrice?: DecimalFilter<"FeeRate"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"FeeRate"> | string | null
    effectiveFrom?: DateTimeFilter<"FeeRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"FeeRate"> | Date | string | null
    description?: StringNullableFilter<"FeeRate"> | string | null
    isActive?: BoolFilter<"FeeRate"> | boolean
    createdAt?: DateTimeFilter<"FeeRate"> | Date | string
    updatedAt?: DateTimeFilter<"FeeRate"> | Date | string
  }

  export type FeeRateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    feeType?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    unit?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeeRateWhereInput | FeeRateWhereInput[]
    OR?: FeeRateWhereInput[]
    NOT?: FeeRateWhereInput | FeeRateWhereInput[]
    name?: StringFilter<"FeeRate"> | string
    feeType?: EnumFeeTypeFilter<"FeeRate"> | $Enums.FeeType
    vehicleType?: EnumVehicleTypeNullableFilter<"FeeRate"> | $Enums.VehicleType | null
    unitPrice?: DecimalFilter<"FeeRate"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"FeeRate"> | string | null
    effectiveFrom?: DateTimeFilter<"FeeRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"FeeRate"> | Date | string | null
    description?: StringNullableFilter<"FeeRate"> | string | null
    isActive?: BoolFilter<"FeeRate"> | boolean
    createdAt?: DateTimeFilter<"FeeRate"> | Date | string
    updatedAt?: DateTimeFilter<"FeeRate"> | Date | string
  }, "id">

  export type FeeRateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    feeType?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    unit?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeRateCountOrderByAggregateInput
    _avg?: FeeRateAvgOrderByAggregateInput
    _max?: FeeRateMaxOrderByAggregateInput
    _min?: FeeRateMinOrderByAggregateInput
    _sum?: FeeRateSumOrderByAggregateInput
  }

  export type FeeRateScalarWhereWithAggregatesInput = {
    AND?: FeeRateScalarWhereWithAggregatesInput | FeeRateScalarWhereWithAggregatesInput[]
    OR?: FeeRateScalarWhereWithAggregatesInput[]
    NOT?: FeeRateScalarWhereWithAggregatesInput | FeeRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeeRate"> | number
    name?: StringWithAggregatesFilter<"FeeRate"> | string
    feeType?: EnumFeeTypeWithAggregatesFilter<"FeeRate"> | $Enums.FeeType
    vehicleType?: EnumVehicleTypeNullableWithAggregatesFilter<"FeeRate"> | $Enums.VehicleType | null
    unitPrice?: DecimalWithAggregatesFilter<"FeeRate"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableWithAggregatesFilter<"FeeRate"> | string | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"FeeRate"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"FeeRate"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"FeeRate"> | string | null
    isActive?: BoolWithAggregatesFilter<"FeeRate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeeRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeRate"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    studentProfileId?: IntNullableFilter<"Invoice"> | number | null
    roomId?: IntNullableFilter<"Invoice"> | number | null
    billingMonth?: IntFilter<"Invoice"> | number
    billingYear?: IntFilter<"Invoice"> | number
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paymentDeadline?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    studentProfile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    studentProfileId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paymentDeadline?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfile?: StudentProfileOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    studentProfileId?: IntNullableFilter<"Invoice"> | number | null
    roomId?: IntNullableFilter<"Invoice"> | number | null
    billingMonth?: IntFilter<"Invoice"> | number
    billingYear?: IntFilter<"Invoice"> | number
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paymentDeadline?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    studentProfile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    studentProfileId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paymentDeadline?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    studentProfileId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    roomId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    billingMonth?: IntWithAggregatesFilter<"Invoice"> | number
    billingYear?: IntWithAggregatesFilter<"Invoice"> | number
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paymentDeadline?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    type?: EnumPaymentTypeFilter<"InvoiceItem"> | $Enums.PaymentType
    description?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: IntFilter<"InvoiceItem"> | number
    type?: EnumPaymentTypeFilter<"InvoiceItem"> | $Enums.PaymentType
    description?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"InvoiceItem"> | number
    type?: EnumPaymentTypeWithAggregatesFilter<"InvoiceItem"> | $Enums.PaymentType
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    amount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    studentProfileId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    transactionCode?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    studentProfile?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionCode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    studentProfile?: StudentProfileOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: IntFilter<"Payment"> | number
    studentProfileId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    transactionCode?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    studentProfile?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionCode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    invoiceId?: IntWithAggregatesFilter<"Payment"> | number
    studentProfileId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transactionCode?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UtilityMeterReadingWhereInput = {
    AND?: UtilityMeterReadingWhereInput | UtilityMeterReadingWhereInput[]
    OR?: UtilityMeterReadingWhereInput[]
    NOT?: UtilityMeterReadingWhereInput | UtilityMeterReadingWhereInput[]
    id?: IntFilter<"UtilityMeterReading"> | number
    roomId?: IntFilter<"UtilityMeterReading"> | number
    type?: EnumUtilityTypeFilter<"UtilityMeterReading"> | $Enums.UtilityType
    readingDate?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    indexValue?: FloatFilter<"UtilityMeterReading"> | number
    billingMonth?: IntFilter<"UtilityMeterReading"> | number
    billingYear?: IntFilter<"UtilityMeterReading"> | number
    notes?: StringNullableFilter<"UtilityMeterReading"> | string | null
    createdAt?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    updatedAt?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
  }

  export type UtilityMeterReadingOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    readingDate?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
  }

  export type UtilityMeterReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UtilityMeterReadingWhereInput | UtilityMeterReadingWhereInput[]
    OR?: UtilityMeterReadingWhereInput[]
    NOT?: UtilityMeterReadingWhereInput | UtilityMeterReadingWhereInput[]
    roomId?: IntFilter<"UtilityMeterReading"> | number
    type?: EnumUtilityTypeFilter<"UtilityMeterReading"> | $Enums.UtilityType
    readingDate?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    indexValue?: FloatFilter<"UtilityMeterReading"> | number
    billingMonth?: IntFilter<"UtilityMeterReading"> | number
    billingYear?: IntFilter<"UtilityMeterReading"> | number
    notes?: StringNullableFilter<"UtilityMeterReading"> | string | null
    createdAt?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    updatedAt?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
  }, "id">

  export type UtilityMeterReadingOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    readingDate?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UtilityMeterReadingCountOrderByAggregateInput
    _avg?: UtilityMeterReadingAvgOrderByAggregateInput
    _max?: UtilityMeterReadingMaxOrderByAggregateInput
    _min?: UtilityMeterReadingMinOrderByAggregateInput
    _sum?: UtilityMeterReadingSumOrderByAggregateInput
  }

  export type UtilityMeterReadingScalarWhereWithAggregatesInput = {
    AND?: UtilityMeterReadingScalarWhereWithAggregatesInput | UtilityMeterReadingScalarWhereWithAggregatesInput[]
    OR?: UtilityMeterReadingScalarWhereWithAggregatesInput[]
    NOT?: UtilityMeterReadingScalarWhereWithAggregatesInput | UtilityMeterReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UtilityMeterReading"> | number
    roomId?: IntWithAggregatesFilter<"UtilityMeterReading"> | number
    type?: EnumUtilityTypeWithAggregatesFilter<"UtilityMeterReading"> | $Enums.UtilityType
    readingDate?: DateTimeWithAggregatesFilter<"UtilityMeterReading"> | Date | string
    indexValue?: FloatWithAggregatesFilter<"UtilityMeterReading"> | number
    billingMonth?: IntWithAggregatesFilter<"UtilityMeterReading"> | number
    billingYear?: IntWithAggregatesFilter<"UtilityMeterReading"> | number
    notes?: StringNullableWithAggregatesFilter<"UtilityMeterReading"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UtilityMeterReading"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UtilityMeterReading"> | Date | string
  }

  export type MaintenanceWhereInput = {
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    id?: IntFilter<"Maintenance"> | number
    roomId?: IntFilter<"Maintenance"> | number
    reportedById?: IntFilter<"Maintenance"> | number
    issue?: StringFilter<"Maintenance"> | string
    reportDate?: DateTimeFilter<"Maintenance"> | Date | string
    status?: EnumMaintenanceStatusFilter<"Maintenance"> | $Enums.MaintenanceStatus
    assignedToId?: IntNullableFilter<"Maintenance"> | number | null
    completedDate?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    notes?: StringNullableFilter<"Maintenance"> | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    reportedBy?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    assignedTo?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    images?: MediaListRelationFilter
  }

  export type MaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    issue?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
    reportedBy?: StudentProfileOrderByWithRelationInput
    assignedTo?: StaffProfileOrderByWithRelationInput
    images?: MediaOrderByRelationAggregateInput
  }

  export type MaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    roomId?: IntFilter<"Maintenance"> | number
    reportedById?: IntFilter<"Maintenance"> | number
    issue?: StringFilter<"Maintenance"> | string
    reportDate?: DateTimeFilter<"Maintenance"> | Date | string
    status?: EnumMaintenanceStatusFilter<"Maintenance"> | $Enums.MaintenanceStatus
    assignedToId?: IntNullableFilter<"Maintenance"> | number | null
    completedDate?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    notes?: StringNullableFilter<"Maintenance"> | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    reportedBy?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    assignedTo?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    images?: MediaListRelationFilter
  }, "id">

  export type MaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    issue?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceCountOrderByAggregateInput
    _avg?: MaintenanceAvgOrderByAggregateInput
    _max?: MaintenanceMaxOrderByAggregateInput
    _min?: MaintenanceMinOrderByAggregateInput
    _sum?: MaintenanceSumOrderByAggregateInput
  }

  export type MaintenanceScalarWhereWithAggregatesInput = {
    AND?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    OR?: MaintenanceScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Maintenance"> | number
    roomId?: IntWithAggregatesFilter<"Maintenance"> | number
    reportedById?: IntWithAggregatesFilter<"Maintenance"> | number
    issue?: StringWithAggregatesFilter<"Maintenance"> | string
    reportDate?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    status?: EnumMaintenanceStatusWithAggregatesFilter<"Maintenance"> | $Enums.MaintenanceStatus
    assignedToId?: IntNullableWithAggregatesFilter<"Maintenance"> | number | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Maintenance"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
  }

  export type RoomTransferWhereInput = {
    AND?: RoomTransferWhereInput | RoomTransferWhereInput[]
    OR?: RoomTransferWhereInput[]
    NOT?: RoomTransferWhereInput | RoomTransferWhereInput[]
    id?: IntFilter<"RoomTransfer"> | number
    studentProfileId?: IntFilter<"RoomTransfer"> | number
    fromRoomId?: IntNullableFilter<"RoomTransfer"> | number | null
    toRoomId?: IntFilter<"RoomTransfer"> | number
    transferDate?: DateTimeFilter<"RoomTransfer"> | Date | string
    reason?: StringNullableFilter<"RoomTransfer"> | string | null
    adminNotes?: StringNullableFilter<"RoomTransfer"> | string | null
    approvedById?: IntNullableFilter<"RoomTransfer"> | number | null
    status?: EnumTransferStatusFilter<"RoomTransfer"> | $Enums.TransferStatus
    createdAt?: DateTimeFilter<"RoomTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"RoomTransfer"> | Date | string
    studentProfile?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    fromRoom?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    toRoom?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    approvedBy?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }

  export type RoomTransferOrderByWithRelationInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrderInput | SortOrder
    toRoomId?: SortOrder
    transferDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfile?: StudentProfileOrderByWithRelationInput
    fromRoom?: RoomOrderByWithRelationInput
    toRoom?: RoomOrderByWithRelationInput
    approvedBy?: StaffProfileOrderByWithRelationInput
  }

  export type RoomTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomTransferWhereInput | RoomTransferWhereInput[]
    OR?: RoomTransferWhereInput[]
    NOT?: RoomTransferWhereInput | RoomTransferWhereInput[]
    studentProfileId?: IntFilter<"RoomTransfer"> | number
    fromRoomId?: IntNullableFilter<"RoomTransfer"> | number | null
    toRoomId?: IntFilter<"RoomTransfer"> | number
    transferDate?: DateTimeFilter<"RoomTransfer"> | Date | string
    reason?: StringNullableFilter<"RoomTransfer"> | string | null
    adminNotes?: StringNullableFilter<"RoomTransfer"> | string | null
    approvedById?: IntNullableFilter<"RoomTransfer"> | number | null
    status?: EnumTransferStatusFilter<"RoomTransfer"> | $Enums.TransferStatus
    createdAt?: DateTimeFilter<"RoomTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"RoomTransfer"> | Date | string
    studentProfile?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    fromRoom?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    toRoom?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    approvedBy?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }, "id">

  export type RoomTransferOrderByWithAggregationInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrderInput | SortOrder
    toRoomId?: SortOrder
    transferDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomTransferCountOrderByAggregateInput
    _avg?: RoomTransferAvgOrderByAggregateInput
    _max?: RoomTransferMaxOrderByAggregateInput
    _min?: RoomTransferMinOrderByAggregateInput
    _sum?: RoomTransferSumOrderByAggregateInput
  }

  export type RoomTransferScalarWhereWithAggregatesInput = {
    AND?: RoomTransferScalarWhereWithAggregatesInput | RoomTransferScalarWhereWithAggregatesInput[]
    OR?: RoomTransferScalarWhereWithAggregatesInput[]
    NOT?: RoomTransferScalarWhereWithAggregatesInput | RoomTransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomTransfer"> | number
    studentProfileId?: IntWithAggregatesFilter<"RoomTransfer"> | number
    fromRoomId?: IntNullableWithAggregatesFilter<"RoomTransfer"> | number | null
    toRoomId?: IntWithAggregatesFilter<"RoomTransfer"> | number
    transferDate?: DateTimeWithAggregatesFilter<"RoomTransfer"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"RoomTransfer"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"RoomTransfer"> | string | null
    approvedById?: IntNullableWithAggregatesFilter<"RoomTransfer"> | number | null
    status?: EnumTransferStatusWithAggregatesFilter<"RoomTransfer"> | $Enums.TransferStatus
    createdAt?: DateTimeWithAggregatesFilter<"RoomTransfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomTransfer"> | Date | string
  }

  export type VehicleRegistrationWhereInput = {
    AND?: VehicleRegistrationWhereInput | VehicleRegistrationWhereInput[]
    OR?: VehicleRegistrationWhereInput[]
    NOT?: VehicleRegistrationWhereInput | VehicleRegistrationWhereInput[]
    id?: IntFilter<"VehicleRegistration"> | number
    studentProfileId?: IntFilter<"VehicleRegistration"> | number
    vehicleType?: EnumVehicleTypeFilter<"VehicleRegistration"> | $Enums.VehicleType
    licensePlate?: StringFilter<"VehicleRegistration"> | string
    brand?: StringNullableFilter<"VehicleRegistration"> | string | null
    model?: StringNullableFilter<"VehicleRegistration"> | string | null
    color?: StringNullableFilter<"VehicleRegistration"> | string | null
    parkingCardNo?: StringNullableFilter<"VehicleRegistration"> | string | null
    isActive?: BoolFilter<"VehicleRegistration"> | boolean
    startDate?: DateTimeFilter<"VehicleRegistration"> | Date | string
    endDate?: DateTimeNullableFilter<"VehicleRegistration"> | Date | string | null
    notes?: StringNullableFilter<"VehicleRegistration"> | string | null
    createdAt?: DateTimeFilter<"VehicleRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleRegistration"> | Date | string
    studentProfile?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    images?: MediaListRelationFilter
  }

  export type VehicleRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parkingCardNo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfile?: StudentProfileOrderByWithRelationInput
    images?: MediaOrderByRelationAggregateInput
  }

  export type VehicleRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parkingCardNo?: string
    AND?: VehicleRegistrationWhereInput | VehicleRegistrationWhereInput[]
    OR?: VehicleRegistrationWhereInput[]
    NOT?: VehicleRegistrationWhereInput | VehicleRegistrationWhereInput[]
    studentProfileId?: IntFilter<"VehicleRegistration"> | number
    vehicleType?: EnumVehicleTypeFilter<"VehicleRegistration"> | $Enums.VehicleType
    licensePlate?: StringFilter<"VehicleRegistration"> | string
    brand?: StringNullableFilter<"VehicleRegistration"> | string | null
    model?: StringNullableFilter<"VehicleRegistration"> | string | null
    color?: StringNullableFilter<"VehicleRegistration"> | string | null
    isActive?: BoolFilter<"VehicleRegistration"> | boolean
    startDate?: DateTimeFilter<"VehicleRegistration"> | Date | string
    endDate?: DateTimeNullableFilter<"VehicleRegistration"> | Date | string | null
    notes?: StringNullableFilter<"VehicleRegistration"> | string | null
    createdAt?: DateTimeFilter<"VehicleRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleRegistration"> | Date | string
    studentProfile?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    images?: MediaListRelationFilter
  }, "id" | "parkingCardNo">

  export type VehicleRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parkingCardNo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleRegistrationCountOrderByAggregateInput
    _avg?: VehicleRegistrationAvgOrderByAggregateInput
    _max?: VehicleRegistrationMaxOrderByAggregateInput
    _min?: VehicleRegistrationMinOrderByAggregateInput
    _sum?: VehicleRegistrationSumOrderByAggregateInput
  }

  export type VehicleRegistrationScalarWhereWithAggregatesInput = {
    AND?: VehicleRegistrationScalarWhereWithAggregatesInput | VehicleRegistrationScalarWhereWithAggregatesInput[]
    OR?: VehicleRegistrationScalarWhereWithAggregatesInput[]
    NOT?: VehicleRegistrationScalarWhereWithAggregatesInput | VehicleRegistrationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VehicleRegistration"> | number
    studentProfileId?: IntWithAggregatesFilter<"VehicleRegistration"> | number
    vehicleType?: EnumVehicleTypeWithAggregatesFilter<"VehicleRegistration"> | $Enums.VehicleType
    licensePlate?: StringWithAggregatesFilter<"VehicleRegistration"> | string
    brand?: StringNullableWithAggregatesFilter<"VehicleRegistration"> | string | null
    model?: StringNullableWithAggregatesFilter<"VehicleRegistration"> | string | null
    color?: StringNullableWithAggregatesFilter<"VehicleRegistration"> | string | null
    parkingCardNo?: StringNullableWithAggregatesFilter<"VehicleRegistration"> | string | null
    isActive?: BoolWithAggregatesFilter<"VehicleRegistration"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"VehicleRegistration"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"VehicleRegistration"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"VehicleRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VehicleRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VehicleRegistration"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: IntFilter<"Media"> | number
    filename?: StringFilter<"Media"> | string
    path?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    mediaType?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    uploadedAt?: DateTimeFilter<"Media"> | Date | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    avatarFor?: UserListRelationFilter
    roomImages?: RoomListRelationFilter
    buildingImages?: BuildingListRelationFilter
    vehicleImages?: VehicleRegistrationListRelationFilter
    maintenanceImages?: MaintenanceListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarFor?: UserOrderByRelationAggregateInput
    roomImages?: RoomOrderByRelationAggregateInput
    buildingImages?: BuildingOrderByRelationAggregateInput
    vehicleImages?: VehicleRegistrationOrderByRelationAggregateInput
    maintenanceImages?: MaintenanceOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    filename?: StringFilter<"Media"> | string
    path?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    mediaType?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    uploadedAt?: DateTimeFilter<"Media"> | Date | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    avatarFor?: UserListRelationFilter
    roomImages?: RoomListRelationFilter
    buildingImages?: BuildingListRelationFilter
    vehicleImages?: VehicleRegistrationListRelationFilter
    maintenanceImages?: MaintenanceListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Media"> | number
    filename?: StringWithAggregatesFilter<"Media"> | string
    path?: StringWithAggregatesFilter<"Media"> | string
    mimeType?: StringWithAggregatesFilter<"Media"> | string
    size?: IntWithAggregatesFilter<"Media"> | number
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Media"> | $Enums.MediaType
    uploadedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type LoginLogWhereInput = {
    AND?: LoginLogWhereInput | LoginLogWhereInput[]
    OR?: LoginLogWhereInput[]
    NOT?: LoginLogWhereInput | LoginLogWhereInput[]
    id?: IntFilter<"LoginLog"> | number
    userId?: IntFilter<"LoginLog"> | number
    timestamp?: DateTimeFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableFilter<"LoginLog"> | string | null
    userAgent?: StringNullableFilter<"LoginLog"> | string | null
    status?: StringFilter<"LoginLog"> | string
    location?: StringNullableFilter<"LoginLog"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LoginLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LoginLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LoginLogWhereInput | LoginLogWhereInput[]
    OR?: LoginLogWhereInput[]
    NOT?: LoginLogWhereInput | LoginLogWhereInput[]
    userId?: IntFilter<"LoginLog"> | number
    timestamp?: DateTimeFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableFilter<"LoginLog"> | string | null
    userAgent?: StringNullableFilter<"LoginLog"> | string | null
    status?: StringFilter<"LoginLog"> | string
    location?: StringNullableFilter<"LoginLog"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LoginLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    _count?: LoginLogCountOrderByAggregateInput
    _avg?: LoginLogAvgOrderByAggregateInput
    _max?: LoginLogMaxOrderByAggregateInput
    _min?: LoginLogMinOrderByAggregateInput
    _sum?: LoginLogSumOrderByAggregateInput
  }

  export type LoginLogScalarWhereWithAggregatesInput = {
    AND?: LoginLogScalarWhereWithAggregatesInput | LoginLogScalarWhereWithAggregatesInput[]
    OR?: LoginLogScalarWhereWithAggregatesInput[]
    NOT?: LoginLogScalarWhereWithAggregatesInput | LoginLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LoginLog"> | number
    userId?: IntWithAggregatesFilter<"LoginLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"LoginLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LoginLog"> | string | null
    status?: StringWithAggregatesFilter<"LoginLog"> | string
    location?: StringNullableWithAggregatesFilter<"LoginLog"> | string | null
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatar?: MediaCreateNestedOneWithoutAvatarForInput
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatarId?: number | null
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: MediaUpdateOneWithoutAvatarForNestedInput
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatarId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StaffProfileCreateInput = {
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    managedBuilding?: BuildingCreateNestedOneWithoutStaffInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToInput
    approvedTransfers?: RoomTransferCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileUncheckedCreateInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    managedBuildingId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToInput
    approvedTransfers?: RoomTransferUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    managedBuilding?: BuildingUpdateOneWithoutStaffNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToNestedInput
    approvedTransfers?: RoomTransferUpdateManyWithoutApprovedByNestedInput
  }

  export type StaffProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    managedBuildingId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToNestedInput
    approvedTransfers?: RoomTransferUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type StaffProfileCreateManyInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    managedBuildingId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffProfileUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    managedBuildingId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileCreateInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    room?: RoomCreateNestedOneWithoutResidentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    room?: RoomUpdateOneWithoutResidentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileCreateManyInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUpdateManyMutationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingCreateInput = {
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutBuildingImagesInput
    rooms?: RoomCreateNestedManyWithoutBuildingInput
    staff?: StaffProfileCreateNestedManyWithoutManagedBuildingInput
  }

  export type BuildingUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutBuildingImagesInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
    staff?: StaffProfileUncheckedCreateNestedManyWithoutManagedBuildingInput
  }

  export type BuildingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutBuildingImagesNestedInput
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
    staff?: StaffProfileUpdateManyWithoutManagedBuildingNestedInput
  }

  export type BuildingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutBuildingImagesNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
    staff?: StaffProfileUncheckedUpdateManyWithoutManagedBuildingNestedInput
  }

  export type BuildingCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityCreateInput = {
    name: string
    description?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityCreateInput = {
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutAmenitiesInput
    amenity: AmenityCreateNestedOneWithoutRoomsInput
  }

  export type RoomAmenityUncheckedCreateInput = {
    roomId: number
    amenityId: number
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutAmenitiesNestedInput
    amenity?: AmenityUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomAmenityUncheckedUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityCreateManyInput = {
    roomId: number
    amenityId: number
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityUncheckedUpdateManyInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeRateCreateInput = {
    name: string
    feeType: $Enums.FeeType
    vehicleType?: $Enums.VehicleType | null
    unitPrice: Decimal | DecimalJsLike | number | string
    unit?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeRateUncheckedCreateInput = {
    id?: number
    name: string
    feeType: $Enums.FeeType
    vehicleType?: $Enums.VehicleType | null
    unitPrice: Decimal | DecimalJsLike | number | string
    unit?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeRateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    feeType?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    vehicleType?: NullableEnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    feeType?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    vehicleType?: NullableEnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeRateCreateManyInput = {
    id?: number
    name: string
    feeType: $Enums.FeeType
    vehicleType?: $Enums.VehicleType | null
    unitPrice: Decimal | DecimalJsLike | number | string
    unit?: string | null
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeRateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    feeType?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    vehicleType?: NullableEnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    feeType?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    vehicleType?: NullableEnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutInvoicesInput
    room?: RoomCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    studentProfileId?: number | null
    roomId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutInvoicesNestedInput
    room?: RoomUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    studentProfileId?: number | null
    roomId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    type: $Enums.PaymentType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    type: $Enums.PaymentType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateInput = {
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    type: $Enums.PaymentType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    studentProfile: StudentProfileCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    invoiceId: number
    studentProfileId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    studentProfile?: StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    invoiceId: number
    studentProfileId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilityMeterReadingCreateInput = {
    type: $Enums.UtilityType
    readingDate: Date | string
    indexValue: number
    billingMonth: number
    billingYear: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMeterReadingsInput
  }

  export type UtilityMeterReadingUncheckedCreateInput = {
    id?: number
    roomId: number
    type: $Enums.UtilityType
    readingDate: Date | string
    indexValue: number
    billingMonth: number
    billingYear: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtilityMeterReadingUpdateInput = {
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMeterReadingsNestedInput
  }

  export type UtilityMeterReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilityMeterReadingCreateManyInput = {
    id?: number
    roomId: number
    type: $Enums.UtilityType
    readingDate: Date | string
    indexValue: number
    billingMonth: number
    billingYear: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtilityMeterReadingUpdateManyMutationInput = {
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilityMeterReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceCreateInput = {
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMaintenancesInput
    reportedBy: StudentProfileCreateNestedOneWithoutReportedMaintenancesInput
    assignedTo?: StaffProfileCreateNestedOneWithoutAssignedMaintenancesInput
    images?: MediaCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceUncheckedCreateInput = {
    id?: number
    roomId: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceUpdateInput = {
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMaintenancesNestedInput
    reportedBy?: StudentProfileUpdateOneRequiredWithoutReportedMaintenancesNestedInput
    assignedTo?: StaffProfileUpdateOneWithoutAssignedMaintenancesNestedInput
    images?: MediaUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceCreateManyInput = {
    id?: number
    roomId: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceUpdateManyMutationInput = {
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferCreateInput = {
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutRoomTransfersInput
    fromRoom?: RoomCreateNestedOneWithoutFromTransfersInput
    toRoom: RoomCreateNestedOneWithoutToTransfersInput
    approvedBy?: StaffProfileCreateNestedOneWithoutApprovedTransfersInput
  }

  export type RoomTransferUncheckedCreateInput = {
    id?: number
    studentProfileId: number
    fromRoomId?: number | null
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferUpdateInput = {
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutRoomTransfersNestedInput
    fromRoom?: RoomUpdateOneWithoutFromTransfersNestedInput
    toRoom?: RoomUpdateOneRequiredWithoutToTransfersNestedInput
    approvedBy?: StaffProfileUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type RoomTransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferCreateManyInput = {
    id?: number
    studentProfileId: number
    fromRoomId?: number | null
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferUpdateManyMutationInput = {
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleRegistrationCreateInput = {
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutVehicleRegistrationsInput
    images?: MediaCreateNestedManyWithoutVehicleImagesInput
  }

  export type VehicleRegistrationUncheckedCreateInput = {
    id?: number
    studentProfileId: number
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutVehicleImagesInput
  }

  export type VehicleRegistrationUpdateInput = {
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutVehicleRegistrationsNestedInput
    images?: MediaUpdateManyWithoutVehicleImagesNestedInput
  }

  export type VehicleRegistrationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutVehicleImagesNestedInput
  }

  export type VehicleRegistrationCreateManyInput = {
    id?: number
    studentProfileId: number
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleRegistrationUpdateManyMutationInput = {
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleRegistrationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserCreateNestedManyWithoutAvatarInput
    roomImages?: RoomCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceCreateNestedManyWithoutImagesInput
  }

  export type MediaUncheckedCreateInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserUncheckedCreateNestedManyWithoutAvatarInput
    roomImages?: RoomUncheckedCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingUncheckedCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationUncheckedCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceUncheckedCreateNestedManyWithoutImagesInput
  }

  export type MediaUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUncheckedUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUncheckedUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUncheckedUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUncheckedUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type MediaCreateManyInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginLogCreateInput = {
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    location?: string | null
    user: UserCreateNestedOneWithoutLoginLogsInput
  }

  export type LoginLogUncheckedCreateInput = {
    id?: number
    userId: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    location?: string | null
  }

  export type LoginLogUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutLoginLogsNestedInput
  }

  export type LoginLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoginLogCreateManyInput = {
    id?: number
    userId: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    location?: string | null
  }

  export type LoginLogUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoginLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type StaffProfileNullableScalarRelationFilter = {
    is?: StaffProfileWhereInput | null
    isNot?: StaffProfileWhereInput | null
  }

  export type StudentProfileNullableScalarRelationFilter = {
    is?: StudentProfileWhereInput | null
    isNot?: StudentProfileWhereInput | null
  }

  export type LoginLogListRelationFilter = {
    every?: LoginLogWhereInput
    some?: LoginLogWhereInput
    none?: LoginLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LoginLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    avatarId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    avatarId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    avatarId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BuildingNullableScalarRelationFilter = {
    is?: BuildingWhereInput | null
    isNot?: BuildingWhereInput | null
  }

  export type MaintenanceListRelationFilter = {
    every?: MaintenanceWhereInput
    some?: MaintenanceWhereInput
    none?: MaintenanceWhereInput
  }

  export type RoomTransferListRelationFilter = {
    every?: RoomTransferWhereInput
    some?: RoomTransferWhereInput
    none?: RoomTransferWhereInput
  }

  export type MaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    position?: SortOrder
    identityCardNumber?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    managedBuildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    managedBuildingId?: SortOrder
  }

  export type StaffProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    position?: SortOrder
    identityCardNumber?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    managedBuildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    position?: SortOrder
    identityCardNumber?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    managedBuildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    managedBuildingId?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type RoomNullableScalarRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type VehicleRegistrationListRelationFilter = {
    every?: VehicleRegistrationWhereInput
    some?: VehicleRegistrationWhereInput
    none?: VehicleRegistrationWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    identityCardNumber?: SortOrder
    ethnicity?: SortOrder
    religion?: SortOrder
    priorityObject?: SortOrder
    phoneNumber?: SortOrder
    personalEmail?: SortOrder
    faculty?: SortOrder
    courseYear?: SortOrder
    className?: SortOrder
    permanentProvince?: SortOrder
    permanentDistrict?: SortOrder
    permanentAddress?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    contractEndDate?: SortOrder
    fatherName?: SortOrder
    fatherDobYear?: SortOrder
    fatherPhone?: SortOrder
    fatherAddress?: SortOrder
    motherName?: SortOrder
    motherDobYear?: SortOrder
    motherPhone?: SortOrder
    motherAddress?: SortOrder
    emergencyContactRelation?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactAddress?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseYear?: SortOrder
    fatherDobYear?: SortOrder
    motherDobYear?: SortOrder
    roomId?: SortOrder
  }

  export type StudentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    identityCardNumber?: SortOrder
    ethnicity?: SortOrder
    religion?: SortOrder
    priorityObject?: SortOrder
    phoneNumber?: SortOrder
    personalEmail?: SortOrder
    faculty?: SortOrder
    courseYear?: SortOrder
    className?: SortOrder
    permanentProvince?: SortOrder
    permanentDistrict?: SortOrder
    permanentAddress?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    contractEndDate?: SortOrder
    fatherName?: SortOrder
    fatherDobYear?: SortOrder
    fatherPhone?: SortOrder
    fatherAddress?: SortOrder
    motherName?: SortOrder
    motherDobYear?: SortOrder
    motherPhone?: SortOrder
    motherAddress?: SortOrder
    emergencyContactRelation?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactAddress?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    identityCardNumber?: SortOrder
    ethnicity?: SortOrder
    religion?: SortOrder
    priorityObject?: SortOrder
    phoneNumber?: SortOrder
    personalEmail?: SortOrder
    faculty?: SortOrder
    courseYear?: SortOrder
    className?: SortOrder
    permanentProvince?: SortOrder
    permanentDistrict?: SortOrder
    permanentAddress?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    contractEndDate?: SortOrder
    fatherName?: SortOrder
    fatherDobYear?: SortOrder
    fatherPhone?: SortOrder
    fatherAddress?: SortOrder
    motherName?: SortOrder
    motherDobYear?: SortOrder
    motherPhone?: SortOrder
    motherAddress?: SortOrder
    emergencyContactRelation?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactAddress?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseYear?: SortOrder
    fatherDobYear?: SortOrder
    motherDobYear?: SortOrder
    roomId?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type StaffProfileListRelationFilter = {
    every?: StaffProfileWhereInput
    some?: StaffProfileWhereInput
    none?: StaffProfileWhereInput
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuildingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type EnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BuildingScalarRelationFilter = {
    is?: BuildingWhereInput
    isNot?: BuildingWhereInput
  }

  export type StudentProfileListRelationFilter = {
    every?: StudentProfileWhereInput
    some?: StudentProfileWhereInput
    none?: StudentProfileWhereInput
  }

  export type RoomAmenityListRelationFilter = {
    every?: RoomAmenityWhereInput
    some?: RoomAmenityWhereInput
    none?: RoomAmenityWhereInput
  }

  export type UtilityMeterReadingListRelationFilter = {
    every?: UtilityMeterReadingWhereInput
    some?: UtilityMeterReadingWhereInput
    none?: UtilityMeterReadingWhereInput
  }

  export type StudentProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UtilityMeterReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomBuildingIdNumberCompoundUniqueInput = {
    buildingId: number
    number: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    buildingId?: SortOrder
    number?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    description?: SortOrder
    roomFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    buildingId?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    roomFee?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    buildingId?: SortOrder
    number?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    description?: SortOrder
    roomFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    buildingId?: SortOrder
    number?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    description?: SortOrder
    roomFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    buildingId?: SortOrder
    capacity?: SortOrder
    actualOccupancy?: SortOrder
    floor?: SortOrder
    roomFee?: SortOrder
  }

  export type EnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type EnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type RoomAmenityRoomIdAmenityIdCompoundUniqueInput = {
    roomId: number
    amenityId: number
  }

  export type RoomAmenityCountOrderByAggregateInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAmenityAvgOrderByAggregateInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
  }

  export type RoomAmenityMaxOrderByAggregateInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAmenityMinOrderByAggregateInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAmenitySumOrderByAggregateInput = {
    roomId?: SortOrder
    amenityId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumFeeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeFilter<$PrismaModel> | $Enums.FeeType
  }

  export type EnumVehicleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVehicleTypeNullableFilter<$PrismaModel> | $Enums.VehicleType | null
  }

  export type FeeRateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    feeType?: SortOrder
    vehicleType?: SortOrder
    unitPrice?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeRateAvgOrderByAggregateInput = {
    id?: SortOrder
    unitPrice?: SortOrder
  }

  export type FeeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    feeType?: SortOrder
    vehicleType?: SortOrder
    unitPrice?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeRateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    feeType?: SortOrder
    vehicleType?: SortOrder
    unitPrice?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeRateSumOrderByAggregateInput = {
    id?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumFeeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeFilter<$PrismaModel>
  }

  export type EnumVehicleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVehicleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeNullableFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    roomId?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paymentDeadline?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    roomId?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    roomId?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paymentDeadline?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    roomId?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paymentDeadline?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    roomId?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type StudentProfileScalarRelationFilter = {
    is?: StudentProfileWhereInput
    isNot?: StudentProfileWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    transactionCode?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    transactionCode?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    transactionCode?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    studentProfileId?: SortOrder
    amount?: SortOrder
  }

  export type EnumUtilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UtilityType | EnumUtilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUtilityTypeFilter<$PrismaModel> | $Enums.UtilityType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UtilityMeterReadingCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    readingDate?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UtilityMeterReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
  }

  export type UtilityMeterReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    readingDate?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UtilityMeterReadingMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    readingDate?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UtilityMeterReadingSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    indexValue?: SortOrder
    billingMonth?: SortOrder
    billingYear?: SortOrder
  }

  export type EnumUtilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UtilityType | EnumUtilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUtilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.UtilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUtilityTypeFilter<$PrismaModel>
    _max?: NestedEnumUtilityTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type MaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    issue?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type MaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    issue?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    issue?: SortOrder
    reportDate?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    reportedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type RoomTransferCountOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrder
    toRoomId?: SortOrder
    transferDate?: SortOrder
    reason?: SortOrder
    adminNotes?: SortOrder
    approvedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTransferAvgOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrder
    toRoomId?: SortOrder
    approvedById?: SortOrder
  }

  export type RoomTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrder
    toRoomId?: SortOrder
    transferDate?: SortOrder
    reason?: SortOrder
    adminNotes?: SortOrder
    approvedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTransferMinOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrder
    toRoomId?: SortOrder
    transferDate?: SortOrder
    reason?: SortOrder
    adminNotes?: SortOrder
    approvedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTransferSumOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    fromRoomId?: SortOrder
    toRoomId?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type EnumVehicleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeFilter<$PrismaModel> | $Enums.VehicleType
  }

  export type VehicleRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    color?: SortOrder
    parkingCardNo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleRegistrationAvgOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
  }

  export type VehicleRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    color?: SortOrder
    parkingCardNo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    color?: SortOrder
    parkingCardNo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleRegistrationSumOrderByAggregateInput = {
    id?: SortOrder
    studentProfileId?: SortOrder
  }

  export type EnumVehicleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type BuildingListRelationFilter = {
    every?: BuildingWhereInput
    some?: BuildingWhereInput
    none?: BuildingWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    mediaType?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type LoginLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type LoginLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LoginLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type LoginLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type LoginLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MediaCreateNestedOneWithoutAvatarForInput = {
    create?: XOR<MediaCreateWithoutAvatarForInput, MediaUncheckedCreateWithoutAvatarForInput>
    connectOrCreate?: MediaCreateOrConnectWithoutAvatarForInput
    connect?: MediaWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type LoginLogCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
  }

  export type StaffProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type StudentProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type LoginLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MediaUpdateOneWithoutAvatarForNestedInput = {
    create?: XOR<MediaCreateWithoutAvatarForInput, MediaUncheckedCreateWithoutAvatarForInput>
    connectOrCreate?: MediaCreateOrConnectWithoutAvatarForInput
    upsert?: MediaUpsertWithoutAvatarForInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutAvatarForInput, MediaUpdateWithoutAvatarForInput>, MediaUncheckedUpdateWithoutAvatarForInput>
  }

  export type StaffProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    upsert?: StaffProfileUpsertWithoutUserInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUserInput, StaffProfileUpdateWithoutUserInput>, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    upsert?: StudentProfileUpsertWithoutUserInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutUserInput, StudentProfileUpdateWithoutUserInput>, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type LoginLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    upsert?: LoginLogUpsertWithWhereUniqueWithoutUserInput | LoginLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    set?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    disconnect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    delete?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    update?: LoginLogUpdateWithWhereUniqueWithoutUserInput | LoginLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginLogUpdateManyWithWhereWithoutUserInput | LoginLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StaffProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    upsert?: StaffProfileUpsertWithoutUserInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUserInput, StaffProfileUpdateWithoutUserInput>, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    upsert?: StudentProfileUpsertWithoutUserInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutUserInput, StudentProfileUpdateWithoutUserInput>, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type LoginLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput> | LoginLogCreateWithoutUserInput[] | LoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginLogCreateOrConnectWithoutUserInput | LoginLogCreateOrConnectWithoutUserInput[]
    upsert?: LoginLogUpsertWithWhereUniqueWithoutUserInput | LoginLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginLogCreateManyUserInputEnvelope
    set?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    disconnect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    delete?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    connect?: LoginLogWhereUniqueInput | LoginLogWhereUniqueInput[]
    update?: LoginLogUpdateWithWhereUniqueWithoutUserInput | LoginLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginLogUpdateManyWithWhereWithoutUserInput | LoginLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStaffProfileInput = {
    create?: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffProfileInput
    connect?: UserWhereUniqueInput
  }

  export type BuildingCreateNestedOneWithoutStaffInput = {
    create?: XOR<BuildingCreateWithoutStaffInput, BuildingUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutStaffInput
    connect?: BuildingWhereUniqueInput
  }

  export type MaintenanceCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToInput, MaintenanceUncheckedCreateWithoutAssignedToInput> | MaintenanceCreateWithoutAssignedToInput[] | MaintenanceUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToInput | MaintenanceCreateOrConnectWithoutAssignedToInput[]
    createMany?: MaintenanceCreateManyAssignedToInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type RoomTransferCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<RoomTransferCreateWithoutApprovedByInput, RoomTransferUncheckedCreateWithoutApprovedByInput> | RoomTransferCreateWithoutApprovedByInput[] | RoomTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutApprovedByInput | RoomTransferCreateOrConnectWithoutApprovedByInput[]
    createMany?: RoomTransferCreateManyApprovedByInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToInput, MaintenanceUncheckedCreateWithoutAssignedToInput> | MaintenanceCreateWithoutAssignedToInput[] | MaintenanceUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToInput | MaintenanceCreateOrConnectWithoutAssignedToInput[]
    createMany?: MaintenanceCreateManyAssignedToInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type RoomTransferUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<RoomTransferCreateWithoutApprovedByInput, RoomTransferUncheckedCreateWithoutApprovedByInput> | RoomTransferCreateWithoutApprovedByInput[] | RoomTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutApprovedByInput | RoomTransferCreateOrConnectWithoutApprovedByInput[]
    createMany?: RoomTransferCreateManyApprovedByInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type UserUpdateOneRequiredWithoutStaffProfileNestedInput = {
    create?: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffProfileInput
    upsert?: UserUpsertWithoutStaffProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffProfileInput, UserUpdateWithoutStaffProfileInput>, UserUncheckedUpdateWithoutStaffProfileInput>
  }

  export type BuildingUpdateOneWithoutStaffNestedInput = {
    create?: XOR<BuildingCreateWithoutStaffInput, BuildingUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutStaffInput
    upsert?: BuildingUpsertWithoutStaffInput
    disconnect?: BuildingWhereInput | boolean
    delete?: BuildingWhereInput | boolean
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutStaffInput, BuildingUpdateWithoutStaffInput>, BuildingUncheckedUpdateWithoutStaffInput>
  }

  export type MaintenanceUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToInput, MaintenanceUncheckedCreateWithoutAssignedToInput> | MaintenanceCreateWithoutAssignedToInput[] | MaintenanceUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToInput | MaintenanceCreateOrConnectWithoutAssignedToInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutAssignedToInput | MaintenanceUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: MaintenanceCreateManyAssignedToInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutAssignedToInput | MaintenanceUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutAssignedToInput | MaintenanceUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type RoomTransferUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<RoomTransferCreateWithoutApprovedByInput, RoomTransferUncheckedCreateWithoutApprovedByInput> | RoomTransferCreateWithoutApprovedByInput[] | RoomTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutApprovedByInput | RoomTransferCreateOrConnectWithoutApprovedByInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutApprovedByInput | RoomTransferUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: RoomTransferCreateManyApprovedByInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutApprovedByInput | RoomTransferUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutApprovedByInput | RoomTransferUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToInput, MaintenanceUncheckedCreateWithoutAssignedToInput> | MaintenanceCreateWithoutAssignedToInput[] | MaintenanceUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToInput | MaintenanceCreateOrConnectWithoutAssignedToInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutAssignedToInput | MaintenanceUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: MaintenanceCreateManyAssignedToInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutAssignedToInput | MaintenanceUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutAssignedToInput | MaintenanceUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type RoomTransferUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<RoomTransferCreateWithoutApprovedByInput, RoomTransferUncheckedCreateWithoutApprovedByInput> | RoomTransferCreateWithoutApprovedByInput[] | RoomTransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutApprovedByInput | RoomTransferCreateOrConnectWithoutApprovedByInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutApprovedByInput | RoomTransferUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: RoomTransferCreateManyApprovedByInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutApprovedByInput | RoomTransferUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutApprovedByInput | RoomTransferUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutResidentsInput = {
    create?: XOR<RoomCreateWithoutResidentsInput, RoomUncheckedCreateWithoutResidentsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutResidentsInput
    connect?: RoomWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<InvoiceCreateWithoutStudentProfileInput, InvoiceUncheckedCreateWithoutStudentProfileInput> | InvoiceCreateWithoutStudentProfileInput[] | InvoiceUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentProfileInput | InvoiceCreateOrConnectWithoutStudentProfileInput[]
    createMany?: InvoiceCreateManyStudentProfileInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<PaymentCreateWithoutStudentProfileInput, PaymentUncheckedCreateWithoutStudentProfileInput> | PaymentCreateWithoutStudentProfileInput[] | PaymentUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentProfileInput | PaymentCreateOrConnectWithoutStudentProfileInput[]
    createMany?: PaymentCreateManyStudentProfileInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RoomTransferCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<RoomTransferCreateWithoutStudentProfileInput, RoomTransferUncheckedCreateWithoutStudentProfileInput> | RoomTransferCreateWithoutStudentProfileInput[] | RoomTransferUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutStudentProfileInput | RoomTransferCreateOrConnectWithoutStudentProfileInput[]
    createMany?: RoomTransferCreateManyStudentProfileInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutReportedByInput = {
    create?: XOR<MaintenanceCreateWithoutReportedByInput, MaintenanceUncheckedCreateWithoutReportedByInput> | MaintenanceCreateWithoutReportedByInput[] | MaintenanceUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutReportedByInput | MaintenanceCreateOrConnectWithoutReportedByInput[]
    createMany?: MaintenanceCreateManyReportedByInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type VehicleRegistrationCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<VehicleRegistrationCreateWithoutStudentProfileInput, VehicleRegistrationUncheckedCreateWithoutStudentProfileInput> | VehicleRegistrationCreateWithoutStudentProfileInput[] | VehicleRegistrationUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutStudentProfileInput | VehicleRegistrationCreateOrConnectWithoutStudentProfileInput[]
    createMany?: VehicleRegistrationCreateManyStudentProfileInputEnvelope
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<InvoiceCreateWithoutStudentProfileInput, InvoiceUncheckedCreateWithoutStudentProfileInput> | InvoiceCreateWithoutStudentProfileInput[] | InvoiceUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentProfileInput | InvoiceCreateOrConnectWithoutStudentProfileInput[]
    createMany?: InvoiceCreateManyStudentProfileInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<PaymentCreateWithoutStudentProfileInput, PaymentUncheckedCreateWithoutStudentProfileInput> | PaymentCreateWithoutStudentProfileInput[] | PaymentUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentProfileInput | PaymentCreateOrConnectWithoutStudentProfileInput[]
    createMany?: PaymentCreateManyStudentProfileInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<RoomTransferCreateWithoutStudentProfileInput, RoomTransferUncheckedCreateWithoutStudentProfileInput> | RoomTransferCreateWithoutStudentProfileInput[] | RoomTransferUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutStudentProfileInput | RoomTransferCreateOrConnectWithoutStudentProfileInput[]
    createMany?: RoomTransferCreateManyStudentProfileInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<MaintenanceCreateWithoutReportedByInput, MaintenanceUncheckedCreateWithoutReportedByInput> | MaintenanceCreateWithoutReportedByInput[] | MaintenanceUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutReportedByInput | MaintenanceCreateOrConnectWithoutReportedByInput[]
    createMany?: MaintenanceCreateManyReportedByInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<VehicleRegistrationCreateWithoutStudentProfileInput, VehicleRegistrationUncheckedCreateWithoutStudentProfileInput> | VehicleRegistrationCreateWithoutStudentProfileInput[] | VehicleRegistrationUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutStudentProfileInput | VehicleRegistrationCreateOrConnectWithoutStudentProfileInput[]
    createMany?: VehicleRegistrationCreateManyStudentProfileInputEnvelope
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentStatus
  }

  export type UserUpdateOneRequiredWithoutStudentProfileNestedInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    upsert?: UserUpsertWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentProfileInput, UserUpdateWithoutStudentProfileInput>, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type RoomUpdateOneWithoutResidentsNestedInput = {
    create?: XOR<RoomCreateWithoutResidentsInput, RoomUncheckedCreateWithoutResidentsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutResidentsInput
    upsert?: RoomUpsertWithoutResidentsInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutResidentsInput, RoomUpdateWithoutResidentsInput>, RoomUncheckedUpdateWithoutResidentsInput>
  }

  export type InvoiceUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentProfileInput, InvoiceUncheckedCreateWithoutStudentProfileInput> | InvoiceCreateWithoutStudentProfileInput[] | InvoiceUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentProfileInput | InvoiceCreateOrConnectWithoutStudentProfileInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentProfileInput | InvoiceUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: InvoiceCreateManyStudentProfileInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentProfileInput | InvoiceUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentProfileInput | InvoiceUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<PaymentCreateWithoutStudentProfileInput, PaymentUncheckedCreateWithoutStudentProfileInput> | PaymentCreateWithoutStudentProfileInput[] | PaymentUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentProfileInput | PaymentCreateOrConnectWithoutStudentProfileInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStudentProfileInput | PaymentUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: PaymentCreateManyStudentProfileInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStudentProfileInput | PaymentUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStudentProfileInput | PaymentUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RoomTransferUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<RoomTransferCreateWithoutStudentProfileInput, RoomTransferUncheckedCreateWithoutStudentProfileInput> | RoomTransferCreateWithoutStudentProfileInput[] | RoomTransferUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutStudentProfileInput | RoomTransferCreateOrConnectWithoutStudentProfileInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutStudentProfileInput | RoomTransferUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: RoomTransferCreateManyStudentProfileInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutStudentProfileInput | RoomTransferUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutStudentProfileInput | RoomTransferUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<MaintenanceCreateWithoutReportedByInput, MaintenanceUncheckedCreateWithoutReportedByInput> | MaintenanceCreateWithoutReportedByInput[] | MaintenanceUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutReportedByInput | MaintenanceCreateOrConnectWithoutReportedByInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutReportedByInput | MaintenanceUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: MaintenanceCreateManyReportedByInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutReportedByInput | MaintenanceUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutReportedByInput | MaintenanceUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<VehicleRegistrationCreateWithoutStudentProfileInput, VehicleRegistrationUncheckedCreateWithoutStudentProfileInput> | VehicleRegistrationCreateWithoutStudentProfileInput[] | VehicleRegistrationUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutStudentProfileInput | VehicleRegistrationCreateOrConnectWithoutStudentProfileInput[]
    upsert?: VehicleRegistrationUpsertWithWhereUniqueWithoutStudentProfileInput | VehicleRegistrationUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: VehicleRegistrationCreateManyStudentProfileInputEnvelope
    set?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    disconnect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    delete?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    update?: VehicleRegistrationUpdateWithWhereUniqueWithoutStudentProfileInput | VehicleRegistrationUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: VehicleRegistrationUpdateManyWithWhereWithoutStudentProfileInput | VehicleRegistrationUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: VehicleRegistrationScalarWhereInput | VehicleRegistrationScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentProfileInput, InvoiceUncheckedCreateWithoutStudentProfileInput> | InvoiceCreateWithoutStudentProfileInput[] | InvoiceUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentProfileInput | InvoiceCreateOrConnectWithoutStudentProfileInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentProfileInput | InvoiceUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: InvoiceCreateManyStudentProfileInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentProfileInput | InvoiceUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentProfileInput | InvoiceUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<PaymentCreateWithoutStudentProfileInput, PaymentUncheckedCreateWithoutStudentProfileInput> | PaymentCreateWithoutStudentProfileInput[] | PaymentUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentProfileInput | PaymentCreateOrConnectWithoutStudentProfileInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStudentProfileInput | PaymentUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: PaymentCreateManyStudentProfileInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStudentProfileInput | PaymentUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStudentProfileInput | PaymentUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<RoomTransferCreateWithoutStudentProfileInput, RoomTransferUncheckedCreateWithoutStudentProfileInput> | RoomTransferCreateWithoutStudentProfileInput[] | RoomTransferUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutStudentProfileInput | RoomTransferCreateOrConnectWithoutStudentProfileInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutStudentProfileInput | RoomTransferUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: RoomTransferCreateManyStudentProfileInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutStudentProfileInput | RoomTransferUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutStudentProfileInput | RoomTransferUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<MaintenanceCreateWithoutReportedByInput, MaintenanceUncheckedCreateWithoutReportedByInput> | MaintenanceCreateWithoutReportedByInput[] | MaintenanceUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutReportedByInput | MaintenanceCreateOrConnectWithoutReportedByInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutReportedByInput | MaintenanceUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: MaintenanceCreateManyReportedByInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutReportedByInput | MaintenanceUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutReportedByInput | MaintenanceUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<VehicleRegistrationCreateWithoutStudentProfileInput, VehicleRegistrationUncheckedCreateWithoutStudentProfileInput> | VehicleRegistrationCreateWithoutStudentProfileInput[] | VehicleRegistrationUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutStudentProfileInput | VehicleRegistrationCreateOrConnectWithoutStudentProfileInput[]
    upsert?: VehicleRegistrationUpsertWithWhereUniqueWithoutStudentProfileInput | VehicleRegistrationUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: VehicleRegistrationCreateManyStudentProfileInputEnvelope
    set?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    disconnect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    delete?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    update?: VehicleRegistrationUpdateWithWhereUniqueWithoutStudentProfileInput | VehicleRegistrationUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: VehicleRegistrationUpdateManyWithWhereWithoutStudentProfileInput | VehicleRegistrationUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: VehicleRegistrationScalarWhereInput | VehicleRegistrationScalarWhereInput[]
  }

  export type MediaCreateNestedManyWithoutBuildingImagesInput = {
    create?: XOR<MediaCreateWithoutBuildingImagesInput, MediaUncheckedCreateWithoutBuildingImagesInput> | MediaCreateWithoutBuildingImagesInput[] | MediaUncheckedCreateWithoutBuildingImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBuildingImagesInput | MediaCreateOrConnectWithoutBuildingImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type StaffProfileCreateNestedManyWithoutManagedBuildingInput = {
    create?: XOR<StaffProfileCreateWithoutManagedBuildingInput, StaffProfileUncheckedCreateWithoutManagedBuildingInput> | StaffProfileCreateWithoutManagedBuildingInput[] | StaffProfileUncheckedCreateWithoutManagedBuildingInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutManagedBuildingInput | StaffProfileCreateOrConnectWithoutManagedBuildingInput[]
    createMany?: StaffProfileCreateManyManagedBuildingInputEnvelope
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutBuildingImagesInput = {
    create?: XOR<MediaCreateWithoutBuildingImagesInput, MediaUncheckedCreateWithoutBuildingImagesInput> | MediaCreateWithoutBuildingImagesInput[] | MediaUncheckedCreateWithoutBuildingImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBuildingImagesInput | MediaCreateOrConnectWithoutBuildingImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type StaffProfileUncheckedCreateNestedManyWithoutManagedBuildingInput = {
    create?: XOR<StaffProfileCreateWithoutManagedBuildingInput, StaffProfileUncheckedCreateWithoutManagedBuildingInput> | StaffProfileCreateWithoutManagedBuildingInput[] | StaffProfileUncheckedCreateWithoutManagedBuildingInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutManagedBuildingInput | StaffProfileCreateOrConnectWithoutManagedBuildingInput[]
    createMany?: StaffProfileCreateManyManagedBuildingInputEnvelope
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
  }

  export type MediaUpdateManyWithoutBuildingImagesNestedInput = {
    create?: XOR<MediaCreateWithoutBuildingImagesInput, MediaUncheckedCreateWithoutBuildingImagesInput> | MediaCreateWithoutBuildingImagesInput[] | MediaUncheckedCreateWithoutBuildingImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBuildingImagesInput | MediaCreateOrConnectWithoutBuildingImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutBuildingImagesInput | MediaUpsertWithWhereUniqueWithoutBuildingImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutBuildingImagesInput | MediaUpdateWithWhereUniqueWithoutBuildingImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutBuildingImagesInput | MediaUpdateManyWithWhereWithoutBuildingImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type StaffProfileUpdateManyWithoutManagedBuildingNestedInput = {
    create?: XOR<StaffProfileCreateWithoutManagedBuildingInput, StaffProfileUncheckedCreateWithoutManagedBuildingInput> | StaffProfileCreateWithoutManagedBuildingInput[] | StaffProfileUncheckedCreateWithoutManagedBuildingInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutManagedBuildingInput | StaffProfileCreateOrConnectWithoutManagedBuildingInput[]
    upsert?: StaffProfileUpsertWithWhereUniqueWithoutManagedBuildingInput | StaffProfileUpsertWithWhereUniqueWithoutManagedBuildingInput[]
    createMany?: StaffProfileCreateManyManagedBuildingInputEnvelope
    set?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    disconnect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    delete?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    update?: StaffProfileUpdateWithWhereUniqueWithoutManagedBuildingInput | StaffProfileUpdateWithWhereUniqueWithoutManagedBuildingInput[]
    updateMany?: StaffProfileUpdateManyWithWhereWithoutManagedBuildingInput | StaffProfileUpdateManyWithWhereWithoutManagedBuildingInput[]
    deleteMany?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutBuildingImagesNestedInput = {
    create?: XOR<MediaCreateWithoutBuildingImagesInput, MediaUncheckedCreateWithoutBuildingImagesInput> | MediaCreateWithoutBuildingImagesInput[] | MediaUncheckedCreateWithoutBuildingImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBuildingImagesInput | MediaCreateOrConnectWithoutBuildingImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutBuildingImagesInput | MediaUpsertWithWhereUniqueWithoutBuildingImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutBuildingImagesInput | MediaUpdateWithWhereUniqueWithoutBuildingImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutBuildingImagesInput | MediaUpdateManyWithWhereWithoutBuildingImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type StaffProfileUncheckedUpdateManyWithoutManagedBuildingNestedInput = {
    create?: XOR<StaffProfileCreateWithoutManagedBuildingInput, StaffProfileUncheckedCreateWithoutManagedBuildingInput> | StaffProfileCreateWithoutManagedBuildingInput[] | StaffProfileUncheckedCreateWithoutManagedBuildingInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutManagedBuildingInput | StaffProfileCreateOrConnectWithoutManagedBuildingInput[]
    upsert?: StaffProfileUpsertWithWhereUniqueWithoutManagedBuildingInput | StaffProfileUpsertWithWhereUniqueWithoutManagedBuildingInput[]
    createMany?: StaffProfileCreateManyManagedBuildingInputEnvelope
    set?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    disconnect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    delete?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    update?: StaffProfileUpdateWithWhereUniqueWithoutManagedBuildingInput | StaffProfileUpdateWithWhereUniqueWithoutManagedBuildingInput[]
    updateMany?: StaffProfileUpdateManyWithWhereWithoutManagedBuildingInput | StaffProfileUpdateManyWithWhereWithoutManagedBuildingInput[]
    deleteMany?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
  }

  export type BuildingCreateNestedOneWithoutRoomsInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutRoomImagesInput = {
    create?: XOR<MediaCreateWithoutRoomImagesInput, MediaUncheckedCreateWithoutRoomImagesInput> | MediaCreateWithoutRoomImagesInput[] | MediaUncheckedCreateWithoutRoomImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutRoomImagesInput | MediaCreateOrConnectWithoutRoomImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type StudentProfileCreateNestedManyWithoutRoomInput = {
    create?: XOR<StudentProfileCreateWithoutRoomInput, StudentProfileUncheckedCreateWithoutRoomInput> | StudentProfileCreateWithoutRoomInput[] | StudentProfileUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRoomInput | StudentProfileCreateOrConnectWithoutRoomInput[]
    createMany?: StudentProfileCreateManyRoomInputEnvelope
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
  }

  export type RoomAmenityCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAmenityCreateWithoutRoomInput, RoomAmenityUncheckedCreateWithoutRoomInput> | RoomAmenityCreateWithoutRoomInput[] | RoomAmenityUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutRoomInput | RoomAmenityCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAmenityCreateManyRoomInputEnvelope
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
  }

  export type UtilityMeterReadingCreateNestedManyWithoutRoomInput = {
    create?: XOR<UtilityMeterReadingCreateWithoutRoomInput, UtilityMeterReadingUncheckedCreateWithoutRoomInput> | UtilityMeterReadingCreateWithoutRoomInput[] | UtilityMeterReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UtilityMeterReadingCreateOrConnectWithoutRoomInput | UtilityMeterReadingCreateOrConnectWithoutRoomInput[]
    createMany?: UtilityMeterReadingCreateManyRoomInputEnvelope
    connect?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutRoomInput = {
    create?: XOR<InvoiceCreateWithoutRoomInput, InvoiceUncheckedCreateWithoutRoomInput> | InvoiceCreateWithoutRoomInput[] | InvoiceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRoomInput | InvoiceCreateOrConnectWithoutRoomInput[]
    createMany?: InvoiceCreateManyRoomInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutRoomInput = {
    create?: XOR<MaintenanceCreateWithoutRoomInput, MaintenanceUncheckedCreateWithoutRoomInput> | MaintenanceCreateWithoutRoomInput[] | MaintenanceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutRoomInput | MaintenanceCreateOrConnectWithoutRoomInput[]
    createMany?: MaintenanceCreateManyRoomInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type RoomTransferCreateNestedManyWithoutFromRoomInput = {
    create?: XOR<RoomTransferCreateWithoutFromRoomInput, RoomTransferUncheckedCreateWithoutFromRoomInput> | RoomTransferCreateWithoutFromRoomInput[] | RoomTransferUncheckedCreateWithoutFromRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutFromRoomInput | RoomTransferCreateOrConnectWithoutFromRoomInput[]
    createMany?: RoomTransferCreateManyFromRoomInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type RoomTransferCreateNestedManyWithoutToRoomInput = {
    create?: XOR<RoomTransferCreateWithoutToRoomInput, RoomTransferUncheckedCreateWithoutToRoomInput> | RoomTransferCreateWithoutToRoomInput[] | RoomTransferUncheckedCreateWithoutToRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutToRoomInput | RoomTransferCreateOrConnectWithoutToRoomInput[]
    createMany?: RoomTransferCreateManyToRoomInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutRoomImagesInput = {
    create?: XOR<MediaCreateWithoutRoomImagesInput, MediaUncheckedCreateWithoutRoomImagesInput> | MediaCreateWithoutRoomImagesInput[] | MediaUncheckedCreateWithoutRoomImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutRoomImagesInput | MediaCreateOrConnectWithoutRoomImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type StudentProfileUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<StudentProfileCreateWithoutRoomInput, StudentProfileUncheckedCreateWithoutRoomInput> | StudentProfileCreateWithoutRoomInput[] | StudentProfileUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRoomInput | StudentProfileCreateOrConnectWithoutRoomInput[]
    createMany?: StudentProfileCreateManyRoomInputEnvelope
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
  }

  export type RoomAmenityUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAmenityCreateWithoutRoomInput, RoomAmenityUncheckedCreateWithoutRoomInput> | RoomAmenityCreateWithoutRoomInput[] | RoomAmenityUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutRoomInput | RoomAmenityCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAmenityCreateManyRoomInputEnvelope
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
  }

  export type UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<UtilityMeterReadingCreateWithoutRoomInput, UtilityMeterReadingUncheckedCreateWithoutRoomInput> | UtilityMeterReadingCreateWithoutRoomInput[] | UtilityMeterReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UtilityMeterReadingCreateOrConnectWithoutRoomInput | UtilityMeterReadingCreateOrConnectWithoutRoomInput[]
    createMany?: UtilityMeterReadingCreateManyRoomInputEnvelope
    connect?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<InvoiceCreateWithoutRoomInput, InvoiceUncheckedCreateWithoutRoomInput> | InvoiceCreateWithoutRoomInput[] | InvoiceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRoomInput | InvoiceCreateOrConnectWithoutRoomInput[]
    createMany?: InvoiceCreateManyRoomInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MaintenanceCreateWithoutRoomInput, MaintenanceUncheckedCreateWithoutRoomInput> | MaintenanceCreateWithoutRoomInput[] | MaintenanceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutRoomInput | MaintenanceCreateOrConnectWithoutRoomInput[]
    createMany?: MaintenanceCreateManyRoomInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput = {
    create?: XOR<RoomTransferCreateWithoutFromRoomInput, RoomTransferUncheckedCreateWithoutFromRoomInput> | RoomTransferCreateWithoutFromRoomInput[] | RoomTransferUncheckedCreateWithoutFromRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutFromRoomInput | RoomTransferCreateOrConnectWithoutFromRoomInput[]
    createMany?: RoomTransferCreateManyFromRoomInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type RoomTransferUncheckedCreateNestedManyWithoutToRoomInput = {
    create?: XOR<RoomTransferCreateWithoutToRoomInput, RoomTransferUncheckedCreateWithoutToRoomInput> | RoomTransferCreateWithoutToRoomInput[] | RoomTransferUncheckedCreateWithoutToRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutToRoomInput | RoomTransferCreateOrConnectWithoutToRoomInput[]
    createMany?: RoomTransferCreateManyToRoomInputEnvelope
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
  }

  export type EnumRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoomType
  }

  export type EnumRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoomStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BuildingUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    upsert?: BuildingUpsertWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutRoomsInput, BuildingUpdateWithoutRoomsInput>, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type MediaUpdateManyWithoutRoomImagesNestedInput = {
    create?: XOR<MediaCreateWithoutRoomImagesInput, MediaUncheckedCreateWithoutRoomImagesInput> | MediaCreateWithoutRoomImagesInput[] | MediaUncheckedCreateWithoutRoomImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutRoomImagesInput | MediaCreateOrConnectWithoutRoomImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutRoomImagesInput | MediaUpsertWithWhereUniqueWithoutRoomImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutRoomImagesInput | MediaUpdateWithWhereUniqueWithoutRoomImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutRoomImagesInput | MediaUpdateManyWithWhereWithoutRoomImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type StudentProfileUpdateManyWithoutRoomNestedInput = {
    create?: XOR<StudentProfileCreateWithoutRoomInput, StudentProfileUncheckedCreateWithoutRoomInput> | StudentProfileCreateWithoutRoomInput[] | StudentProfileUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRoomInput | StudentProfileCreateOrConnectWithoutRoomInput[]
    upsert?: StudentProfileUpsertWithWhereUniqueWithoutRoomInput | StudentProfileUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: StudentProfileCreateManyRoomInputEnvelope
    set?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    disconnect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    delete?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    update?: StudentProfileUpdateWithWhereUniqueWithoutRoomInput | StudentProfileUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: StudentProfileUpdateManyWithWhereWithoutRoomInput | StudentProfileUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
  }

  export type RoomAmenityUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutRoomInput, RoomAmenityUncheckedCreateWithoutRoomInput> | RoomAmenityCreateWithoutRoomInput[] | RoomAmenityUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutRoomInput | RoomAmenityCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAmenityUpsertWithWhereUniqueWithoutRoomInput | RoomAmenityUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAmenityCreateManyRoomInputEnvelope
    set?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    disconnect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    delete?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    update?: RoomAmenityUpdateWithWhereUniqueWithoutRoomInput | RoomAmenityUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAmenityUpdateManyWithWhereWithoutRoomInput | RoomAmenityUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
  }

  export type UtilityMeterReadingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<UtilityMeterReadingCreateWithoutRoomInput, UtilityMeterReadingUncheckedCreateWithoutRoomInput> | UtilityMeterReadingCreateWithoutRoomInput[] | UtilityMeterReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UtilityMeterReadingCreateOrConnectWithoutRoomInput | UtilityMeterReadingCreateOrConnectWithoutRoomInput[]
    upsert?: UtilityMeterReadingUpsertWithWhereUniqueWithoutRoomInput | UtilityMeterReadingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: UtilityMeterReadingCreateManyRoomInputEnvelope
    set?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    disconnect?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    delete?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    connect?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    update?: UtilityMeterReadingUpdateWithWhereUniqueWithoutRoomInput | UtilityMeterReadingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: UtilityMeterReadingUpdateManyWithWhereWithoutRoomInput | UtilityMeterReadingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: UtilityMeterReadingScalarWhereInput | UtilityMeterReadingScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutRoomNestedInput = {
    create?: XOR<InvoiceCreateWithoutRoomInput, InvoiceUncheckedCreateWithoutRoomInput> | InvoiceCreateWithoutRoomInput[] | InvoiceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRoomInput | InvoiceCreateOrConnectWithoutRoomInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRoomInput | InvoiceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: InvoiceCreateManyRoomInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRoomInput | InvoiceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRoomInput | InvoiceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MaintenanceCreateWithoutRoomInput, MaintenanceUncheckedCreateWithoutRoomInput> | MaintenanceCreateWithoutRoomInput[] | MaintenanceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutRoomInput | MaintenanceCreateOrConnectWithoutRoomInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutRoomInput | MaintenanceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MaintenanceCreateManyRoomInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutRoomInput | MaintenanceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutRoomInput | MaintenanceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type RoomTransferUpdateManyWithoutFromRoomNestedInput = {
    create?: XOR<RoomTransferCreateWithoutFromRoomInput, RoomTransferUncheckedCreateWithoutFromRoomInput> | RoomTransferCreateWithoutFromRoomInput[] | RoomTransferUncheckedCreateWithoutFromRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutFromRoomInput | RoomTransferCreateOrConnectWithoutFromRoomInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutFromRoomInput | RoomTransferUpsertWithWhereUniqueWithoutFromRoomInput[]
    createMany?: RoomTransferCreateManyFromRoomInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutFromRoomInput | RoomTransferUpdateWithWhereUniqueWithoutFromRoomInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutFromRoomInput | RoomTransferUpdateManyWithWhereWithoutFromRoomInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type RoomTransferUpdateManyWithoutToRoomNestedInput = {
    create?: XOR<RoomTransferCreateWithoutToRoomInput, RoomTransferUncheckedCreateWithoutToRoomInput> | RoomTransferCreateWithoutToRoomInput[] | RoomTransferUncheckedCreateWithoutToRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutToRoomInput | RoomTransferCreateOrConnectWithoutToRoomInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutToRoomInput | RoomTransferUpsertWithWhereUniqueWithoutToRoomInput[]
    createMany?: RoomTransferCreateManyToRoomInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutToRoomInput | RoomTransferUpdateWithWhereUniqueWithoutToRoomInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutToRoomInput | RoomTransferUpdateManyWithWhereWithoutToRoomInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutRoomImagesNestedInput = {
    create?: XOR<MediaCreateWithoutRoomImagesInput, MediaUncheckedCreateWithoutRoomImagesInput> | MediaCreateWithoutRoomImagesInput[] | MediaUncheckedCreateWithoutRoomImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutRoomImagesInput | MediaCreateOrConnectWithoutRoomImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutRoomImagesInput | MediaUpsertWithWhereUniqueWithoutRoomImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutRoomImagesInput | MediaUpdateWithWhereUniqueWithoutRoomImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutRoomImagesInput | MediaUpdateManyWithWhereWithoutRoomImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type StudentProfileUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<StudentProfileCreateWithoutRoomInput, StudentProfileUncheckedCreateWithoutRoomInput> | StudentProfileCreateWithoutRoomInput[] | StudentProfileUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRoomInput | StudentProfileCreateOrConnectWithoutRoomInput[]
    upsert?: StudentProfileUpsertWithWhereUniqueWithoutRoomInput | StudentProfileUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: StudentProfileCreateManyRoomInputEnvelope
    set?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    disconnect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    delete?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    update?: StudentProfileUpdateWithWhereUniqueWithoutRoomInput | StudentProfileUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: StudentProfileUpdateManyWithWhereWithoutRoomInput | StudentProfileUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
  }

  export type RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutRoomInput, RoomAmenityUncheckedCreateWithoutRoomInput> | RoomAmenityCreateWithoutRoomInput[] | RoomAmenityUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutRoomInput | RoomAmenityCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAmenityUpsertWithWhereUniqueWithoutRoomInput | RoomAmenityUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAmenityCreateManyRoomInputEnvelope
    set?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    disconnect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    delete?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    update?: RoomAmenityUpdateWithWhereUniqueWithoutRoomInput | RoomAmenityUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAmenityUpdateManyWithWhereWithoutRoomInput | RoomAmenityUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
  }

  export type UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<UtilityMeterReadingCreateWithoutRoomInput, UtilityMeterReadingUncheckedCreateWithoutRoomInput> | UtilityMeterReadingCreateWithoutRoomInput[] | UtilityMeterReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UtilityMeterReadingCreateOrConnectWithoutRoomInput | UtilityMeterReadingCreateOrConnectWithoutRoomInput[]
    upsert?: UtilityMeterReadingUpsertWithWhereUniqueWithoutRoomInput | UtilityMeterReadingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: UtilityMeterReadingCreateManyRoomInputEnvelope
    set?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    disconnect?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    delete?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    connect?: UtilityMeterReadingWhereUniqueInput | UtilityMeterReadingWhereUniqueInput[]
    update?: UtilityMeterReadingUpdateWithWhereUniqueWithoutRoomInput | UtilityMeterReadingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: UtilityMeterReadingUpdateManyWithWhereWithoutRoomInput | UtilityMeterReadingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: UtilityMeterReadingScalarWhereInput | UtilityMeterReadingScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<InvoiceCreateWithoutRoomInput, InvoiceUncheckedCreateWithoutRoomInput> | InvoiceCreateWithoutRoomInput[] | InvoiceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRoomInput | InvoiceCreateOrConnectWithoutRoomInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRoomInput | InvoiceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: InvoiceCreateManyRoomInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRoomInput | InvoiceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRoomInput | InvoiceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MaintenanceCreateWithoutRoomInput, MaintenanceUncheckedCreateWithoutRoomInput> | MaintenanceCreateWithoutRoomInput[] | MaintenanceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutRoomInput | MaintenanceCreateOrConnectWithoutRoomInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutRoomInput | MaintenanceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MaintenanceCreateManyRoomInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutRoomInput | MaintenanceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutRoomInput | MaintenanceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput = {
    create?: XOR<RoomTransferCreateWithoutFromRoomInput, RoomTransferUncheckedCreateWithoutFromRoomInput> | RoomTransferCreateWithoutFromRoomInput[] | RoomTransferUncheckedCreateWithoutFromRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutFromRoomInput | RoomTransferCreateOrConnectWithoutFromRoomInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutFromRoomInput | RoomTransferUpsertWithWhereUniqueWithoutFromRoomInput[]
    createMany?: RoomTransferCreateManyFromRoomInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutFromRoomInput | RoomTransferUpdateWithWhereUniqueWithoutFromRoomInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutFromRoomInput | RoomTransferUpdateManyWithWhereWithoutFromRoomInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput = {
    create?: XOR<RoomTransferCreateWithoutToRoomInput, RoomTransferUncheckedCreateWithoutToRoomInput> | RoomTransferCreateWithoutToRoomInput[] | RoomTransferUncheckedCreateWithoutToRoomInput[]
    connectOrCreate?: RoomTransferCreateOrConnectWithoutToRoomInput | RoomTransferCreateOrConnectWithoutToRoomInput[]
    upsert?: RoomTransferUpsertWithWhereUniqueWithoutToRoomInput | RoomTransferUpsertWithWhereUniqueWithoutToRoomInput[]
    createMany?: RoomTransferCreateManyToRoomInputEnvelope
    set?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    disconnect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    delete?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    connect?: RoomTransferWhereUniqueInput | RoomTransferWhereUniqueInput[]
    update?: RoomTransferUpdateWithWhereUniqueWithoutToRoomInput | RoomTransferUpdateWithWhereUniqueWithoutToRoomInput[]
    updateMany?: RoomTransferUpdateManyWithWhereWithoutToRoomInput | RoomTransferUpdateManyWithWhereWithoutToRoomInput[]
    deleteMany?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
  }

  export type RoomAmenityCreateNestedManyWithoutAmenityInput = {
    create?: XOR<RoomAmenityCreateWithoutAmenityInput, RoomAmenityUncheckedCreateWithoutAmenityInput> | RoomAmenityCreateWithoutAmenityInput[] | RoomAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutAmenityInput | RoomAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: RoomAmenityCreateManyAmenityInputEnvelope
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
  }

  export type RoomAmenityUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<RoomAmenityCreateWithoutAmenityInput, RoomAmenityUncheckedCreateWithoutAmenityInput> | RoomAmenityCreateWithoutAmenityInput[] | RoomAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutAmenityInput | RoomAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: RoomAmenityCreateManyAmenityInputEnvelope
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
  }

  export type RoomAmenityUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutAmenityInput, RoomAmenityUncheckedCreateWithoutAmenityInput> | RoomAmenityCreateWithoutAmenityInput[] | RoomAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutAmenityInput | RoomAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: RoomAmenityUpsertWithWhereUniqueWithoutAmenityInput | RoomAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: RoomAmenityCreateManyAmenityInputEnvelope
    set?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    disconnect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    delete?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    update?: RoomAmenityUpdateWithWhereUniqueWithoutAmenityInput | RoomAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: RoomAmenityUpdateManyWithWhereWithoutAmenityInput | RoomAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
  }

  export type RoomAmenityUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<RoomAmenityCreateWithoutAmenityInput, RoomAmenityUncheckedCreateWithoutAmenityInput> | RoomAmenityCreateWithoutAmenityInput[] | RoomAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomAmenityCreateOrConnectWithoutAmenityInput | RoomAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: RoomAmenityUpsertWithWhereUniqueWithoutAmenityInput | RoomAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: RoomAmenityCreateManyAmenityInputEnvelope
    set?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    disconnect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    delete?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    connect?: RoomAmenityWhereUniqueInput | RoomAmenityWhereUniqueInput[]
    update?: RoomAmenityUpdateWithWhereUniqueWithoutAmenityInput | RoomAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: RoomAmenityUpdateManyWithWhereWithoutAmenityInput | RoomAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
  }

  export type RoomCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAmenitiesInput
    connect?: RoomWhereUniqueInput
  }

  export type AmenityCreateNestedOneWithoutRoomsInput = {
    create?: XOR<AmenityCreateWithoutRoomsInput, AmenityUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutRoomsInput
    connect?: AmenityWhereUniqueInput
  }

  export type RoomUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAmenitiesInput
    upsert?: RoomUpsertWithoutAmenitiesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutAmenitiesInput, RoomUpdateWithoutAmenitiesInput>, RoomUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<AmenityCreateWithoutRoomsInput, AmenityUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutRoomsInput
    upsert?: AmenityUpsertWithoutRoomsInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutRoomsInput, AmenityUpdateWithoutRoomsInput>, AmenityUncheckedUpdateWithoutRoomsInput>
  }

  export type EnumFeeTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeeType
  }

  export type NullableEnumVehicleTypeFieldUpdateOperationsInput = {
    set?: $Enums.VehicleType | null
  }

  export type StudentProfileCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<StudentProfileCreateWithoutInvoicesInput, StudentProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutInvoicesInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<RoomCreateWithoutInvoicesInput, RoomUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutInvoicesInput
    connect?: RoomWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type StudentProfileUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<StudentProfileCreateWithoutInvoicesInput, StudentProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutInvoicesInput
    upsert?: StudentProfileUpsertWithoutInvoicesInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutInvoicesInput, StudentProfileUpdateWithoutInvoicesInput>, StudentProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type RoomUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<RoomCreateWithoutInvoicesInput, RoomUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutInvoicesInput
    upsert?: RoomUpsertWithoutInvoicesInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutInvoicesInput, RoomUpdateWithoutInvoicesInput>, RoomUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutPaymentsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutPaymentsInput
    upsert?: StudentProfileUpsertWithoutPaymentsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutPaymentsInput, StudentProfileUpdateWithoutPaymentsInput>, StudentProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type RoomCreateNestedOneWithoutMeterReadingsInput = {
    create?: XOR<RoomCreateWithoutMeterReadingsInput, RoomUncheckedCreateWithoutMeterReadingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMeterReadingsInput
    connect?: RoomWhereUniqueInput
  }

  export type EnumUtilityTypeFieldUpdateOperationsInput = {
    set?: $Enums.UtilityType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoomUpdateOneRequiredWithoutMeterReadingsNestedInput = {
    create?: XOR<RoomCreateWithoutMeterReadingsInput, RoomUncheckedCreateWithoutMeterReadingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMeterReadingsInput
    upsert?: RoomUpsertWithoutMeterReadingsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutMeterReadingsInput, RoomUpdateWithoutMeterReadingsInput>, RoomUncheckedUpdateWithoutMeterReadingsInput>
  }

  export type RoomCreateNestedOneWithoutMaintenancesInput = {
    create?: XOR<RoomCreateWithoutMaintenancesInput, RoomUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMaintenancesInput
    connect?: RoomWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutReportedMaintenancesInput = {
    create?: XOR<StudentProfileCreateWithoutReportedMaintenancesInput, StudentProfileUncheckedCreateWithoutReportedMaintenancesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutReportedMaintenancesInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutAssignedMaintenancesInput = {
    create?: XOR<StaffProfileCreateWithoutAssignedMaintenancesInput, StaffProfileUncheckedCreateWithoutAssignedMaintenancesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAssignedMaintenancesInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutMaintenanceImagesInput = {
    create?: XOR<MediaCreateWithoutMaintenanceImagesInput, MediaUncheckedCreateWithoutMaintenanceImagesInput> | MediaCreateWithoutMaintenanceImagesInput[] | MediaUncheckedCreateWithoutMaintenanceImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutMaintenanceImagesInput | MediaCreateOrConnectWithoutMaintenanceImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutMaintenanceImagesInput = {
    create?: XOR<MediaCreateWithoutMaintenanceImagesInput, MediaUncheckedCreateWithoutMaintenanceImagesInput> | MediaCreateWithoutMaintenanceImagesInput[] | MediaUncheckedCreateWithoutMaintenanceImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutMaintenanceImagesInput | MediaCreateOrConnectWithoutMaintenanceImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type EnumMaintenanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceStatus
  }

  export type RoomUpdateOneRequiredWithoutMaintenancesNestedInput = {
    create?: XOR<RoomCreateWithoutMaintenancesInput, RoomUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMaintenancesInput
    upsert?: RoomUpsertWithoutMaintenancesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutMaintenancesInput, RoomUpdateWithoutMaintenancesInput>, RoomUncheckedUpdateWithoutMaintenancesInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutReportedMaintenancesNestedInput = {
    create?: XOR<StudentProfileCreateWithoutReportedMaintenancesInput, StudentProfileUncheckedCreateWithoutReportedMaintenancesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutReportedMaintenancesInput
    upsert?: StudentProfileUpsertWithoutReportedMaintenancesInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutReportedMaintenancesInput, StudentProfileUpdateWithoutReportedMaintenancesInput>, StudentProfileUncheckedUpdateWithoutReportedMaintenancesInput>
  }

  export type StaffProfileUpdateOneWithoutAssignedMaintenancesNestedInput = {
    create?: XOR<StaffProfileCreateWithoutAssignedMaintenancesInput, StaffProfileUncheckedCreateWithoutAssignedMaintenancesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAssignedMaintenancesInput
    upsert?: StaffProfileUpsertWithoutAssignedMaintenancesInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutAssignedMaintenancesInput, StaffProfileUpdateWithoutAssignedMaintenancesInput>, StaffProfileUncheckedUpdateWithoutAssignedMaintenancesInput>
  }

  export type MediaUpdateManyWithoutMaintenanceImagesNestedInput = {
    create?: XOR<MediaCreateWithoutMaintenanceImagesInput, MediaUncheckedCreateWithoutMaintenanceImagesInput> | MediaCreateWithoutMaintenanceImagesInput[] | MediaUncheckedCreateWithoutMaintenanceImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutMaintenanceImagesInput | MediaCreateOrConnectWithoutMaintenanceImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutMaintenanceImagesInput | MediaUpsertWithWhereUniqueWithoutMaintenanceImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutMaintenanceImagesInput | MediaUpdateWithWhereUniqueWithoutMaintenanceImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutMaintenanceImagesInput | MediaUpdateManyWithWhereWithoutMaintenanceImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutMaintenanceImagesNestedInput = {
    create?: XOR<MediaCreateWithoutMaintenanceImagesInput, MediaUncheckedCreateWithoutMaintenanceImagesInput> | MediaCreateWithoutMaintenanceImagesInput[] | MediaUncheckedCreateWithoutMaintenanceImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutMaintenanceImagesInput | MediaCreateOrConnectWithoutMaintenanceImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutMaintenanceImagesInput | MediaUpsertWithWhereUniqueWithoutMaintenanceImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutMaintenanceImagesInput | MediaUpdateWithWhereUniqueWithoutMaintenanceImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutMaintenanceImagesInput | MediaUpdateManyWithWhereWithoutMaintenanceImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type StudentProfileCreateNestedOneWithoutRoomTransfersInput = {
    create?: XOR<StudentProfileCreateWithoutRoomTransfersInput, StudentProfileUncheckedCreateWithoutRoomTransfersInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRoomTransfersInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutFromTransfersInput = {
    create?: XOR<RoomCreateWithoutFromTransfersInput, RoomUncheckedCreateWithoutFromTransfersInput>
    connectOrCreate?: RoomCreateOrConnectWithoutFromTransfersInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutToTransfersInput = {
    create?: XOR<RoomCreateWithoutToTransfersInput, RoomUncheckedCreateWithoutToTransfersInput>
    connectOrCreate?: RoomCreateOrConnectWithoutToTransfersInput
    connect?: RoomWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutApprovedTransfersInput = {
    create?: XOR<StaffProfileCreateWithoutApprovedTransfersInput, StaffProfileUncheckedCreateWithoutApprovedTransfersInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutApprovedTransfersInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type StudentProfileUpdateOneRequiredWithoutRoomTransfersNestedInput = {
    create?: XOR<StudentProfileCreateWithoutRoomTransfersInput, StudentProfileUncheckedCreateWithoutRoomTransfersInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRoomTransfersInput
    upsert?: StudentProfileUpsertWithoutRoomTransfersInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutRoomTransfersInput, StudentProfileUpdateWithoutRoomTransfersInput>, StudentProfileUncheckedUpdateWithoutRoomTransfersInput>
  }

  export type RoomUpdateOneWithoutFromTransfersNestedInput = {
    create?: XOR<RoomCreateWithoutFromTransfersInput, RoomUncheckedCreateWithoutFromTransfersInput>
    connectOrCreate?: RoomCreateOrConnectWithoutFromTransfersInput
    upsert?: RoomUpsertWithoutFromTransfersInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutFromTransfersInput, RoomUpdateWithoutFromTransfersInput>, RoomUncheckedUpdateWithoutFromTransfersInput>
  }

  export type RoomUpdateOneRequiredWithoutToTransfersNestedInput = {
    create?: XOR<RoomCreateWithoutToTransfersInput, RoomUncheckedCreateWithoutToTransfersInput>
    connectOrCreate?: RoomCreateOrConnectWithoutToTransfersInput
    upsert?: RoomUpsertWithoutToTransfersInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutToTransfersInput, RoomUpdateWithoutToTransfersInput>, RoomUncheckedUpdateWithoutToTransfersInput>
  }

  export type StaffProfileUpdateOneWithoutApprovedTransfersNestedInput = {
    create?: XOR<StaffProfileCreateWithoutApprovedTransfersInput, StaffProfileUncheckedCreateWithoutApprovedTransfersInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutApprovedTransfersInput
    upsert?: StaffProfileUpsertWithoutApprovedTransfersInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutApprovedTransfersInput, StaffProfileUpdateWithoutApprovedTransfersInput>, StaffProfileUncheckedUpdateWithoutApprovedTransfersInput>
  }

  export type StudentProfileCreateNestedOneWithoutVehicleRegistrationsInput = {
    create?: XOR<StudentProfileCreateWithoutVehicleRegistrationsInput, StudentProfileUncheckedCreateWithoutVehicleRegistrationsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutVehicleRegistrationsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutVehicleImagesInput = {
    create?: XOR<MediaCreateWithoutVehicleImagesInput, MediaUncheckedCreateWithoutVehicleImagesInput> | MediaCreateWithoutVehicleImagesInput[] | MediaUncheckedCreateWithoutVehicleImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVehicleImagesInput | MediaCreateOrConnectWithoutVehicleImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutVehicleImagesInput = {
    create?: XOR<MediaCreateWithoutVehicleImagesInput, MediaUncheckedCreateWithoutVehicleImagesInput> | MediaCreateWithoutVehicleImagesInput[] | MediaUncheckedCreateWithoutVehicleImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVehicleImagesInput | MediaCreateOrConnectWithoutVehicleImagesInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type EnumVehicleTypeFieldUpdateOperationsInput = {
    set?: $Enums.VehicleType
  }

  export type StudentProfileUpdateOneRequiredWithoutVehicleRegistrationsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutVehicleRegistrationsInput, StudentProfileUncheckedCreateWithoutVehicleRegistrationsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutVehicleRegistrationsInput
    upsert?: StudentProfileUpsertWithoutVehicleRegistrationsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutVehicleRegistrationsInput, StudentProfileUpdateWithoutVehicleRegistrationsInput>, StudentProfileUncheckedUpdateWithoutVehicleRegistrationsInput>
  }

  export type MediaUpdateManyWithoutVehicleImagesNestedInput = {
    create?: XOR<MediaCreateWithoutVehicleImagesInput, MediaUncheckedCreateWithoutVehicleImagesInput> | MediaCreateWithoutVehicleImagesInput[] | MediaUncheckedCreateWithoutVehicleImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVehicleImagesInput | MediaCreateOrConnectWithoutVehicleImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutVehicleImagesInput | MediaUpsertWithWhereUniqueWithoutVehicleImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutVehicleImagesInput | MediaUpdateWithWhereUniqueWithoutVehicleImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutVehicleImagesInput | MediaUpdateManyWithWhereWithoutVehicleImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutVehicleImagesNestedInput = {
    create?: XOR<MediaCreateWithoutVehicleImagesInput, MediaUncheckedCreateWithoutVehicleImagesInput> | MediaCreateWithoutVehicleImagesInput[] | MediaUncheckedCreateWithoutVehicleImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVehicleImagesInput | MediaCreateOrConnectWithoutVehicleImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutVehicleImagesInput | MediaUpsertWithWhereUniqueWithoutVehicleImagesInput[]
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutVehicleImagesInput | MediaUpdateWithWhereUniqueWithoutVehicleImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutVehicleImagesInput | MediaUpdateManyWithWhereWithoutVehicleImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutAvatarInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput> | UserCreateWithoutAvatarInput[] | UserUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput | UserCreateOrConnectWithoutAvatarInput[]
    createMany?: UserCreateManyAvatarInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutImagesInput = {
    create?: XOR<RoomCreateWithoutImagesInput, RoomUncheckedCreateWithoutImagesInput> | RoomCreateWithoutImagesInput[] | RoomUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutImagesInput | RoomCreateOrConnectWithoutImagesInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type BuildingCreateNestedManyWithoutImagesInput = {
    create?: XOR<BuildingCreateWithoutImagesInput, BuildingUncheckedCreateWithoutImagesInput> | BuildingCreateWithoutImagesInput[] | BuildingUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutImagesInput | BuildingCreateOrConnectWithoutImagesInput[]
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
  }

  export type VehicleRegistrationCreateNestedManyWithoutImagesInput = {
    create?: XOR<VehicleRegistrationCreateWithoutImagesInput, VehicleRegistrationUncheckedCreateWithoutImagesInput> | VehicleRegistrationCreateWithoutImagesInput[] | VehicleRegistrationUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutImagesInput | VehicleRegistrationCreateOrConnectWithoutImagesInput[]
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutImagesInput = {
    create?: XOR<MaintenanceCreateWithoutImagesInput, MaintenanceUncheckedCreateWithoutImagesInput> | MaintenanceCreateWithoutImagesInput[] | MaintenanceUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutImagesInput | MaintenanceCreateOrConnectWithoutImagesInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAvatarInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput> | UserCreateWithoutAvatarInput[] | UserUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput | UserCreateOrConnectWithoutAvatarInput[]
    createMany?: UserCreateManyAvatarInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutImagesInput = {
    create?: XOR<RoomCreateWithoutImagesInput, RoomUncheckedCreateWithoutImagesInput> | RoomCreateWithoutImagesInput[] | RoomUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutImagesInput | RoomCreateOrConnectWithoutImagesInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type BuildingUncheckedCreateNestedManyWithoutImagesInput = {
    create?: XOR<BuildingCreateWithoutImagesInput, BuildingUncheckedCreateWithoutImagesInput> | BuildingCreateWithoutImagesInput[] | BuildingUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutImagesInput | BuildingCreateOrConnectWithoutImagesInput[]
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
  }

  export type VehicleRegistrationUncheckedCreateNestedManyWithoutImagesInput = {
    create?: XOR<VehicleRegistrationCreateWithoutImagesInput, VehicleRegistrationUncheckedCreateWithoutImagesInput> | VehicleRegistrationCreateWithoutImagesInput[] | VehicleRegistrationUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutImagesInput | VehicleRegistrationCreateOrConnectWithoutImagesInput[]
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutImagesInput = {
    create?: XOR<MaintenanceCreateWithoutImagesInput, MaintenanceUncheckedCreateWithoutImagesInput> | MaintenanceCreateWithoutImagesInput[] | MaintenanceUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutImagesInput | MaintenanceCreateOrConnectWithoutImagesInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type UserUpdateManyWithoutAvatarNestedInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput> | UserCreateWithoutAvatarInput[] | UserUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput | UserCreateOrConnectWithoutAvatarInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAvatarInput | UserUpsertWithWhereUniqueWithoutAvatarInput[]
    createMany?: UserCreateManyAvatarInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAvatarInput | UserUpdateWithWhereUniqueWithoutAvatarInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAvatarInput | UserUpdateManyWithWhereWithoutAvatarInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutImagesNestedInput = {
    create?: XOR<RoomCreateWithoutImagesInput, RoomUncheckedCreateWithoutImagesInput> | RoomCreateWithoutImagesInput[] | RoomUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutImagesInput | RoomCreateOrConnectWithoutImagesInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutImagesInput | RoomUpsertWithWhereUniqueWithoutImagesInput[]
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutImagesInput | RoomUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutImagesInput | RoomUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BuildingUpdateManyWithoutImagesNestedInput = {
    create?: XOR<BuildingCreateWithoutImagesInput, BuildingUncheckedCreateWithoutImagesInput> | BuildingCreateWithoutImagesInput[] | BuildingUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutImagesInput | BuildingCreateOrConnectWithoutImagesInput[]
    upsert?: BuildingUpsertWithWhereUniqueWithoutImagesInput | BuildingUpsertWithWhereUniqueWithoutImagesInput[]
    set?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    disconnect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    delete?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    update?: BuildingUpdateWithWhereUniqueWithoutImagesInput | BuildingUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: BuildingUpdateManyWithWhereWithoutImagesInput | BuildingUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
  }

  export type VehicleRegistrationUpdateManyWithoutImagesNestedInput = {
    create?: XOR<VehicleRegistrationCreateWithoutImagesInput, VehicleRegistrationUncheckedCreateWithoutImagesInput> | VehicleRegistrationCreateWithoutImagesInput[] | VehicleRegistrationUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutImagesInput | VehicleRegistrationCreateOrConnectWithoutImagesInput[]
    upsert?: VehicleRegistrationUpsertWithWhereUniqueWithoutImagesInput | VehicleRegistrationUpsertWithWhereUniqueWithoutImagesInput[]
    set?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    disconnect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    delete?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    update?: VehicleRegistrationUpdateWithWhereUniqueWithoutImagesInput | VehicleRegistrationUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: VehicleRegistrationUpdateManyWithWhereWithoutImagesInput | VehicleRegistrationUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: VehicleRegistrationScalarWhereInput | VehicleRegistrationScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutImagesNestedInput = {
    create?: XOR<MaintenanceCreateWithoutImagesInput, MaintenanceUncheckedCreateWithoutImagesInput> | MaintenanceCreateWithoutImagesInput[] | MaintenanceUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutImagesInput | MaintenanceCreateOrConnectWithoutImagesInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutImagesInput | MaintenanceUpsertWithWhereUniqueWithoutImagesInput[]
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutImagesInput | MaintenanceUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutImagesInput | MaintenanceUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAvatarNestedInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput> | UserCreateWithoutAvatarInput[] | UserUncheckedCreateWithoutAvatarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput | UserCreateOrConnectWithoutAvatarInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAvatarInput | UserUpsertWithWhereUniqueWithoutAvatarInput[]
    createMany?: UserCreateManyAvatarInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAvatarInput | UserUpdateWithWhereUniqueWithoutAvatarInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAvatarInput | UserUpdateManyWithWhereWithoutAvatarInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutImagesNestedInput = {
    create?: XOR<RoomCreateWithoutImagesInput, RoomUncheckedCreateWithoutImagesInput> | RoomCreateWithoutImagesInput[] | RoomUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutImagesInput | RoomCreateOrConnectWithoutImagesInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutImagesInput | RoomUpsertWithWhereUniqueWithoutImagesInput[]
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutImagesInput | RoomUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutImagesInput | RoomUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BuildingUncheckedUpdateManyWithoutImagesNestedInput = {
    create?: XOR<BuildingCreateWithoutImagesInput, BuildingUncheckedCreateWithoutImagesInput> | BuildingCreateWithoutImagesInput[] | BuildingUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutImagesInput | BuildingCreateOrConnectWithoutImagesInput[]
    upsert?: BuildingUpsertWithWhereUniqueWithoutImagesInput | BuildingUpsertWithWhereUniqueWithoutImagesInput[]
    set?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    disconnect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    delete?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    update?: BuildingUpdateWithWhereUniqueWithoutImagesInput | BuildingUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: BuildingUpdateManyWithWhereWithoutImagesInput | BuildingUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
  }

  export type VehicleRegistrationUncheckedUpdateManyWithoutImagesNestedInput = {
    create?: XOR<VehicleRegistrationCreateWithoutImagesInput, VehicleRegistrationUncheckedCreateWithoutImagesInput> | VehicleRegistrationCreateWithoutImagesInput[] | VehicleRegistrationUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: VehicleRegistrationCreateOrConnectWithoutImagesInput | VehicleRegistrationCreateOrConnectWithoutImagesInput[]
    upsert?: VehicleRegistrationUpsertWithWhereUniqueWithoutImagesInput | VehicleRegistrationUpsertWithWhereUniqueWithoutImagesInput[]
    set?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    disconnect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    delete?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    connect?: VehicleRegistrationWhereUniqueInput | VehicleRegistrationWhereUniqueInput[]
    update?: VehicleRegistrationUpdateWithWhereUniqueWithoutImagesInput | VehicleRegistrationUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: VehicleRegistrationUpdateManyWithWhereWithoutImagesInput | VehicleRegistrationUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: VehicleRegistrationScalarWhereInput | VehicleRegistrationScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutImagesNestedInput = {
    create?: XOR<MaintenanceCreateWithoutImagesInput, MaintenanceUncheckedCreateWithoutImagesInput> | MaintenanceCreateWithoutImagesInput[] | MaintenanceUncheckedCreateWithoutImagesInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutImagesInput | MaintenanceCreateOrConnectWithoutImagesInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutImagesInput | MaintenanceUpsertWithWhereUniqueWithoutImagesInput[]
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutImagesInput | MaintenanceUpdateWithWhereUniqueWithoutImagesInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutImagesInput | MaintenanceUpdateManyWithWhereWithoutImagesInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLoginLogsInput = {
    create?: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLoginLogsNestedInput = {
    create?: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginLogsInput
    upsert?: UserUpsertWithoutLoginLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginLogsInput, UserUpdateWithoutLoginLogsInput>, UserUncheckedUpdateWithoutLoginLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type NestedEnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumFeeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeFilter<$PrismaModel> | $Enums.FeeType
  }

  export type NestedEnumVehicleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVehicleTypeNullableFilter<$PrismaModel> | $Enums.VehicleType | null
  }

  export type NestedEnumFeeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeFilter<$PrismaModel>
  }

  export type NestedEnumVehicleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVehicleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumUtilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UtilityType | EnumUtilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUtilityTypeFilter<$PrismaModel> | $Enums.UtilityType
  }

  export type NestedEnumUtilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UtilityType | EnumUtilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UtilityType[] | ListEnumUtilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUtilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.UtilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUtilityTypeFilter<$PrismaModel>
    _max?: NestedEnumUtilityTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedEnumVehicleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeFilter<$PrismaModel> | $Enums.VehicleType
  }

  export type NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type MediaCreateWithoutAvatarForInput = {
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomImages?: RoomCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceCreateNestedManyWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutAvatarForInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomImages?: RoomUncheckedCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingUncheckedCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationUncheckedCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceUncheckedCreateNestedManyWithoutImagesInput
  }

  export type MediaCreateOrConnectWithoutAvatarForInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutAvatarForInput, MediaUncheckedCreateWithoutAvatarForInput>
  }

  export type StaffProfileCreateWithoutUserInput = {
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managedBuilding?: BuildingCreateNestedOneWithoutStaffInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToInput
    approvedTransfers?: RoomTransferCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    managedBuildingId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToInput
    approvedTransfers?: RoomTransferUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileCreateOrConnectWithoutUserInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
  }

  export type StudentProfileCreateWithoutUserInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room?: RoomCreateNestedOneWithoutResidentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutUserInput = {
    id?: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutUserInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
  }

  export type LoginLogCreateWithoutUserInput = {
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    location?: string | null
  }

  export type LoginLogUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    location?: string | null
  }

  export type LoginLogCreateOrConnectWithoutUserInput = {
    where: LoginLogWhereUniqueInput
    create: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput>
  }

  export type LoginLogCreateManyUserInputEnvelope = {
    data: LoginLogCreateManyUserInput | LoginLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutAvatarForInput = {
    update: XOR<MediaUpdateWithoutAvatarForInput, MediaUncheckedUpdateWithoutAvatarForInput>
    create: XOR<MediaCreateWithoutAvatarForInput, MediaUncheckedCreateWithoutAvatarForInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutAvatarForInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutAvatarForInput, MediaUncheckedUpdateWithoutAvatarForInput>
  }

  export type MediaUpdateWithoutAvatarForInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomImages?: RoomUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutAvatarForInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomImages?: RoomUncheckedUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUncheckedUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUncheckedUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type StaffProfileUpsertWithoutUserInput = {
    update: XOR<StaffProfileUpdateWithoutUserInput, StaffProfileUncheckedUpdateWithoutUserInput>
    create: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutUserInput, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type StaffProfileUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managedBuilding?: BuildingUpdateOneWithoutStaffNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToNestedInput
    approvedTransfers?: RoomTransferUpdateManyWithoutApprovedByNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    managedBuildingId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToNestedInput
    approvedTransfers?: RoomTransferUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type StudentProfileUpsertWithoutUserInput = {
    update: XOR<StudentProfileUpdateWithoutUserInput, StudentProfileUncheckedUpdateWithoutUserInput>
    create: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutUserInput, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUpdateWithoutUserInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneWithoutResidentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type LoginLogUpsertWithWhereUniqueWithoutUserInput = {
    where: LoginLogWhereUniqueInput
    update: XOR<LoginLogUpdateWithoutUserInput, LoginLogUncheckedUpdateWithoutUserInput>
    create: XOR<LoginLogCreateWithoutUserInput, LoginLogUncheckedCreateWithoutUserInput>
  }

  export type LoginLogUpdateWithWhereUniqueWithoutUserInput = {
    where: LoginLogWhereUniqueInput
    data: XOR<LoginLogUpdateWithoutUserInput, LoginLogUncheckedUpdateWithoutUserInput>
  }

  export type LoginLogUpdateManyWithWhereWithoutUserInput = {
    where: LoginLogScalarWhereInput
    data: XOR<LoginLogUpdateManyMutationInput, LoginLogUncheckedUpdateManyWithoutUserInput>
  }

  export type LoginLogScalarWhereInput = {
    AND?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
    OR?: LoginLogScalarWhereInput[]
    NOT?: LoginLogScalarWhereInput | LoginLogScalarWhereInput[]
    id?: IntFilter<"LoginLog"> | number
    userId?: IntFilter<"LoginLog"> | number
    timestamp?: DateTimeFilter<"LoginLog"> | Date | string
    ipAddress?: StringNullableFilter<"LoginLog"> | string | null
    userAgent?: StringNullableFilter<"LoginLog"> | string | null
    status?: StringFilter<"LoginLog"> | string
    location?: StringNullableFilter<"LoginLog"> | string | null
  }

  export type UserCreateWithoutStaffProfileInput = {
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatar?: MediaCreateNestedOneWithoutAvatarForInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffProfileInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatarId?: number | null
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
  }

  export type BuildingCreateWithoutStaffInput = {
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutBuildingImagesInput
    rooms?: RoomCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateWithoutStaffInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutBuildingImagesInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingCreateOrConnectWithoutStaffInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutStaffInput, BuildingUncheckedCreateWithoutStaffInput>
  }

  export type MaintenanceCreateWithoutAssignedToInput = {
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMaintenancesInput
    reportedBy: StudentProfileCreateNestedOneWithoutReportedMaintenancesInput
    images?: MediaCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceUncheckedCreateWithoutAssignedToInput = {
    id?: number
    roomId: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceCreateOrConnectWithoutAssignedToInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutAssignedToInput, MaintenanceUncheckedCreateWithoutAssignedToInput>
  }

  export type MaintenanceCreateManyAssignedToInputEnvelope = {
    data: MaintenanceCreateManyAssignedToInput | MaintenanceCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type RoomTransferCreateWithoutApprovedByInput = {
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutRoomTransfersInput
    fromRoom?: RoomCreateNestedOneWithoutFromTransfersInput
    toRoom: RoomCreateNestedOneWithoutToTransfersInput
  }

  export type RoomTransferUncheckedCreateWithoutApprovedByInput = {
    id?: number
    studentProfileId: number
    fromRoomId?: number | null
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateOrConnectWithoutApprovedByInput = {
    where: RoomTransferWhereUniqueInput
    create: XOR<RoomTransferCreateWithoutApprovedByInput, RoomTransferUncheckedCreateWithoutApprovedByInput>
  }

  export type RoomTransferCreateManyApprovedByInputEnvelope = {
    data: RoomTransferCreateManyApprovedByInput | RoomTransferCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStaffProfileInput = {
    update: XOR<UserUpdateWithoutStaffProfileInput, UserUncheckedUpdateWithoutStaffProfileInput>
    create: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffProfileInput, UserUncheckedUpdateWithoutStaffProfileInput>
  }

  export type UserUpdateWithoutStaffProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: MediaUpdateOneWithoutAvatarForNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BuildingUpsertWithoutStaffInput = {
    update: XOR<BuildingUpdateWithoutStaffInput, BuildingUncheckedUpdateWithoutStaffInput>
    create: XOR<BuildingCreateWithoutStaffInput, BuildingUncheckedCreateWithoutStaffInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutStaffInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutStaffInput, BuildingUncheckedUpdateWithoutStaffInput>
  }

  export type BuildingUpdateWithoutStaffInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutBuildingImagesNestedInput
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutBuildingImagesNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutAssignedToInput, MaintenanceUncheckedUpdateWithoutAssignedToInput>
    create: XOR<MaintenanceCreateWithoutAssignedToInput, MaintenanceUncheckedCreateWithoutAssignedToInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutAssignedToInput, MaintenanceUncheckedUpdateWithoutAssignedToInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutAssignedToInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type MaintenanceScalarWhereInput = {
    AND?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    OR?: MaintenanceScalarWhereInput[]
    NOT?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    id?: IntFilter<"Maintenance"> | number
    roomId?: IntFilter<"Maintenance"> | number
    reportedById?: IntFilter<"Maintenance"> | number
    issue?: StringFilter<"Maintenance"> | string
    reportDate?: DateTimeFilter<"Maintenance"> | Date | string
    status?: EnumMaintenanceStatusFilter<"Maintenance"> | $Enums.MaintenanceStatus
    assignedToId?: IntNullableFilter<"Maintenance"> | number | null
    completedDate?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    notes?: StringNullableFilter<"Maintenance"> | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
  }

  export type RoomTransferUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: RoomTransferWhereUniqueInput
    update: XOR<RoomTransferUpdateWithoutApprovedByInput, RoomTransferUncheckedUpdateWithoutApprovedByInput>
    create: XOR<RoomTransferCreateWithoutApprovedByInput, RoomTransferUncheckedCreateWithoutApprovedByInput>
  }

  export type RoomTransferUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: RoomTransferWhereUniqueInput
    data: XOR<RoomTransferUpdateWithoutApprovedByInput, RoomTransferUncheckedUpdateWithoutApprovedByInput>
  }

  export type RoomTransferUpdateManyWithWhereWithoutApprovedByInput = {
    where: RoomTransferScalarWhereInput
    data: XOR<RoomTransferUpdateManyMutationInput, RoomTransferUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type RoomTransferScalarWhereInput = {
    AND?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
    OR?: RoomTransferScalarWhereInput[]
    NOT?: RoomTransferScalarWhereInput | RoomTransferScalarWhereInput[]
    id?: IntFilter<"RoomTransfer"> | number
    studentProfileId?: IntFilter<"RoomTransfer"> | number
    fromRoomId?: IntNullableFilter<"RoomTransfer"> | number | null
    toRoomId?: IntFilter<"RoomTransfer"> | number
    transferDate?: DateTimeFilter<"RoomTransfer"> | Date | string
    reason?: StringNullableFilter<"RoomTransfer"> | string | null
    adminNotes?: StringNullableFilter<"RoomTransfer"> | string | null
    approvedById?: IntNullableFilter<"RoomTransfer"> | number | null
    status?: EnumTransferStatusFilter<"RoomTransfer"> | $Enums.TransferStatus
    createdAt?: DateTimeFilter<"RoomTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"RoomTransfer"> | Date | string
  }

  export type UserCreateWithoutStudentProfileInput = {
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatar?: MediaCreateNestedOneWithoutAvatarForInput
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatarId?: number | null
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
  }

  export type RoomCreateWithoutResidentsInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutResidentsInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutResidentsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutResidentsInput, RoomUncheckedCreateWithoutResidentsInput>
  }

  export type InvoiceCreateWithoutStudentProfileInput = {
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room?: RoomCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    roomId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutStudentProfileInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutStudentProfileInput, InvoiceUncheckedCreateWithoutStudentProfileInput>
  }

  export type InvoiceCreateManyStudentProfileInputEnvelope = {
    data: InvoiceCreateManyStudentProfileInput | InvoiceCreateManyStudentProfileInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutStudentProfileInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    invoiceId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutStudentProfileInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStudentProfileInput, PaymentUncheckedCreateWithoutStudentProfileInput>
  }

  export type PaymentCreateManyStudentProfileInputEnvelope = {
    data: PaymentCreateManyStudentProfileInput | PaymentCreateManyStudentProfileInput[]
    skipDuplicates?: boolean
  }

  export type RoomTransferCreateWithoutStudentProfileInput = {
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fromRoom?: RoomCreateNestedOneWithoutFromTransfersInput
    toRoom: RoomCreateNestedOneWithoutToTransfersInput
    approvedBy?: StaffProfileCreateNestedOneWithoutApprovedTransfersInput
  }

  export type RoomTransferUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    fromRoomId?: number | null
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateOrConnectWithoutStudentProfileInput = {
    where: RoomTransferWhereUniqueInput
    create: XOR<RoomTransferCreateWithoutStudentProfileInput, RoomTransferUncheckedCreateWithoutStudentProfileInput>
  }

  export type RoomTransferCreateManyStudentProfileInputEnvelope = {
    data: RoomTransferCreateManyStudentProfileInput | RoomTransferCreateManyStudentProfileInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutReportedByInput = {
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMaintenancesInput
    assignedTo?: StaffProfileCreateNestedOneWithoutAssignedMaintenancesInput
    images?: MediaCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceUncheckedCreateWithoutReportedByInput = {
    id?: number
    roomId: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceCreateOrConnectWithoutReportedByInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutReportedByInput, MaintenanceUncheckedCreateWithoutReportedByInput>
  }

  export type MaintenanceCreateManyReportedByInputEnvelope = {
    data: MaintenanceCreateManyReportedByInput | MaintenanceCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type VehicleRegistrationCreateWithoutStudentProfileInput = {
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutVehicleImagesInput
  }

  export type VehicleRegistrationUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutVehicleImagesInput
  }

  export type VehicleRegistrationCreateOrConnectWithoutStudentProfileInput = {
    where: VehicleRegistrationWhereUniqueInput
    create: XOR<VehicleRegistrationCreateWithoutStudentProfileInput, VehicleRegistrationUncheckedCreateWithoutStudentProfileInput>
  }

  export type VehicleRegistrationCreateManyStudentProfileInputEnvelope = {
    data: VehicleRegistrationCreateManyStudentProfileInput | VehicleRegistrationCreateManyStudentProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentProfileInput = {
    update: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type UserUpdateWithoutStudentProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: MediaUpdateOneWithoutAvatarForNestedInput
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoomUpsertWithoutResidentsInput = {
    update: XOR<RoomUpdateWithoutResidentsInput, RoomUncheckedUpdateWithoutResidentsInput>
    create: XOR<RoomCreateWithoutResidentsInput, RoomUncheckedCreateWithoutResidentsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutResidentsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutResidentsInput, RoomUncheckedUpdateWithoutResidentsInput>
  }

  export type RoomUpdateWithoutResidentsInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutResidentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutStudentProfileInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutStudentProfileInput, InvoiceUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<InvoiceCreateWithoutStudentProfileInput, InvoiceUncheckedCreateWithoutStudentProfileInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutStudentProfileInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutStudentProfileInput, InvoiceUncheckedUpdateWithoutStudentProfileInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutStudentProfileInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutStudentProfileInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    studentProfileId?: IntNullableFilter<"Invoice"> | number | null
    roomId?: IntNullableFilter<"Invoice"> | number | null
    billingMonth?: IntFilter<"Invoice"> | number
    billingYear?: IntFilter<"Invoice"> | number
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paymentDeadline?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutStudentProfileInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutStudentProfileInput, PaymentUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<PaymentCreateWithoutStudentProfileInput, PaymentUncheckedCreateWithoutStudentProfileInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutStudentProfileInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutStudentProfileInput, PaymentUncheckedUpdateWithoutStudentProfileInput>
  }

  export type PaymentUpdateManyWithWhereWithoutStudentProfileInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutStudentProfileInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    studentProfileId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    transactionCode?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type RoomTransferUpsertWithWhereUniqueWithoutStudentProfileInput = {
    where: RoomTransferWhereUniqueInput
    update: XOR<RoomTransferUpdateWithoutStudentProfileInput, RoomTransferUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<RoomTransferCreateWithoutStudentProfileInput, RoomTransferUncheckedCreateWithoutStudentProfileInput>
  }

  export type RoomTransferUpdateWithWhereUniqueWithoutStudentProfileInput = {
    where: RoomTransferWhereUniqueInput
    data: XOR<RoomTransferUpdateWithoutStudentProfileInput, RoomTransferUncheckedUpdateWithoutStudentProfileInput>
  }

  export type RoomTransferUpdateManyWithWhereWithoutStudentProfileInput = {
    where: RoomTransferScalarWhereInput
    data: XOR<RoomTransferUpdateManyMutationInput, RoomTransferUncheckedUpdateManyWithoutStudentProfileInput>
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutReportedByInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutReportedByInput, MaintenanceUncheckedUpdateWithoutReportedByInput>
    create: XOR<MaintenanceCreateWithoutReportedByInput, MaintenanceUncheckedCreateWithoutReportedByInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutReportedByInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutReportedByInput, MaintenanceUncheckedUpdateWithoutReportedByInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutReportedByInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutReportedByInput>
  }

  export type VehicleRegistrationUpsertWithWhereUniqueWithoutStudentProfileInput = {
    where: VehicleRegistrationWhereUniqueInput
    update: XOR<VehicleRegistrationUpdateWithoutStudentProfileInput, VehicleRegistrationUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<VehicleRegistrationCreateWithoutStudentProfileInput, VehicleRegistrationUncheckedCreateWithoutStudentProfileInput>
  }

  export type VehicleRegistrationUpdateWithWhereUniqueWithoutStudentProfileInput = {
    where: VehicleRegistrationWhereUniqueInput
    data: XOR<VehicleRegistrationUpdateWithoutStudentProfileInput, VehicleRegistrationUncheckedUpdateWithoutStudentProfileInput>
  }

  export type VehicleRegistrationUpdateManyWithWhereWithoutStudentProfileInput = {
    where: VehicleRegistrationScalarWhereInput
    data: XOR<VehicleRegistrationUpdateManyMutationInput, VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileInput>
  }

  export type VehicleRegistrationScalarWhereInput = {
    AND?: VehicleRegistrationScalarWhereInput | VehicleRegistrationScalarWhereInput[]
    OR?: VehicleRegistrationScalarWhereInput[]
    NOT?: VehicleRegistrationScalarWhereInput | VehicleRegistrationScalarWhereInput[]
    id?: IntFilter<"VehicleRegistration"> | number
    studentProfileId?: IntFilter<"VehicleRegistration"> | number
    vehicleType?: EnumVehicleTypeFilter<"VehicleRegistration"> | $Enums.VehicleType
    licensePlate?: StringFilter<"VehicleRegistration"> | string
    brand?: StringNullableFilter<"VehicleRegistration"> | string | null
    model?: StringNullableFilter<"VehicleRegistration"> | string | null
    color?: StringNullableFilter<"VehicleRegistration"> | string | null
    parkingCardNo?: StringNullableFilter<"VehicleRegistration"> | string | null
    isActive?: BoolFilter<"VehicleRegistration"> | boolean
    startDate?: DateTimeFilter<"VehicleRegistration"> | Date | string
    endDate?: DateTimeNullableFilter<"VehicleRegistration"> | Date | string | null
    notes?: StringNullableFilter<"VehicleRegistration"> | string | null
    createdAt?: DateTimeFilter<"VehicleRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleRegistration"> | Date | string
  }

  export type MediaCreateWithoutBuildingImagesInput = {
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserCreateNestedManyWithoutAvatarInput
    roomImages?: RoomCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceCreateNestedManyWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutBuildingImagesInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserUncheckedCreateNestedManyWithoutAvatarInput
    roomImages?: RoomUncheckedCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationUncheckedCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceUncheckedCreateNestedManyWithoutImagesInput
  }

  export type MediaCreateOrConnectWithoutBuildingImagesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutBuildingImagesInput, MediaUncheckedCreateWithoutBuildingImagesInput>
  }

  export type RoomCreateWithoutBuildingInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutBuildingInput = {
    id?: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomCreateManyBuildingInputEnvelope = {
    data: RoomCreateManyBuildingInput | RoomCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type StaffProfileCreateWithoutManagedBuildingInput = {
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToInput
    approvedTransfers?: RoomTransferCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileUncheckedCreateWithoutManagedBuildingInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToInput
    approvedTransfers?: RoomTransferUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileCreateOrConnectWithoutManagedBuildingInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutManagedBuildingInput, StaffProfileUncheckedCreateWithoutManagedBuildingInput>
  }

  export type StaffProfileCreateManyManagedBuildingInputEnvelope = {
    data: StaffProfileCreateManyManagedBuildingInput | StaffProfileCreateManyManagedBuildingInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithWhereUniqueWithoutBuildingImagesInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutBuildingImagesInput, MediaUncheckedUpdateWithoutBuildingImagesInput>
    create: XOR<MediaCreateWithoutBuildingImagesInput, MediaUncheckedCreateWithoutBuildingImagesInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutBuildingImagesInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutBuildingImagesInput, MediaUncheckedUpdateWithoutBuildingImagesInput>
  }

  export type MediaUpdateManyWithWhereWithoutBuildingImagesInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutBuildingImagesInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: IntFilter<"Media"> | number
    filename?: StringFilter<"Media"> | string
    path?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    mediaType?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    uploadedAt?: DateTimeFilter<"Media"> | Date | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
  }

  export type RoomUpdateManyWithWhereWithoutBuildingInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutBuildingInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    buildingId?: IntFilter<"Room"> | number
    number?: StringFilter<"Room"> | string
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    capacity?: IntFilter<"Room"> | number
    actualOccupancy?: IntFilter<"Room"> | number
    floor?: IntFilter<"Room"> | number
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    description?: StringNullableFilter<"Room"> | string | null
    roomFee?: DecimalFilter<"Room"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type StaffProfileUpsertWithWhereUniqueWithoutManagedBuildingInput = {
    where: StaffProfileWhereUniqueInput
    update: XOR<StaffProfileUpdateWithoutManagedBuildingInput, StaffProfileUncheckedUpdateWithoutManagedBuildingInput>
    create: XOR<StaffProfileCreateWithoutManagedBuildingInput, StaffProfileUncheckedCreateWithoutManagedBuildingInput>
  }

  export type StaffProfileUpdateWithWhereUniqueWithoutManagedBuildingInput = {
    where: StaffProfileWhereUniqueInput
    data: XOR<StaffProfileUpdateWithoutManagedBuildingInput, StaffProfileUncheckedUpdateWithoutManagedBuildingInput>
  }

  export type StaffProfileUpdateManyWithWhereWithoutManagedBuildingInput = {
    where: StaffProfileScalarWhereInput
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyWithoutManagedBuildingInput>
  }

  export type StaffProfileScalarWhereInput = {
    AND?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
    OR?: StaffProfileScalarWhereInput[]
    NOT?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
    id?: IntFilter<"StaffProfile"> | number
    userId?: IntFilter<"StaffProfile"> | number
    fullName?: StringFilter<"StaffProfile"> | string
    phoneNumber?: StringNullableFilter<"StaffProfile"> | string | null
    position?: StringNullableFilter<"StaffProfile"> | string | null
    identityCardNumber?: StringNullableFilter<"StaffProfile"> | string | null
    gender?: EnumGenderNullableFilter<"StaffProfile"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"StaffProfile"> | Date | string | null
    address?: StringNullableFilter<"StaffProfile"> | string | null
    managedBuildingId?: IntNullableFilter<"StaffProfile"> | number | null
    createdAt?: DateTimeFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StaffProfile"> | Date | string
  }

  export type BuildingCreateWithoutRoomsInput = {
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutBuildingImagesInput
    staff?: StaffProfileCreateNestedManyWithoutManagedBuildingInput
  }

  export type BuildingUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutBuildingImagesInput
    staff?: StaffProfileUncheckedCreateNestedManyWithoutManagedBuildingInput
  }

  export type BuildingCreateOrConnectWithoutRoomsInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
  }

  export type MediaCreateWithoutRoomImagesInput = {
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserCreateNestedManyWithoutAvatarInput
    buildingImages?: BuildingCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceCreateNestedManyWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutRoomImagesInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserUncheckedCreateNestedManyWithoutAvatarInput
    buildingImages?: BuildingUncheckedCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationUncheckedCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceUncheckedCreateNestedManyWithoutImagesInput
  }

  export type MediaCreateOrConnectWithoutRoomImagesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutRoomImagesInput, MediaUncheckedCreateWithoutRoomImagesInput>
  }

  export type StudentProfileCreateWithoutRoomInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutRoomInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutRoomInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutRoomInput, StudentProfileUncheckedCreateWithoutRoomInput>
  }

  export type StudentProfileCreateManyRoomInputEnvelope = {
    data: StudentProfileCreateManyRoomInput | StudentProfileCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomAmenityCreateWithoutRoomInput = {
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    amenity: AmenityCreateNestedOneWithoutRoomsInput
  }

  export type RoomAmenityUncheckedCreateWithoutRoomInput = {
    amenityId: number
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityCreateOrConnectWithoutRoomInput = {
    where: RoomAmenityWhereUniqueInput
    create: XOR<RoomAmenityCreateWithoutRoomInput, RoomAmenityUncheckedCreateWithoutRoomInput>
  }

  export type RoomAmenityCreateManyRoomInputEnvelope = {
    data: RoomAmenityCreateManyRoomInput | RoomAmenityCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UtilityMeterReadingCreateWithoutRoomInput = {
    type: $Enums.UtilityType
    readingDate: Date | string
    indexValue: number
    billingMonth: number
    billingYear: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtilityMeterReadingUncheckedCreateWithoutRoomInput = {
    id?: number
    type: $Enums.UtilityType
    readingDate: Date | string
    indexValue: number
    billingMonth: number
    billingYear: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtilityMeterReadingCreateOrConnectWithoutRoomInput = {
    where: UtilityMeterReadingWhereUniqueInput
    create: XOR<UtilityMeterReadingCreateWithoutRoomInput, UtilityMeterReadingUncheckedCreateWithoutRoomInput>
  }

  export type UtilityMeterReadingCreateManyRoomInputEnvelope = {
    data: UtilityMeterReadingCreateManyRoomInput | UtilityMeterReadingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutRoomInput = {
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutRoomInput = {
    id?: number
    studentProfileId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRoomInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRoomInput, InvoiceUncheckedCreateWithoutRoomInput>
  }

  export type InvoiceCreateManyRoomInputEnvelope = {
    data: InvoiceCreateManyRoomInput | InvoiceCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutRoomInput = {
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedBy: StudentProfileCreateNestedOneWithoutReportedMaintenancesInput
    assignedTo?: StaffProfileCreateNestedOneWithoutAssignedMaintenancesInput
    images?: MediaCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceUncheckedCreateWithoutRoomInput = {
    id?: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutMaintenanceImagesInput
  }

  export type MaintenanceCreateOrConnectWithoutRoomInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutRoomInput, MaintenanceUncheckedCreateWithoutRoomInput>
  }

  export type MaintenanceCreateManyRoomInputEnvelope = {
    data: MaintenanceCreateManyRoomInput | MaintenanceCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomTransferCreateWithoutFromRoomInput = {
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutRoomTransfersInput
    toRoom: RoomCreateNestedOneWithoutToTransfersInput
    approvedBy?: StaffProfileCreateNestedOneWithoutApprovedTransfersInput
  }

  export type RoomTransferUncheckedCreateWithoutFromRoomInput = {
    id?: number
    studentProfileId: number
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateOrConnectWithoutFromRoomInput = {
    where: RoomTransferWhereUniqueInput
    create: XOR<RoomTransferCreateWithoutFromRoomInput, RoomTransferUncheckedCreateWithoutFromRoomInput>
  }

  export type RoomTransferCreateManyFromRoomInputEnvelope = {
    data: RoomTransferCreateManyFromRoomInput | RoomTransferCreateManyFromRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomTransferCreateWithoutToRoomInput = {
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutRoomTransfersInput
    fromRoom?: RoomCreateNestedOneWithoutFromTransfersInput
    approvedBy?: StaffProfileCreateNestedOneWithoutApprovedTransfersInput
  }

  export type RoomTransferUncheckedCreateWithoutToRoomInput = {
    id?: number
    studentProfileId: number
    fromRoomId?: number | null
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateOrConnectWithoutToRoomInput = {
    where: RoomTransferWhereUniqueInput
    create: XOR<RoomTransferCreateWithoutToRoomInput, RoomTransferUncheckedCreateWithoutToRoomInput>
  }

  export type RoomTransferCreateManyToRoomInputEnvelope = {
    data: RoomTransferCreateManyToRoomInput | RoomTransferCreateManyToRoomInput[]
    skipDuplicates?: boolean
  }

  export type BuildingUpsertWithoutRoomsInput = {
    update: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutRoomsInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type BuildingUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutBuildingImagesNestedInput
    staff?: StaffProfileUpdateManyWithoutManagedBuildingNestedInput
  }

  export type BuildingUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutBuildingImagesNestedInput
    staff?: StaffProfileUncheckedUpdateManyWithoutManagedBuildingNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutRoomImagesInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutRoomImagesInput, MediaUncheckedUpdateWithoutRoomImagesInput>
    create: XOR<MediaCreateWithoutRoomImagesInput, MediaUncheckedCreateWithoutRoomImagesInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutRoomImagesInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutRoomImagesInput, MediaUncheckedUpdateWithoutRoomImagesInput>
  }

  export type MediaUpdateManyWithWhereWithoutRoomImagesInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutRoomImagesInput>
  }

  export type StudentProfileUpsertWithWhereUniqueWithoutRoomInput = {
    where: StudentProfileWhereUniqueInput
    update: XOR<StudentProfileUpdateWithoutRoomInput, StudentProfileUncheckedUpdateWithoutRoomInput>
    create: XOR<StudentProfileCreateWithoutRoomInput, StudentProfileUncheckedCreateWithoutRoomInput>
  }

  export type StudentProfileUpdateWithWhereUniqueWithoutRoomInput = {
    where: StudentProfileWhereUniqueInput
    data: XOR<StudentProfileUpdateWithoutRoomInput, StudentProfileUncheckedUpdateWithoutRoomInput>
  }

  export type StudentProfileUpdateManyWithWhereWithoutRoomInput = {
    where: StudentProfileScalarWhereInput
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyWithoutRoomInput>
  }

  export type StudentProfileScalarWhereInput = {
    AND?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
    OR?: StudentProfileScalarWhereInput[]
    NOT?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
    id?: IntFilter<"StudentProfile"> | number
    userId?: IntFilter<"StudentProfile"> | number
    studentId?: StringFilter<"StudentProfile"> | string
    fullName?: StringFilter<"StudentProfile"> | string
    gender?: EnumGenderFilter<"StudentProfile"> | $Enums.Gender
    birthDate?: DateTimeFilter<"StudentProfile"> | Date | string
    identityCardNumber?: StringFilter<"StudentProfile"> | string
    ethnicity?: StringNullableFilter<"StudentProfile"> | string | null
    religion?: StringNullableFilter<"StudentProfile"> | string | null
    priorityObject?: StringNullableFilter<"StudentProfile"> | string | null
    phoneNumber?: StringFilter<"StudentProfile"> | string
    personalEmail?: StringNullableFilter<"StudentProfile"> | string | null
    faculty?: StringFilter<"StudentProfile"> | string
    courseYear?: IntFilter<"StudentProfile"> | number
    className?: StringNullableFilter<"StudentProfile"> | string | null
    permanentProvince?: StringNullableFilter<"StudentProfile"> | string | null
    permanentDistrict?: StringNullableFilter<"StudentProfile"> | string | null
    permanentAddress?: StringNullableFilter<"StudentProfile"> | string | null
    status?: EnumStudentStatusFilter<"StudentProfile"> | $Enums.StudentStatus
    startDate?: DateTimeFilter<"StudentProfile"> | Date | string
    checkInDate?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    checkOutDate?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    contractEndDate?: DateTimeFilter<"StudentProfile"> | Date | string
    fatherName?: StringNullableFilter<"StudentProfile"> | string | null
    fatherDobYear?: IntNullableFilter<"StudentProfile"> | number | null
    fatherPhone?: StringNullableFilter<"StudentProfile"> | string | null
    fatherAddress?: StringNullableFilter<"StudentProfile"> | string | null
    motherName?: StringNullableFilter<"StudentProfile"> | string | null
    motherDobYear?: IntNullableFilter<"StudentProfile"> | number | null
    motherPhone?: StringNullableFilter<"StudentProfile"> | string | null
    motherAddress?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactRelation?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactPhone?: StringNullableFilter<"StudentProfile"> | string | null
    emergencyContactAddress?: StringNullableFilter<"StudentProfile"> | string | null
    roomId?: IntNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
  }

  export type RoomAmenityUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomAmenityWhereUniqueInput
    update: XOR<RoomAmenityUpdateWithoutRoomInput, RoomAmenityUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomAmenityCreateWithoutRoomInput, RoomAmenityUncheckedCreateWithoutRoomInput>
  }

  export type RoomAmenityUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomAmenityWhereUniqueInput
    data: XOR<RoomAmenityUpdateWithoutRoomInput, RoomAmenityUncheckedUpdateWithoutRoomInput>
  }

  export type RoomAmenityUpdateManyWithWhereWithoutRoomInput = {
    where: RoomAmenityScalarWhereInput
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomAmenityScalarWhereInput = {
    AND?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
    OR?: RoomAmenityScalarWhereInput[]
    NOT?: RoomAmenityScalarWhereInput | RoomAmenityScalarWhereInput[]
    roomId?: IntFilter<"RoomAmenity"> | number
    amenityId?: IntFilter<"RoomAmenity"> | number
    quantity?: IntFilter<"RoomAmenity"> | number
    notes?: StringNullableFilter<"RoomAmenity"> | string | null
    createdAt?: DateTimeFilter<"RoomAmenity"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAmenity"> | Date | string
  }

  export type UtilityMeterReadingUpsertWithWhereUniqueWithoutRoomInput = {
    where: UtilityMeterReadingWhereUniqueInput
    update: XOR<UtilityMeterReadingUpdateWithoutRoomInput, UtilityMeterReadingUncheckedUpdateWithoutRoomInput>
    create: XOR<UtilityMeterReadingCreateWithoutRoomInput, UtilityMeterReadingUncheckedCreateWithoutRoomInput>
  }

  export type UtilityMeterReadingUpdateWithWhereUniqueWithoutRoomInput = {
    where: UtilityMeterReadingWhereUniqueInput
    data: XOR<UtilityMeterReadingUpdateWithoutRoomInput, UtilityMeterReadingUncheckedUpdateWithoutRoomInput>
  }

  export type UtilityMeterReadingUpdateManyWithWhereWithoutRoomInput = {
    where: UtilityMeterReadingScalarWhereInput
    data: XOR<UtilityMeterReadingUpdateManyMutationInput, UtilityMeterReadingUncheckedUpdateManyWithoutRoomInput>
  }

  export type UtilityMeterReadingScalarWhereInput = {
    AND?: UtilityMeterReadingScalarWhereInput | UtilityMeterReadingScalarWhereInput[]
    OR?: UtilityMeterReadingScalarWhereInput[]
    NOT?: UtilityMeterReadingScalarWhereInput | UtilityMeterReadingScalarWhereInput[]
    id?: IntFilter<"UtilityMeterReading"> | number
    roomId?: IntFilter<"UtilityMeterReading"> | number
    type?: EnumUtilityTypeFilter<"UtilityMeterReading"> | $Enums.UtilityType
    readingDate?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    indexValue?: FloatFilter<"UtilityMeterReading"> | number
    billingMonth?: IntFilter<"UtilityMeterReading"> | number
    billingYear?: IntFilter<"UtilityMeterReading"> | number
    notes?: StringNullableFilter<"UtilityMeterReading"> | string | null
    createdAt?: DateTimeFilter<"UtilityMeterReading"> | Date | string
    updatedAt?: DateTimeFilter<"UtilityMeterReading"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutRoomInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutRoomInput, InvoiceUncheckedUpdateWithoutRoomInput>
    create: XOR<InvoiceCreateWithoutRoomInput, InvoiceUncheckedCreateWithoutRoomInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutRoomInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutRoomInput, InvoiceUncheckedUpdateWithoutRoomInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutRoomInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutRoomInput>
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutRoomInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutRoomInput, MaintenanceUncheckedUpdateWithoutRoomInput>
    create: XOR<MaintenanceCreateWithoutRoomInput, MaintenanceUncheckedCreateWithoutRoomInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutRoomInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutRoomInput, MaintenanceUncheckedUpdateWithoutRoomInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutRoomInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomTransferUpsertWithWhereUniqueWithoutFromRoomInput = {
    where: RoomTransferWhereUniqueInput
    update: XOR<RoomTransferUpdateWithoutFromRoomInput, RoomTransferUncheckedUpdateWithoutFromRoomInput>
    create: XOR<RoomTransferCreateWithoutFromRoomInput, RoomTransferUncheckedCreateWithoutFromRoomInput>
  }

  export type RoomTransferUpdateWithWhereUniqueWithoutFromRoomInput = {
    where: RoomTransferWhereUniqueInput
    data: XOR<RoomTransferUpdateWithoutFromRoomInput, RoomTransferUncheckedUpdateWithoutFromRoomInput>
  }

  export type RoomTransferUpdateManyWithWhereWithoutFromRoomInput = {
    where: RoomTransferScalarWhereInput
    data: XOR<RoomTransferUpdateManyMutationInput, RoomTransferUncheckedUpdateManyWithoutFromRoomInput>
  }

  export type RoomTransferUpsertWithWhereUniqueWithoutToRoomInput = {
    where: RoomTransferWhereUniqueInput
    update: XOR<RoomTransferUpdateWithoutToRoomInput, RoomTransferUncheckedUpdateWithoutToRoomInput>
    create: XOR<RoomTransferCreateWithoutToRoomInput, RoomTransferUncheckedCreateWithoutToRoomInput>
  }

  export type RoomTransferUpdateWithWhereUniqueWithoutToRoomInput = {
    where: RoomTransferWhereUniqueInput
    data: XOR<RoomTransferUpdateWithoutToRoomInput, RoomTransferUncheckedUpdateWithoutToRoomInput>
  }

  export type RoomTransferUpdateManyWithWhereWithoutToRoomInput = {
    where: RoomTransferScalarWhereInput
    data: XOR<RoomTransferUpdateManyMutationInput, RoomTransferUncheckedUpdateManyWithoutToRoomInput>
  }

  export type RoomAmenityCreateWithoutAmenityInput = {
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutAmenitiesInput
  }

  export type RoomAmenityUncheckedCreateWithoutAmenityInput = {
    roomId: number
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityCreateOrConnectWithoutAmenityInput = {
    where: RoomAmenityWhereUniqueInput
    create: XOR<RoomAmenityCreateWithoutAmenityInput, RoomAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type RoomAmenityCreateManyAmenityInputEnvelope = {
    data: RoomAmenityCreateManyAmenityInput | RoomAmenityCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type RoomAmenityUpsertWithWhereUniqueWithoutAmenityInput = {
    where: RoomAmenityWhereUniqueInput
    update: XOR<RoomAmenityUpdateWithoutAmenityInput, RoomAmenityUncheckedUpdateWithoutAmenityInput>
    create: XOR<RoomAmenityCreateWithoutAmenityInput, RoomAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type RoomAmenityUpdateWithWhereUniqueWithoutAmenityInput = {
    where: RoomAmenityWhereUniqueInput
    data: XOR<RoomAmenityUpdateWithoutAmenityInput, RoomAmenityUncheckedUpdateWithoutAmenityInput>
  }

  export type RoomAmenityUpdateManyWithWhereWithoutAmenityInput = {
    where: RoomAmenityScalarWhereInput
    data: XOR<RoomAmenityUpdateManyMutationInput, RoomAmenityUncheckedUpdateManyWithoutAmenityInput>
  }

  export type RoomCreateWithoutAmenitiesInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutAmenitiesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityCreateWithoutRoomsInput = {
    name: string
    description?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    description?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityCreateOrConnectWithoutRoomsInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutRoomsInput, AmenityUncheckedCreateWithoutRoomsInput>
  }

  export type RoomUpsertWithoutAmenitiesInput = {
    update: XOR<RoomUpdateWithoutAmenitiesInput, RoomUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<RoomCreateWithoutAmenitiesInput, RoomUncheckedCreateWithoutAmenitiesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutAmenitiesInput, RoomUncheckedUpdateWithoutAmenitiesInput>
  }

  export type RoomUpdateWithoutAmenitiesInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type AmenityUpsertWithoutRoomsInput = {
    update: XOR<AmenityUpdateWithoutRoomsInput, AmenityUncheckedUpdateWithoutRoomsInput>
    create: XOR<AmenityCreateWithoutRoomsInput, AmenityUncheckedCreateWithoutRoomsInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutRoomsInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutRoomsInput, AmenityUncheckedUpdateWithoutRoomsInput>
  }

  export type AmenityUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileCreateWithoutInvoicesInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    room?: RoomCreateNestedOneWithoutResidentsInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutInvoicesInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutInvoicesInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutInvoicesInput, StudentProfileUncheckedCreateWithoutInvoicesInput>
  }

  export type RoomCreateWithoutInvoicesInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutInvoicesInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutInvoicesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutInvoicesInput, RoomUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    type: $Enums.PaymentType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    type: $Enums.PaymentType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    studentProfileId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type StudentProfileUpsertWithoutInvoicesInput = {
    update: XOR<StudentProfileUpdateWithoutInvoicesInput, StudentProfileUncheckedUpdateWithoutInvoicesInput>
    create: XOR<StudentProfileCreateWithoutInvoicesInput, StudentProfileUncheckedCreateWithoutInvoicesInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutInvoicesInput, StudentProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type StudentProfileUpdateWithoutInvoicesInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    room?: RoomUpdateOneWithoutResidentsNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type RoomUpsertWithoutInvoicesInput = {
    update: XOR<RoomUpdateWithoutInvoicesInput, RoomUncheckedUpdateWithoutInvoicesInput>
    create: XOR<RoomCreateWithoutInvoicesInput, RoomUncheckedCreateWithoutInvoicesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutInvoicesInput, RoomUncheckedUpdateWithoutInvoicesInput>
  }

  export type RoomUpdateWithoutInvoicesInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    type?: EnumPaymentTypeFilter<"InvoiceItem"> | $Enums.PaymentType
    description?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutInvoicesInput
    room?: RoomCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    studentProfileId?: number | null
    roomId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutInvoicesNestedInput
    room?: RoomUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutInvoicesInput
    room?: RoomCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: number
    studentProfileId?: number | null
    roomId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type StudentProfileCreateWithoutPaymentsInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    room?: RoomCreateNestedOneWithoutResidentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutPaymentsInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutPaymentsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutInvoicesNestedInput
    room?: RoomUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type StudentProfileUpsertWithoutPaymentsInput = {
    update: XOR<StudentProfileUpdateWithoutPaymentsInput, StudentProfileUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutPaymentsInput, StudentProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentProfileUpdateWithoutPaymentsInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    room?: RoomUpdateOneWithoutResidentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type RoomCreateWithoutMeterReadingsInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutMeterReadingsInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutMeterReadingsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutMeterReadingsInput, RoomUncheckedCreateWithoutMeterReadingsInput>
  }

  export type RoomUpsertWithoutMeterReadingsInput = {
    update: XOR<RoomUpdateWithoutMeterReadingsInput, RoomUncheckedUpdateWithoutMeterReadingsInput>
    create: XOR<RoomCreateWithoutMeterReadingsInput, RoomUncheckedCreateWithoutMeterReadingsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutMeterReadingsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutMeterReadingsInput, RoomUncheckedUpdateWithoutMeterReadingsInput>
  }

  export type RoomUpdateWithoutMeterReadingsInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutMeterReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type RoomCreateWithoutMaintenancesInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutMaintenancesInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutMaintenancesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutMaintenancesInput, RoomUncheckedCreateWithoutMaintenancesInput>
  }

  export type StudentProfileCreateWithoutReportedMaintenancesInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    room?: RoomCreateNestedOneWithoutResidentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutReportedMaintenancesInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutReportedMaintenancesInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutReportedMaintenancesInput, StudentProfileUncheckedCreateWithoutReportedMaintenancesInput>
  }

  export type StaffProfileCreateWithoutAssignedMaintenancesInput = {
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    managedBuilding?: BuildingCreateNestedOneWithoutStaffInput
    approvedTransfers?: RoomTransferCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileUncheckedCreateWithoutAssignedMaintenancesInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    managedBuildingId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedTransfers?: RoomTransferUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type StaffProfileCreateOrConnectWithoutAssignedMaintenancesInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutAssignedMaintenancesInput, StaffProfileUncheckedCreateWithoutAssignedMaintenancesInput>
  }

  export type MediaCreateWithoutMaintenanceImagesInput = {
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserCreateNestedManyWithoutAvatarInput
    roomImages?: RoomCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationCreateNestedManyWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutMaintenanceImagesInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserUncheckedCreateNestedManyWithoutAvatarInput
    roomImages?: RoomUncheckedCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingUncheckedCreateNestedManyWithoutImagesInput
    vehicleImages?: VehicleRegistrationUncheckedCreateNestedManyWithoutImagesInput
  }

  export type MediaCreateOrConnectWithoutMaintenanceImagesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutMaintenanceImagesInput, MediaUncheckedCreateWithoutMaintenanceImagesInput>
  }

  export type RoomUpsertWithoutMaintenancesInput = {
    update: XOR<RoomUpdateWithoutMaintenancesInput, RoomUncheckedUpdateWithoutMaintenancesInput>
    create: XOR<RoomCreateWithoutMaintenancesInput, RoomUncheckedCreateWithoutMaintenancesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutMaintenancesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutMaintenancesInput, RoomUncheckedUpdateWithoutMaintenancesInput>
  }

  export type RoomUpdateWithoutMaintenancesInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutMaintenancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type StudentProfileUpsertWithoutReportedMaintenancesInput = {
    update: XOR<StudentProfileUpdateWithoutReportedMaintenancesInput, StudentProfileUncheckedUpdateWithoutReportedMaintenancesInput>
    create: XOR<StudentProfileCreateWithoutReportedMaintenancesInput, StudentProfileUncheckedCreateWithoutReportedMaintenancesInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutReportedMaintenancesInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutReportedMaintenancesInput, StudentProfileUncheckedUpdateWithoutReportedMaintenancesInput>
  }

  export type StudentProfileUpdateWithoutReportedMaintenancesInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    room?: RoomUpdateOneWithoutResidentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutReportedMaintenancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type StaffProfileUpsertWithoutAssignedMaintenancesInput = {
    update: XOR<StaffProfileUpdateWithoutAssignedMaintenancesInput, StaffProfileUncheckedUpdateWithoutAssignedMaintenancesInput>
    create: XOR<StaffProfileCreateWithoutAssignedMaintenancesInput, StaffProfileUncheckedCreateWithoutAssignedMaintenancesInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutAssignedMaintenancesInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutAssignedMaintenancesInput, StaffProfileUncheckedUpdateWithoutAssignedMaintenancesInput>
  }

  export type StaffProfileUpdateWithoutAssignedMaintenancesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    managedBuilding?: BuildingUpdateOneWithoutStaffNestedInput
    approvedTransfers?: RoomTransferUpdateManyWithoutApprovedByNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutAssignedMaintenancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    managedBuildingId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedTransfers?: RoomTransferUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutMaintenanceImagesInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutMaintenanceImagesInput, MediaUncheckedUpdateWithoutMaintenanceImagesInput>
    create: XOR<MediaCreateWithoutMaintenanceImagesInput, MediaUncheckedCreateWithoutMaintenanceImagesInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutMaintenanceImagesInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutMaintenanceImagesInput, MediaUncheckedUpdateWithoutMaintenanceImagesInput>
  }

  export type MediaUpdateManyWithWhereWithoutMaintenanceImagesInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutMaintenanceImagesInput>
  }

  export type StudentProfileCreateWithoutRoomTransfersInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    room?: RoomCreateNestedOneWithoutResidentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutRoomTransfersInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
    vehicleRegistrations?: VehicleRegistrationUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutRoomTransfersInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutRoomTransfersInput, StudentProfileUncheckedCreateWithoutRoomTransfersInput>
  }

  export type RoomCreateWithoutFromTransfersInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutFromTransfersInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutFromTransfersInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutFromTransfersInput, RoomUncheckedCreateWithoutFromTransfersInput>
  }

  export type RoomCreateWithoutToTransfersInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    images?: MediaCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
  }

  export type RoomUncheckedCreateWithoutToTransfersInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutRoomImagesInput
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
  }

  export type RoomCreateOrConnectWithoutToTransfersInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutToTransfersInput, RoomUncheckedCreateWithoutToTransfersInput>
  }

  export type StaffProfileCreateWithoutApprovedTransfersInput = {
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    managedBuilding?: BuildingCreateNestedOneWithoutStaffInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToInput
  }

  export type StaffProfileUncheckedCreateWithoutApprovedTransfersInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    managedBuildingId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type StaffProfileCreateOrConnectWithoutApprovedTransfersInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutApprovedTransfersInput, StaffProfileUncheckedCreateWithoutApprovedTransfersInput>
  }

  export type StudentProfileUpsertWithoutRoomTransfersInput = {
    update: XOR<StudentProfileUpdateWithoutRoomTransfersInput, StudentProfileUncheckedUpdateWithoutRoomTransfersInput>
    create: XOR<StudentProfileCreateWithoutRoomTransfersInput, StudentProfileUncheckedCreateWithoutRoomTransfersInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutRoomTransfersInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutRoomTransfersInput, StudentProfileUncheckedUpdateWithoutRoomTransfersInput>
  }

  export type StudentProfileUpdateWithoutRoomTransfersInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    room?: RoomUpdateOneWithoutResidentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutRoomTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type RoomUpsertWithoutFromTransfersInput = {
    update: XOR<RoomUpdateWithoutFromTransfersInput, RoomUncheckedUpdateWithoutFromTransfersInput>
    create: XOR<RoomCreateWithoutFromTransfersInput, RoomUncheckedCreateWithoutFromTransfersInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutFromTransfersInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutFromTransfersInput, RoomUncheckedUpdateWithoutFromTransfersInput>
  }

  export type RoomUpdateWithoutFromTransfersInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutFromTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUpsertWithoutToTransfersInput = {
    update: XOR<RoomUpdateWithoutToTransfersInput, RoomUncheckedUpdateWithoutToTransfersInput>
    create: XOR<RoomCreateWithoutToTransfersInput, RoomUncheckedCreateWithoutToTransfersInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutToTransfersInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutToTransfersInput, RoomUncheckedUpdateWithoutToTransfersInput>
  }

  export type RoomUpdateWithoutToTransfersInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutToTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
  }

  export type StaffProfileUpsertWithoutApprovedTransfersInput = {
    update: XOR<StaffProfileUpdateWithoutApprovedTransfersInput, StaffProfileUncheckedUpdateWithoutApprovedTransfersInput>
    create: XOR<StaffProfileCreateWithoutApprovedTransfersInput, StaffProfileUncheckedCreateWithoutApprovedTransfersInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutApprovedTransfersInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutApprovedTransfersInput, StaffProfileUncheckedUpdateWithoutApprovedTransfersInput>
  }

  export type StaffProfileUpdateWithoutApprovedTransfersInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    managedBuilding?: BuildingUpdateOneWithoutStaffNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutApprovedTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    managedBuildingId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type StudentProfileCreateWithoutVehicleRegistrationsInput = {
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    room?: RoomCreateNestedOneWithoutResidentsInput
    invoices?: InvoiceCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceCreateNestedManyWithoutReportedByInput
  }

  export type StudentProfileUncheckedCreateWithoutVehicleRegistrationsInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    roomId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentProfileInput
    roomTransfers?: RoomTransferUncheckedCreateNestedManyWithoutStudentProfileInput
    reportedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type StudentProfileCreateOrConnectWithoutVehicleRegistrationsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutVehicleRegistrationsInput, StudentProfileUncheckedCreateWithoutVehicleRegistrationsInput>
  }

  export type MediaCreateWithoutVehicleImagesInput = {
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserCreateNestedManyWithoutAvatarInput
    roomImages?: RoomCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceCreateNestedManyWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutVehicleImagesInput = {
    id?: number
    filename: string
    path: string
    mimeType: string
    size: number
    mediaType: $Enums.MediaType
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarFor?: UserUncheckedCreateNestedManyWithoutAvatarInput
    roomImages?: RoomUncheckedCreateNestedManyWithoutImagesInput
    buildingImages?: BuildingUncheckedCreateNestedManyWithoutImagesInput
    maintenanceImages?: MaintenanceUncheckedCreateNestedManyWithoutImagesInput
  }

  export type MediaCreateOrConnectWithoutVehicleImagesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutVehicleImagesInput, MediaUncheckedCreateWithoutVehicleImagesInput>
  }

  export type StudentProfileUpsertWithoutVehicleRegistrationsInput = {
    update: XOR<StudentProfileUpdateWithoutVehicleRegistrationsInput, StudentProfileUncheckedUpdateWithoutVehicleRegistrationsInput>
    create: XOR<StudentProfileCreateWithoutVehicleRegistrationsInput, StudentProfileUncheckedCreateWithoutVehicleRegistrationsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutVehicleRegistrationsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutVehicleRegistrationsInput, StudentProfileUncheckedUpdateWithoutVehicleRegistrationsInput>
  }

  export type StudentProfileUpdateWithoutVehicleRegistrationsInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    room?: RoomUpdateOneWithoutResidentsNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutVehicleRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutVehicleImagesInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutVehicleImagesInput, MediaUncheckedUpdateWithoutVehicleImagesInput>
    create: XOR<MediaCreateWithoutVehicleImagesInput, MediaUncheckedCreateWithoutVehicleImagesInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutVehicleImagesInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutVehicleImagesInput, MediaUncheckedUpdateWithoutVehicleImagesInput>
  }

  export type MediaUpdateManyWithWhereWithoutVehicleImagesInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutVehicleImagesInput>
  }

  export type UserCreateWithoutAvatarInput = {
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAvatarInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    loginLogs?: LoginLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAvatarInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
  }

  export type UserCreateManyAvatarInputEnvelope = {
    data: UserCreateManyAvatarInput | UserCreateManyAvatarInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutImagesInput = {
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    residents?: StudentProfileCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingCreateNestedManyWithoutRoomInput
    invoices?: InvoiceCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferCreateNestedManyWithoutToRoomInput
  }

  export type RoomUncheckedCreateWithoutImagesInput = {
    id?: number
    buildingId: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    residents?: StudentProfileUncheckedCreateNestedManyWithoutRoomInput
    amenities?: RoomAmenityUncheckedCreateNestedManyWithoutRoomInput
    meterReadings?: UtilityMeterReadingUncheckedCreateNestedManyWithoutRoomInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutRoomInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutRoomInput
    fromTransfers?: RoomTransferUncheckedCreateNestedManyWithoutFromRoomInput
    toTransfers?: RoomTransferUncheckedCreateNestedManyWithoutToRoomInput
  }

  export type RoomCreateOrConnectWithoutImagesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutImagesInput, RoomUncheckedCreateWithoutImagesInput>
  }

  export type BuildingCreateWithoutImagesInput = {
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutBuildingInput
    staff?: StaffProfileCreateNestedManyWithoutManagedBuildingInput
  }

  export type BuildingUncheckedCreateWithoutImagesInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
    staff?: StaffProfileUncheckedCreateNestedManyWithoutManagedBuildingInput
  }

  export type BuildingCreateOrConnectWithoutImagesInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutImagesInput, BuildingUncheckedCreateWithoutImagesInput>
  }

  export type VehicleRegistrationCreateWithoutImagesInput = {
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutVehicleRegistrationsInput
  }

  export type VehicleRegistrationUncheckedCreateWithoutImagesInput = {
    id?: number
    studentProfileId: number
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleRegistrationCreateOrConnectWithoutImagesInput = {
    where: VehicleRegistrationWhereUniqueInput
    create: XOR<VehicleRegistrationCreateWithoutImagesInput, VehicleRegistrationUncheckedCreateWithoutImagesInput>
  }

  export type MaintenanceCreateWithoutImagesInput = {
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMaintenancesInput
    reportedBy: StudentProfileCreateNestedOneWithoutReportedMaintenancesInput
    assignedTo?: StaffProfileCreateNestedOneWithoutAssignedMaintenancesInput
  }

  export type MaintenanceUncheckedCreateWithoutImagesInput = {
    id?: number
    roomId: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateOrConnectWithoutImagesInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutImagesInput, MaintenanceUncheckedCreateWithoutImagesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutAvatarInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAvatarInput, UserUncheckedUpdateWithoutAvatarInput>
    create: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAvatarInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAvatarInput, UserUncheckedUpdateWithoutAvatarInput>
  }

  export type UserUpdateManyWithWhereWithoutAvatarInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAvatarInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarId?: IntNullableFilter<"User"> | number | null
  }

  export type RoomUpsertWithWhereUniqueWithoutImagesInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutImagesInput, RoomUncheckedUpdateWithoutImagesInput>
    create: XOR<RoomCreateWithoutImagesInput, RoomUncheckedCreateWithoutImagesInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutImagesInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutImagesInput, RoomUncheckedUpdateWithoutImagesInput>
  }

  export type RoomUpdateManyWithWhereWithoutImagesInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutImagesInput>
  }

  export type BuildingUpsertWithWhereUniqueWithoutImagesInput = {
    where: BuildingWhereUniqueInput
    update: XOR<BuildingUpdateWithoutImagesInput, BuildingUncheckedUpdateWithoutImagesInput>
    create: XOR<BuildingCreateWithoutImagesInput, BuildingUncheckedCreateWithoutImagesInput>
  }

  export type BuildingUpdateWithWhereUniqueWithoutImagesInput = {
    where: BuildingWhereUniqueInput
    data: XOR<BuildingUpdateWithoutImagesInput, BuildingUncheckedUpdateWithoutImagesInput>
  }

  export type BuildingUpdateManyWithWhereWithoutImagesInput = {
    where: BuildingScalarWhereInput
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyWithoutImagesInput>
  }

  export type BuildingScalarWhereInput = {
    AND?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
    OR?: BuildingScalarWhereInput[]
    NOT?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
    id?: IntFilter<"Building"> | number
    name?: StringFilter<"Building"> | string
    address?: StringNullableFilter<"Building"> | string | null
    description?: StringNullableFilter<"Building"> | string | null
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
  }

  export type VehicleRegistrationUpsertWithWhereUniqueWithoutImagesInput = {
    where: VehicleRegistrationWhereUniqueInput
    update: XOR<VehicleRegistrationUpdateWithoutImagesInput, VehicleRegistrationUncheckedUpdateWithoutImagesInput>
    create: XOR<VehicleRegistrationCreateWithoutImagesInput, VehicleRegistrationUncheckedCreateWithoutImagesInput>
  }

  export type VehicleRegistrationUpdateWithWhereUniqueWithoutImagesInput = {
    where: VehicleRegistrationWhereUniqueInput
    data: XOR<VehicleRegistrationUpdateWithoutImagesInput, VehicleRegistrationUncheckedUpdateWithoutImagesInput>
  }

  export type VehicleRegistrationUpdateManyWithWhereWithoutImagesInput = {
    where: VehicleRegistrationScalarWhereInput
    data: XOR<VehicleRegistrationUpdateManyMutationInput, VehicleRegistrationUncheckedUpdateManyWithoutImagesInput>
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutImagesInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutImagesInput, MaintenanceUncheckedUpdateWithoutImagesInput>
    create: XOR<MaintenanceCreateWithoutImagesInput, MaintenanceUncheckedCreateWithoutImagesInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutImagesInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutImagesInput, MaintenanceUncheckedUpdateWithoutImagesInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutImagesInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutImagesInput>
  }

  export type UserCreateWithoutLoginLogsInput = {
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatar?: MediaCreateNestedOneWithoutAvatarForInput
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoginLogsInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    avatarId?: number | null
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoginLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
  }

  export type UserUpsertWithoutLoginLogsInput = {
    update: XOR<UserUpdateWithoutLoginLogsInput, UserUncheckedUpdateWithoutLoginLogsInput>
    create: XOR<UserCreateWithoutLoginLogsInput, UserUncheckedCreateWithoutLoginLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginLogsInput, UserUncheckedUpdateWithoutLoginLogsInput>
  }

  export type UserUpdateWithoutLoginLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: MediaUpdateOneWithoutAvatarForNestedInput
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LoginLogCreateManyUserInput = {
    id?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    location?: string | null
  }

  export type LoginLogUpdateWithoutUserInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoginLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoginLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceCreateManyAssignedToInput = {
    id?: number
    roomId: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateManyApprovedByInput = {
    id?: number
    studentProfileId: number
    fromRoomId?: number | null
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceUpdateWithoutAssignedToInput = {
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMaintenancesNestedInput
    reportedBy?: StudentProfileUpdateOneRequiredWithoutReportedMaintenancesNestedInput
    images?: MediaUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUpdateWithoutApprovedByInput = {
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutRoomTransfersNestedInput
    fromRoom?: RoomUpdateOneWithoutFromTransfersNestedInput
    toRoom?: RoomUpdateOneRequiredWithoutToTransfersNestedInput
  }

  export type RoomTransferUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyStudentProfileInput = {
    id?: number
    roomId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyStudentProfileInput = {
    id?: number
    invoiceId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateManyStudentProfileInput = {
    id?: number
    fromRoomId?: number | null
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateManyReportedByInput = {
    id?: number
    roomId: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleRegistrationCreateManyStudentProfileInput = {
    id?: number
    vehicleType: $Enums.VehicleType
    licensePlate: string
    brand?: string | null
    model?: string | null
    color?: string | null
    parkingCardNo?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutStudentProfileInput = {
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutStudentProfileInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUpdateWithoutStudentProfileInput = {
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromRoom?: RoomUpdateOneWithoutFromTransfersNestedInput
    toRoom?: RoomUpdateOneRequiredWithoutToTransfersNestedInput
    approvedBy?: StaffProfileUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type RoomTransferUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUncheckedUpdateManyWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUpdateWithoutReportedByInput = {
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMaintenancesNestedInput
    assignedTo?: StaffProfileUpdateOneWithoutAssignedMaintenancesNestedInput
    images?: MediaUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateManyWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleRegistrationUpdateWithoutStudentProfileInput = {
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutVehicleImagesNestedInput
  }

  export type VehicleRegistrationUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutVehicleImagesNestedInput
  }

  export type VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateManyBuildingInput = {
    id?: number
    number: string
    type: $Enums.RoomType
    capacity: number
    actualOccupancy?: number
    floor: number
    status?: $Enums.RoomStatus
    description?: string | null
    roomFee?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffProfileCreateManyManagedBuildingInput = {
    id?: number
    userId: number
    fullName: string
    phoneNumber?: string | null
    position?: string | null
    identityCardNumber?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateWithoutBuildingImagesInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutBuildingImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUncheckedUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUncheckedUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUncheckedUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutBuildingImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutBuildingInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBuildingInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutRoomImagesNestedInput
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutBuildingInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffProfileUpdateWithoutManagedBuildingInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToNestedInput
    approvedTransfers?: RoomTransferUpdateManyWithoutApprovedByNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutManagedBuildingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToNestedInput
    approvedTransfers?: RoomTransferUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type StaffProfileUncheckedUpdateManyWithoutManagedBuildingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    identityCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileCreateManyRoomInput = {
    id?: number
    userId: number
    studentId: string
    fullName: string
    gender: $Enums.Gender
    birthDate: Date | string
    identityCardNumber: string
    ethnicity?: string | null
    religion?: string | null
    priorityObject?: string | null
    phoneNumber: string
    personalEmail?: string | null
    faculty: string
    courseYear: number
    className?: string | null
    permanentProvince?: string | null
    permanentDistrict?: string | null
    permanentAddress?: string | null
    status?: $Enums.StudentStatus
    startDate: Date | string
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    contractEndDate: Date | string
    fatherName?: string | null
    fatherDobYear?: number | null
    fatherPhone?: string | null
    fatherAddress?: string | null
    motherName?: string | null
    motherDobYear?: number | null
    motherPhone?: string | null
    motherAddress?: string | null
    emergencyContactRelation?: string | null
    emergencyContactPhone?: string | null
    emergencyContactAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityCreateManyRoomInput = {
    amenityId: number
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtilityMeterReadingCreateManyRoomInput = {
    id?: number
    type: $Enums.UtilityType
    readingDate: Date | string
    indexValue: number
    billingMonth: number
    billingYear: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyRoomInput = {
    id?: number
    studentProfileId?: number | null
    billingMonth: number
    billingYear: number
    issueDate?: Date | string
    dueDate: Date | string
    paymentDeadline: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateManyRoomInput = {
    id?: number
    reportedById: number
    issue: string
    reportDate?: Date | string
    status?: $Enums.MaintenanceStatus
    assignedToId?: number | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateManyFromRoomInput = {
    id?: number
    studentProfileId: number
    toRoomId: number
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTransferCreateManyToRoomInput = {
    id?: number
    studentProfileId: number
    fromRoomId?: number | null
    transferDate: Date | string
    reason?: string | null
    adminNotes?: string | null
    approvedById?: number | null
    status?: $Enums.TransferStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateWithoutRoomImagesInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUpdateManyWithoutAvatarNestedInput
    buildingImages?: BuildingUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutRoomImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUncheckedUpdateManyWithoutAvatarNestedInput
    buildingImages?: BuildingUncheckedUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUncheckedUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutRoomImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUpdateWithoutRoomInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentProfileNestedInput
    roomTransfers?: RoomTransferUncheckedUpdateManyWithoutStudentProfileNestedInput
    reportedMaintenances?: MaintenanceUncheckedUpdateManyWithoutReportedByNestedInput
    vehicleRegistrations?: VehicleRegistrationUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    identityCardNumber?: StringFieldUpdateOperationsInput | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    priorityObject?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: StringFieldUpdateOperationsInput | string
    courseYear?: IntFieldUpdateOperationsInput | number
    className?: NullableStringFieldUpdateOperationsInput | string | null
    permanentProvince?: NullableStringFieldUpdateOperationsInput | string | null
    permanentDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    fatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    fatherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    motherDobYear?: NullableIntFieldUpdateOperationsInput | number | null
    motherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    motherAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityUpdateWithoutRoomInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomAmenityUncheckedUpdateWithoutRoomInput = {
    amenityId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityUncheckedUpdateManyWithoutRoomInput = {
    amenityId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilityMeterReadingUpdateWithoutRoomInput = {
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilityMeterReadingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilityMeterReadingUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumUtilityTypeFieldUpdateOperationsInput | $Enums.UtilityType
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    indexValue?: FloatFieldUpdateOperationsInput | number
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutRoomInput = {
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    billingMonth?: IntFieldUpdateOperationsInput | number
    billingYear?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUpdateWithoutRoomInput = {
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StudentProfileUpdateOneRequiredWithoutReportedMaintenancesNestedInput
    assignedTo?: StaffProfileUpdateOneWithoutAssignedMaintenancesNestedInput
    images?: MediaUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutMaintenanceImagesNestedInput
  }

  export type MaintenanceUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUpdateWithoutFromRoomInput = {
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutRoomTransfersNestedInput
    toRoom?: RoomUpdateOneRequiredWithoutToTransfersNestedInput
    approvedBy?: StaffProfileUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type RoomTransferUncheckedUpdateWithoutFromRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUncheckedUpdateManyWithoutFromRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    toRoomId?: IntFieldUpdateOperationsInput | number
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUpdateWithoutToRoomInput = {
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutRoomTransfersNestedInput
    fromRoom?: RoomUpdateOneWithoutFromTransfersNestedInput
    approvedBy?: StaffProfileUpdateOneWithoutApprovedTransfersNestedInput
  }

  export type RoomTransferUncheckedUpdateWithoutToRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTransferUncheckedUpdateManyWithoutToRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    fromRoomId?: NullableIntFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityCreateManyAmenityInput = {
    roomId: number
    quantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAmenityUpdateWithoutAmenityInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type RoomAmenityUncheckedUpdateWithoutAmenityInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAmenityUncheckedUpdateManyWithoutAmenityInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: number
    type: $Enums.PaymentType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: number
    studentProfileId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: string | null
    transactionCode?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutMaintenanceImagesInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutMaintenanceImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUncheckedUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUncheckedUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUncheckedUpdateManyWithoutImagesNestedInput
    vehicleImages?: VehicleRegistrationUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutMaintenanceImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutVehicleImagesInput = {
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutVehicleImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarFor?: UserUncheckedUpdateManyWithoutAvatarNestedInput
    roomImages?: RoomUncheckedUpdateManyWithoutImagesNestedInput
    buildingImages?: BuildingUncheckedUpdateManyWithoutImagesNestedInput
    maintenanceImages?: MaintenanceUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutVehicleImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyAvatarInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUpdateWithoutAvatarInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAvatarInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    loginLogs?: LoginLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAvatarInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomUpdateWithoutImagesInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    residents?: StudentProfileUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    residents?: StudentProfileUncheckedUpdateManyWithoutRoomNestedInput
    amenities?: RoomAmenityUncheckedUpdateManyWithoutRoomNestedInput
    meterReadings?: UtilityMeterReadingUncheckedUpdateManyWithoutRoomNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutRoomNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutRoomNestedInput
    fromTransfers?: RoomTransferUncheckedUpdateManyWithoutFromRoomNestedInput
    toTransfers?: RoomTransferUncheckedUpdateManyWithoutToRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingId?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    actualOccupancy?: IntFieldUpdateOperationsInput | number
    floor?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roomFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
    staff?: StaffProfileUpdateManyWithoutManagedBuildingNestedInput
  }

  export type BuildingUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
    staff?: StaffProfileUncheckedUpdateManyWithoutManagedBuildingNestedInput
  }

  export type BuildingUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleRegistrationUpdateWithoutImagesInput = {
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutVehicleRegistrationsNestedInput
  }

  export type VehicleRegistrationUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleRegistrationUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUpdateWithoutImagesInput = {
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMaintenancesNestedInput
    reportedBy?: StudentProfileUpdateOneRequiredWithoutReportedMaintenancesNestedInput
    assignedTo?: StaffProfileUpdateOneWithoutAssignedMaintenancesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    reportedById?: IntFieldUpdateOperationsInput | number
    issue?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}